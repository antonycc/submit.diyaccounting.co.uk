name: "Set origins"
description: "Set the origin domain for a primary domain"
inputs:
  origin-domain:
    description: "Origin domain to point to."
    required: true
  apex-domain:
    description: "Apex domain to set alias for."
    required: true
  aws-account-id:
    description: "AWS Account ID where the CloudFront distribution exists (used for tag lookups)."
    required: true
  hosted-zone-id:
    description: "AWS Route 53 Hosted Zone ID for the apex domain."
    required: true
  cloudfront-distribution-id:
    description: "CloudFront Distribution ID to update aliases on."
    required: true
  api-gateway-id:
    description: "API Gateway v2 HTTP API ID for custom domain mapping."
    required: false
    default: ""
  regional-certificate-arn:
    description: "ACM certificate ARN (eu-west-2) for API Gateway custom domain."
    required: false
    default: ""
  prod-apex-alias:
    description: "Additional prod alias domain (e.g. submit.diyaccounting.co.uk). Only set for prod."
    required: false
    default: ""
  route53-actions-role-arn:
    description: "OIDC role ARN for the account containing Route53 (cross-account). Leave empty to use current credentials."
    required: false
    default: ""
  route53-deploy-role-arn:
    description: "Deploy role ARN for the account containing Route53 (cross-account). Leave empty to use current credentials."
    required: false
    default: ""
  restore-actions-role-arn:
    description: "OIDC role ARN to restore after Route53 for API Gateway operations. Required if route53-actions-role-arn is set."
    required: false
    default: ""
  restore-deploy-role-arn:
    description: "Deploy role ARN to restore after Route53 for API Gateway operations. Required if restore-actions-role-arn is set."
    required: false
    default: ""

outputs:
  existing-deployment-name:
    description: "Existing deployment name used by any previous CloudFront distribution with the same apex domain."
    value: ${{ steps.cloudfront.outputs.EXISTING_DEPLOYMENT_NAME }}

runs:
  using: "composite"
  steps:
    - name: Replace CloudFront aliases with origin-domain
      id: cloudfront
      shell: bash
      env:
        SET_ORIGINS_ORIGIN_DOMAIN: ${{ inputs.origin-domain }}
        SET_ORIGINS_APEX_DOMAIN: ${{ inputs.apex-domain }}
        SET_ORIGINS_PROD_APEX_ALIAS: ${{ inputs.prod-apex-alias }}
        SET_ORIGINS_AWS_ACCOUNT_ID: ${{ inputs.aws-account-id }}
        SET_ORIGINS_HOSTED_ZONE_ID: ${{ inputs.hosted-zone-id }}
        SET_ORIGINS_CLOUDFRONT_DISTRIBUTION_ID: ${{ inputs.cloudfront-distribution-id }}
      run: |
        set -eo pipefail

        # Skip alias replacement if a CloudFront default domain is provided, as it cannot be an alternate domain
        if [[ "${SET_ORIGINS_ORIGIN_DOMAIN?}" =~ \.cloudfront\.net$ ]]; then
          echo "origin-domain ends with .cloudfront.net; skipping CloudFront alias replacement."
          exit 0
        fi

        echo "Replacing CloudFront aliases on distribution [${SET_ORIGINS_CLOUDFRONT_DISTRIBUTION_ID?}] with: [${SET_ORIGINS_ORIGIN_DOMAIN?}]"

        #aws cloudfront associate-alias \
        #  --target-distribution-id "${SET_ORIGINS_CLOUDFRONT_DISTRIBUTION_ID?}" \
        #  --alias "${SET_ORIGINS_APEX_DOMAIN?}" || true

        # Query for a distribution with alias matching SET_ORIGINS_APEX_DOMAIN and remove all the aliases from that distribution of there are any.
        echo "Checking for existing CloudFront distribution with alias: ${SET_ORIGINS_APEX_DOMAIN?}"
        EXISTING_DISTRIBUTION_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?Aliases.Items!=null && contains(Aliases.Items, '${SET_ORIGINS_APEX_DOMAIN?}')].Id | [0]" \
            --output text)
        if [ -n "$EXISTING_DISTRIBUTION_ID" ] && [ "$EXISTING_DISTRIBUTION_ID" != "None" ] && [ "$EXISTING_DISTRIBUTION_ID" != "${SET_ORIGINS_CLOUDFRONT_DISTRIBUTION_ID?}" ]; then
          echo "Found existing CloudFront distribution [${EXISTING_DISTRIBUTION_ID?}] with alias [${SET_ORIGINS_APEX_DOMAIN?}], removing aliases from that distribution to make way for distribution [${SET_ORIGINS_CLOUDFRONT_DISTRIBUTION_ID?}]."
          EXISTING_ETAG=$(aws cloudfront get-distribution-config \
            --id "${EXISTING_DISTRIBUTION_ID?}" \
            --query 'ETag' \
            --output text)
          aws cloudfront get-distribution-config \
              --id "${EXISTING_DISTRIBUTION_ID?}" \
              --query 'DistributionConfig' \
              --output json > /tmp/existing-cf-config.json

          # Get the value of the OriginFor tag on the existing distribution to restore it after updating
          ORIGIN_FOR_TAG_VALUE=$(aws cloudfront list-tags-for-resource \
            --resource "arn:aws:cloudfront::${SET_ORIGINS_AWS_ACCOUNT_ID?}:distribution/${EXISTING_DISTRIBUTION_ID?}" \
            --query "Tags.Items[?Key=='OriginFor'].Value | [0]" \
            --output text)

          EXISTING_DEPLOYMENT_NAME=
          if [ "$ORIGIN_FOR_TAG_VALUE" != "None" ] && [ -n "$ORIGIN_FOR_TAG_VALUE" ] && [ "$ORIGIN_FOR_TAG_VALUE" != "$SET_ORIGINS_APEX_DOMAIN" ]; then
            echo "Preserving aliases for OriginFor tag value: [${ORIGIN_FOR_TAG_VALUE?}]"
            jq --arg origin "${ORIGIN_FOR_TAG_VALUE?}" '.Aliases = {Quantity: 1, Items: [$origin]}' /tmp/existing-cf-config.json > /tmp/existing-cf-config.updated.json
            EXISTING_DEPLOYMENT_NAME=$(echo "${ORIGIN_FOR_TAG_VALUE?}" | cut -d. -f1)
          else
            jq '.Aliases = {Quantity: 0, Items: []}' /tmp/existing-cf-config.json > /tmp/existing-cf-config.updated.json
          fi
          echo "Updating CloudFront distribution [${EXISTING_DISTRIBUTION_ID?}] matching etag [${EXISTING_ETAG?}] to remove aliases of [${SET_ORIGINS_APEX_DOMAIN?}]"
          aws cloudfront update-distribution \
            --id "${EXISTING_DISTRIBUTION_ID?}" \
            --if-match "${EXISTING_ETAG?}" \
            --distribution-config file:///tmp/existing-cf-config.updated.json
          echo "Waiting for CloudFront distribution [${EXISTING_DISTRIBUTION_ID?}] to deploy updated aliases..."
          aws cloudfront wait distribution-deployed --id "${EXISTING_DISTRIBUTION_ID?}"
          echo "Removed aliases from existing CloudFront distribution [${EXISTING_DISTRIBUTION_ID?}]."
        elif [ -n "$EXISTING_DISTRIBUTION_ID" ] && [ "$EXISTING_DISTRIBUTION_ID" != "None" ] && [ "$EXISTING_DISTRIBUTION_ID" == "${SET_ORIGINS_CLOUDFRONT_DISTRIBUTION_ID?}" ]; then
          echo "Found existing CloudFront distribution ${EXISTING_DISTRIBUTION_ID?} with alias ${SET_ORIGINS_APEX_DOMAIN?}, and it is already target for distribution ${SET_ORIGINS_CLOUDFRONT_DISTRIBUTION_ID?}."
          exit 0
        else
          echo "No existing CloudFront distribution found with alias [${SET_ORIGINS_APEX_DOMAIN?}]."
        fi

        echo "Current CloudFront aliases for: [${SET_ORIGINS_CLOUDFRONT_DISTRIBUTION_ID?}]"
        ETAG=$(aws cloudfront get-distribution-config \
          --id "${SET_ORIGINS_CLOUDFRONT_DISTRIBUTION_ID?}" \
          --query 'ETag' \
          --output text)

        echo "ETag for distribution config for: [${SET_ORIGINS_CLOUDFRONT_DISTRIBUTION_ID}]"
        aws cloudfront get-distribution-config \
          --id "${SET_ORIGINS_CLOUDFRONT_DISTRIBUTION_ID?}" \
          --query 'DistributionConfig' \
          --output json > /tmp/cf-config.json

        if [ -n "${SET_ORIGINS_PROD_APEX_ALIAS:-}" ]; then
          echo "Updating CloudFront aliases to: [${SET_ORIGINS_APEX_DOMAIN?}], [${SET_ORIGINS_ORIGIN_DOMAIN?}], [${SET_ORIGINS_PROD_APEX_ALIAS?}]"
          jq --arg apex "${SET_ORIGINS_APEX_DOMAIN?}" --arg origin "${SET_ORIGINS_ORIGIN_DOMAIN?}" --arg alias "${SET_ORIGINS_PROD_APEX_ALIAS?}" '
            .Aliases = {Quantity: 3, Items: [$apex, $origin, $alias]}
          ' /tmp/cf-config.json > /tmp/cf-config.updated.json
        else
          echo "Updating CloudFront aliases to: [${SET_ORIGINS_APEX_DOMAIN?}], [${SET_ORIGINS_ORIGIN_DOMAIN?}]"
          jq --arg apex "${SET_ORIGINS_APEX_DOMAIN?}" --arg origin "${SET_ORIGINS_ORIGIN_DOMAIN?}" '
            .Aliases = {Quantity: 2, Items: [$apex, $origin]}
          ' /tmp/cf-config.json > /tmp/cf-config.updated.json
        fi

        echo "Updating CloudFront distribution [${SET_ORIGINS_CLOUDFRONT_DISTRIBUTION_ID?}] with new aliases"
        aws cloudfront update-distribution \
          --id "${SET_ORIGINS_CLOUDFRONT_DISTRIBUTION_ID?}" \
          --if-match "${ETAG}" \
          --distribution-config file:///tmp/cf-config.updated.json

        echo "Waiting for CloudFront distribution [${SET_ORIGINS_CLOUDFRONT_DISTRIBUTION_ID?}] to deploy updated aliases..."
        aws cloudfront wait distribution-deployed --id "${SET_ORIGINS_CLOUDFRONT_DISTRIBUTION_ID?}"

        echo "CloudFront aliases now:"
        aws cloudfront get-distribution --id "${SET_ORIGINS_CLOUDFRONT_DISTRIBUTION_ID?}" \
          --query 'Distribution.DistributionConfig.Aliases.Items' --output json

        if [ -n "$EXISTING_DEPLOYMENT_NAME" ]; then
          echo "EXISTING_DEPLOYMENT_NAME=$EXISTING_DEPLOYMENT_NAME" | tee -a "$GITHUB_OUTPUT"
        fi

    # --- Cross-account credential switch for Route53 (if Route53 is in a different account) ---
    - name: Assume Route53 account OIDC role
      if: ${{ inputs.route53-actions-role-arn != '' }}
      uses: aws-actions/configure-aws-credentials@v5
      with:
        role-to-assume: ${{ inputs.route53-actions-role-arn }}
        aws-region: eu-west-2
        role-chaining: false
        audience: sts.amazonaws.com
        role-skip-session-tagging: true
        output-credentials: true
        retry-max-attempts: 3

    - name: Assume Route53 account deploy role
      if: ${{ inputs.route53-deploy-role-arn != '' }}
      uses: aws-actions/configure-aws-credentials@v5
      with:
        role-to-assume: ${{ inputs.route53-deploy-role-arn }}
        aws-region: eu-west-2
        role-chaining: true
        audience: sts.amazonaws.com
        role-skip-session-tagging: true
        output-credentials: true
        retry-max-attempts: 3

    - name: Alias apex domain to base domain
      id: route53
      shell: bash
      env:
        SET_ORIGINS_ORIGIN_DOMAIN: ${{ inputs.origin-domain }}
        SET_ORIGINS_APEX_DOMAIN: ${{ inputs.apex-domain }}
        SET_ORIGINS_PROD_APEX_ALIAS: ${{ inputs.prod-apex-alias }}
        SET_ORIGINS_HOSTED_ZONE_ID: ${{ inputs.hosted-zone-id }}
      run: |
        set -euo pipefail

        CHANGES='[
          {
            "Action": "UPSERT",
            "ResourceRecordSet": {
              "Name": "'"${SET_ORIGINS_APEX_DOMAIN?}"'.",
              "Type": "A",
              "AliasTarget": {
                "HostedZoneId": "'"${SET_ORIGINS_HOSTED_ZONE_ID?}"'",
                "DNSName": "'"${SET_ORIGINS_ORIGIN_DOMAIN?}"'.",
                "EvaluateTargetHealth": false
              }
            }
          },
          {
            "Action": "UPSERT",
            "ResourceRecordSet": {
              "Name": "'"${SET_ORIGINS_APEX_DOMAIN?}"'.",
              "Type": "AAAA",
              "AliasTarget": {
                "HostedZoneId": "'"${SET_ORIGINS_HOSTED_ZONE_ID?}"'",
                "DNSName": "'"${SET_ORIGINS_ORIGIN_DOMAIN?}"'.",
                "EvaluateTargetHealth": false
              }
            }
          }
        ]'

        if [ -n "${SET_ORIGINS_PROD_APEX_ALIAS:-}" ]; then
          echo "Adding prod apex alias DNS: [${SET_ORIGINS_PROD_APEX_ALIAS}] -> [${SET_ORIGINS_ORIGIN_DOMAIN?}]"
          CHANGES=$(echo "$CHANGES" | jq --arg alias "${SET_ORIGINS_PROD_APEX_ALIAS}" --arg origin "${SET_ORIGINS_ORIGIN_DOMAIN?}" --arg zoneId "${SET_ORIGINS_HOSTED_ZONE_ID?}" '. + [
            {
              "Action": "UPSERT",
              "ResourceRecordSet": {
                "Name": ($alias + "."),
                "Type": "A",
                "AliasTarget": {
                  "HostedZoneId": $zoneId,
                  "DNSName": ($origin + "."),
                  "EvaluateTargetHealth": false
                }
              }
            },
            {
              "Action": "UPSERT",
              "ResourceRecordSet": {
                "Name": ($alias + "."),
                "Type": "AAAA",
                "AliasTarget": {
                  "HostedZoneId": $zoneId,
                  "DNSName": ($origin + "."),
                  "EvaluateTargetHealth": false
                }
              }
            }
          ]')
        fi

        CHANGE_BATCH=$(jq -n --argjson changes "$CHANGES" '{"Comment": "Alias apex domain to base domain", "Changes": $changes}')

        echo "Upserting alias records: [${SET_ORIGINS_APEX_DOMAIN?}] -> [${SET_ORIGINS_ORIGIN_DOMAIN?}] in hosted zone [${SET_ORIGINS_HOSTED_ZONE_ID?}]"
        echo "$CHANGE_BATCH" | jq '.Changes[].ResourceRecordSet.Name'
        aws route53 change-resource-record-sets --hosted-zone-id "${SET_ORIGINS_HOSTED_ZONE_ID?}" --change-batch "$CHANGE_BATCH"

    # --- Restore original credentials for API Gateway operations ---
    - name: Restore original OIDC role
      if: ${{ inputs.restore-actions-role-arn != '' }}
      uses: aws-actions/configure-aws-credentials@v5
      with:
        role-to-assume: ${{ inputs.restore-actions-role-arn }}
        aws-region: eu-west-2
        role-chaining: false
        audience: sts.amazonaws.com
        role-skip-session-tagging: true
        output-credentials: true
        retry-max-attempts: 3

    - name: Restore original deploy role
      if: ${{ inputs.restore-deploy-role-arn != '' }}
      uses: aws-actions/configure-aws-credentials@v5
      with:
        role-to-assume: ${{ inputs.restore-deploy-role-arn }}
        aws-region: eu-west-2
        role-chaining: true
        audience: sts.amazonaws.com
        role-skip-session-tagging: true
        output-credentials: true
        retry-max-attempts: 3

    - name: Transfer API Gateway custom domain for apex
      id: apigw-custom-domain
      if: ${{ inputs.api-gateway-id != '' && inputs.regional-certificate-arn != '' }}
      shell: bash
      env:
        SET_ORIGINS_APEX_DOMAIN: ${{ inputs.apex-domain }}
        SET_ORIGINS_PROD_APEX_ALIAS: ${{ inputs.prod-apex-alias }}
        SET_ORIGINS_API_GATEWAY_ID: ${{ inputs.api-gateway-id }}
        SET_ORIGINS_REGIONAL_CERT_ARN: ${{ inputs.regional-certificate-arn }}
      run: |
        set -eo pipefail

        transfer_apigw_domain() {
          local DOMAIN="$1"
          local API_ID="$2"
          local CERT_ARN="$3"

          echo "Transferring API Gateway custom domain [${DOMAIN}] to API [${API_ID}]"

          # Check if domain already exists
          EXISTING=$(aws apigatewayv2 get-domain-names \
            --query "Items[?DomainName=='${DOMAIN}'].DomainName | [0]" --output text 2>/dev/null || echo "None")

          if [ "$EXISTING" != "None" ] && [ -n "$EXISTING" ]; then
            echo "Existing API GW custom domain found for [${DOMAIN}], removing old mappings..."
            MAPPING_IDS=$(aws apigatewayv2 get-api-mappings --domain-name "${DOMAIN}" \
              --query 'Items[*].ApiMappingId' --output text 2>/dev/null || echo "")
            for MID in $MAPPING_IDS; do
              [ -z "$MID" ] || [ "$MID" = "None" ] && continue
              echo "  Deleting mapping [${MID}]"
              aws apigatewayv2 delete-api-mapping --domain-name "${DOMAIN}" --api-mapping-id "$MID"
            done
            echo "  Deleting domain [${DOMAIN}]"
            local DELETE_DELAY=15
            local DELETED=false
            for DELETE_ATTEMPT in 1 2 3 4 5; do
              if aws apigatewayv2 delete-domain-name --domain-name "${DOMAIN}"; then
                DELETED=true
                break
              fi
              echo "  Delete attempt ${DELETE_ATTEMPT}/5 failed (likely rate limited), retrying in ${DELETE_DELAY}s..."
              sleep "${DELETE_DELAY}"
              DELETE_DELAY=$((DELETE_DELAY * 2))
            done
            if [ "$DELETED" != "true" ]; then
              echo "ERROR: Failed to delete API GW custom domain [${DOMAIN}] after 5 attempts"
              return 1
            fi
            echo "  Waiting 10s after domain deletion to avoid rate limiting..."
            sleep 10
          fi

          echo "Creating API GW custom domain [${DOMAIN}] with cert [${CERT_ARN}]"
          local RETRY_DELAY=15
          local CREATED=false
          for ATTEMPT in 1 2 3 4 5; do
            local CREATE_OUTPUT
            CREATE_OUTPUT=$(aws apigatewayv2 create-domain-name \
              --domain-name "${DOMAIN}" \
              --domain-name-configurations "CertificateArn=${CERT_ARN},EndpointType=REGIONAL" 2>&1) && { CREATED=true; break; }
            if echo "$CREATE_OUTPUT" | grep -q "already exists"; then
              echo "  Domain [${DOMAIN}] already exists, proceeding to mapping..."
              CREATED=true
              break
            fi
            echo "  Attempt ${ATTEMPT}/5 failed (${CREATE_OUTPUT}), retrying in ${RETRY_DELAY}s..."
            sleep "${RETRY_DELAY}"
            RETRY_DELAY=$((RETRY_DELAY * 2))
          done
          if [ "$CREATED" != "true" ]; then
            echo "ERROR: Failed to create API GW custom domain [${DOMAIN}] after 5 attempts"
            return 1
          fi

          echo "Creating API mapping for domain [${DOMAIN}] -> API [${API_ID}]"
          aws apigatewayv2 create-api-mapping \
            --domain-name "${DOMAIN}" \
            --api-id "${API_ID}" \
            --stage '$default'

          echo "API GW custom domain [${DOMAIN}] configured successfully"
        }

        # Transfer apex domain
        transfer_apigw_domain "${SET_ORIGINS_APEX_DOMAIN}" "${SET_ORIGINS_API_GATEWAY_ID}" "${SET_ORIGINS_REGIONAL_CERT_ARN}"

        # Transfer prod alias domain if set (sleep to avoid API Gateway TooManyRequestsException)
        if [ -n "${SET_ORIGINS_PROD_APEX_ALIAS:-}" ]; then
          echo "Waiting 15s before next API Gateway domain operation to avoid rate limiting..."
          sleep 15
          transfer_apigw_domain "${SET_ORIGINS_PROD_APEX_ALIAS}" "${SET_ORIGINS_API_GATEWAY_ID}" "${SET_ORIGINS_REGIONAL_CERT_ARN}"
        fi
