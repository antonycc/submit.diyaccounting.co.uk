# deploy: public-url fix for synthetic test (bump)
name: deploy
run-name: "deploy from ${{ github.ref_name }}"
# SPDX-FileCopyrightText: 2025 DIY Accounting Limited
# SPDX-License-Identifier: AGPL-3.0-or-later

concurrency:
  group: deploy-${{ github.ref_name }}
  cancel-in-progress: false

# Bump23

on:
  workflow_dispatch:
    inputs:
      skipDeploy:
        description: 'Skip deploy (run tests only, no deployment)'
        type: choice
        options:
          - 'true'
          - 'false'
        required: false
        default: 'false'
      forceAllStackDeployment:
        description: 'Force re-deploy of all stacks even if they already exist or pass comparison checks'
        type: choice
        options:
          - 'true'
          - 'false'
        required: false
        default: 'true'
      environment-name:
        type: choice
        description: 'Environment name to use instead of computing from branch, e.g. ci or prod'
        required: false
        options:
          - '(auto)'
          - 'ci'
          - 'prod'
        default: '(auto)'
      deployment-name:
        type: string
        description: 'Deployment name to use instead of computing from branch, e.g. ci-lambdas6 or prod-ea373de'
        required: false
        default: ''
      selfDestructDelayHours:
        description: 'Hours before self-destruct triggers for non-prod environments'
        required: false
        default: '2'
      skipTestScenarios:
        description: 'Skip test scenarios for behaviour tests'
        type: choice
        options:
          - 'true'
          - 'false'
        required: false
        default: 'false'
      runProxyBehaviourTests:
        description: 'Run proxy behaviour tests (uses ngrok and Docker)'
        type: choice
        options:
          - 'true'
          - 'false'
        required: false
        default: 'false'
      skipCleanup:
        description: 'Keep test users and native auth enabled after tests (for debugging)'
        type: choice
        options:
          - 'true'
          - 'false'
        required: false
        default: 'false'
  push:
    branches:
      - '**'
      - '!gh_pages'
      - '!dependabot/**'
    paths:
      - 'app/data/**'
      - 'app/functions/**'
      - 'app/lib/**'
      - 'app/services/**'
      - 'infra/main/**'
      - 'web/public/**'
      - '.env.ci'
      - '.env.prod'
      - '**/cdk.json'
      - 'Dockerfile'
      - 'LICENSE'
      - 'package.json'
      - 'pom.xml'
      - 'web/public/submit.catalogue.toml'
      - '.github/workflows/deploy.yml'
  schedule:
    - cron: '11 4 * * *'

permissions:
  id-token: write
  contents: read
  pull-requests: read
  pages: write

env:
  JAVA_VERSION: '25'
  NODE_VERSION: '24'
  AWS_REGION: 'eu-west-2'
  BASE_IMAGE_TAG_PREFIX: 'submit-base'
  GITHUB_ACTOR: ${{ github.actor }}
  SELF_DESTRUCT_DELAY_HOURS: ${{ inputs.selfDestructDelayHours || '2' }}
  BASE_IMAGE_TAG: ${{ github.sha }}
  FORCE_ALL_STACK_DEPLOYMENT: ${{ inputs.forceAllStackDeployment || 'true' }}
  COMMIT_HASH: ${{ github.sha }}
  BUILD_NUMBER: ${{ github.run_number }}
  GITHUB_REF: ${{ github.ref }}
  # GITHUB_REF_TO_ENV: resolved per-job via needs.params.outputs.github-environment

jobs:

  params:
    runs-on: ubuntu-24.04
    steps:
      - name: "github.event_name=[${{ github.event_name }}]"
        run: ":"
      - name: "github.ref=[${{ github.ref }}]"
        run: ":"
      - name: "github.sha=[${{ github.sha }}]"
        run: ":"
      - name: "inputs.skipDeploy=[${{ inputs.skipDeploy }}]"
        run: ":"
      - name: "inputs.forceAllStackDeployment=[${{ inputs.forceAllStackDeployment }}]"
        run: ":"
      - name: "inputs.environment-name=[${{ inputs.environment-name }}]"
        run: ":"
      - name: "inputs.deployment-name=[${{ inputs.deployment-name }}]"
        run: ":"
      - name: "inputs.selfDestructDelayHours=[${{ inputs.selfDestructDelayHours }}]"
        run: ":"
      - name: "inputs.skipTestScenarios=[${{ inputs.skipTestScenarios }}]"
        run: ":"
      - name: "inputs.runProxyBehaviourTests=[${{ inputs.runProxyBehaviourTests }}]"
        run: ":"
      - name: "inputs.skipCleanup=[${{ inputs.skipCleanup }}]"
        run: ":"
      - name: "github.event.head_commit.message=[${{ github.event.head_commit.message }}]"
        run: ":"
      - name: Normalise Params
        id: normalise
        shell: bash
        env:
          RAW_COMMIT_MSG: ${{ github.event.head_commit.message }}
        run: |
          X='${{ inputs.forceAllStackDeployment }}' ; echo "forceAllStackDeployment=${X:-true}" | tee -a "$GITHUB_OUTPUT"
          X='${{ inputs.skipDeploy }}' ; echo "skipDeploy=${X:-false}" | tee -a "$GITHUB_OUTPUT"
          # Convert '(auto)' to empty string for downstream processing
          ENV_NAME='${{ inputs.environment-name }}'; [[ "$ENV_NAME" == "(auto)" ]] && ENV_NAME=""
          echo "environment-name=${ENV_NAME}" | tee -a "$GITHUB_OUTPUT"
          # Resolve GitHub Actions environment from explicit input or branch
          GH_ENV="${ENV_NAME}"
          if [ -z "$GH_ENV" ]; then
            if [ "${{ github.ref }}" == "refs/heads/main" ]; then GH_ENV="prod"; else GH_ENV="ci"; fi
          fi
          echo "github-environment=${GH_ENV}" | tee -a "$GITHUB_OUTPUT"
          echo 'deployment-name=${{ inputs.deployment-name }}' | tee -a "$GITHUB_OUTPUT"
          X='${{ inputs.selfDestructDelayHours }}' ; echo "selfDestructDelayHours=${X:-2}" | tee -a "$GITHUB_OUTPUT"
          X='${{ inputs.skipTestScenarios }}' ; echo "skipTestScenarios=${X:-false}" | tee -a "$GITHUB_OUTPUT"
          X='${{ inputs.runProxyBehaviourTests }}' ; echo "runProxyBehaviourTests=${X:-false}" | tee -a "$GITHUB_OUTPUT"
          X='${{ inputs.skipCleanup }}' ; echo "skipCleanup=${X:-false}" | tee -a "$GITHUB_OUTPUT"
          # Compute isSkippingDeploy: true if skipDeploy=true OR (push event with skip: in commit message)
          SKIP_DEPLOY='${{ inputs.skipDeploy }}'
          EVENT_NAME='${{ github.event_name }}'
          # Sanitize commit message: replace chars outside [a-zA-Z0-9 :-] with -, dedupe spaces and dashes
          COMMIT_MSG=$(printf '%s' "$RAW_COMMIT_MSG" | tr -c 'a-zA-Z0-9 :-' '-' | sed 's/--*/-/g; s/  */ /g')
          if [ "${SKIP_DEPLOY:-false}" = "true" ]; then
            echo "isSkippingDeploy=true" | tee -a "$GITHUB_OUTPUT"
          elif [ "$EVENT_NAME" = "push" ] && echo "$COMMIT_MSG" | grep -q "skip:"; then
            echo "isSkippingDeploy=true" | tee -a "$GITHUB_OUTPUT"
          else
            echo "isSkippingDeploy=false" | tee -a "$GITHUB_OUTPUT"
          fi
    outputs:
      skipDeploy: ${{ steps.normalise.outputs.skipDeploy }}
      forceAllStackDeployment: ${{ steps.normalise.outputs.forceAllStackDeployment }}
      environment-name: ${{ steps.normalise.outputs.environment-name }}
      deployment-name: ${{ steps.normalise.outputs.deployment-name }}
      selfDestructDelayHours: ${{ steps.normalise.outputs.selfDestructDelayHours }}
      skipTestScenarios: ${{ steps.normalise.outputs.skipTestScenarios }}
      runProxyBehaviourTests: ${{ steps.normalise.outputs.runProxyBehaviourTests }}
      skipCleanup: ${{ steps.normalise.outputs.skipCleanup }}
      isSkippingDeploy: ${{ steps.normalise.outputs.isSkippingDeploy }}
      github-environment: ${{ steps.normalise.outputs.github-environment }}

  names:
    needs:
      - params
    runs-on: ubuntu-24.04
    environment: ${{ needs.params.outputs.github-environment }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Configure AWS role via GitHub OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Assume AWS deployment role
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: "needs.params.outputs.isSkippingDeploy=[${{ needs.params.outputs.isSkippingDeploy }}]"
        run: ":"

      - name: If main and skipping deploy, read back last known good prod deployment from SSM Parameter Store
        if: ${{ needs.params.outputs.isSkippingDeploy == 'true' && needs.params.outputs.deployment-name == '' && github.ref == 'refs/heads/main' }}
        run: |
          PARAMETER_NAME="/submit/prod/last-known-good-deployment"
          aws ssm get-parameter --name "$PARAMETER_NAME" --query "Parameter.Value" --output text | tee /tmp/last_known_good_deployment.txt
          echo "Last known good deployment: $(cat /tmp/last_known_good_deployment.txt)"

      - name: If not main and skipping deploy, read back last known good ci deployment from SSM Parameter Store
        if: ${{ needs.params.outputs.isSkippingDeploy == 'true' && needs.params.outputs.deployment-name == '' && github.ref != 'refs/heads/main' }}
        run: |
          PARAMETER_NAME="/submit/ci/last-known-good-deployment"
          aws ssm get-parameter --name "$PARAMETER_NAME" --query "Parameter.Value" --output text | tee /tmp/last_known_good_deployment.txt
          echo "Last known good deployment: $(cat /tmp/last_known_good_deployment.txt)"

      - name: Determine deployment name to use
        id: resolved-deployment-name
        run: |
          # If skipping deploy AND we found a last-known-good deployment, use that
          # Otherwise, pass empty/params value to let get-names compute from commit hash
          if [ "${{ needs.params.outputs.isSkippingDeploy }}" = "true" ] && [ -s /tmp/last_known_good_deployment.txt ]; then
              echo "Using last known good deployment from SSM Parameter Store (skipping deploy)"
              echo "deployment-name=$(cat /tmp/last_known_good_deployment.txt)" | tee -a "$GITHUB_OUTPUT"
          elif [ -n "${{ needs.params.outputs.deployment-name }}" ]; then
              echo "Using explicitly provided deployment name"
              echo "deployment-name=${{ needs.params.outputs.deployment-name }}" | tee -a "$GITHUB_OUTPUT"
          else
              echo "Deployment in progress - get-names will compute deployment name from commit hash"
              echo "deployment-name=" | tee -a "$GITHUB_OUTPUT"
          fi

      - name: Compute deployment name and environment
        id: deployment-config
        uses: './.github/actions/get-names'
        with:
          environment-name: ${{ needs.params.outputs.environment-name || '' }}
          deployment-name: ${{ steps.resolved-deployment-name.outputs.deployment-name }}

      - name: Lookup Cognito from domain convention
        id: lookup-cognito
        uses: './.github/actions/lookup-resources'
        with:
          environment-name: ${{ steps.deployment-config.outputs.environment-name }}
          lookup-cognito: 'true'
    outputs:
      environment-name: ${{ steps.deployment-config.outputs.environment-name }}
      deployment-name: ${{ steps.deployment-config.outputs.deployment-name }}
      base-domain: ${{ steps.deployment-config.outputs.base-domain }}
      base-url:      ${{ steps.deployment-config.outputs.base-url }}
      apex-domain: ${{ steps.deployment-config.outputs.apex-domain }}
      apex-url: ${{ steps.deployment-config.outputs.apex-url }}
      holding-domain: ${{ steps.deployment-config.outputs.holding-domain }}
      holding-url: ${{ steps.deployment-config.outputs.holding-url }}
      prod-apex-alias: ${{ steps.deployment-config.outputs.prod-apex-alias }}
      cognito-user-pool-arn: ${{ steps.lookup-cognito.outputs.cognito-user-pool-arn }}
      cognito-client-id: ${{ steps.lookup-cognito.outputs.cognito-client-id }}

  test:
    name: 'delegate to test workflow'
    needs:
      - params
      - names
    uses: ./.github/workflows/test.yml
    permissions:
      contents: read
      packages: read
      id-token: write
    with:
      environment-name: ${{ needs.names.outputs.environment-name }}
      deployment-name: ${{ needs.names.outputs.deployment-name }}
      runProxyBehaviourTests: ${{ needs.params.outputs.runProxyBehaviourTests }}
    secrets:
      HMRC_SANDBOX_CLIENT_SECRET: ${{ secrets.HMRC_SANDBOX_CLIENT_SECRET }}
      NGROK_AUTHTOKEN: ${{ secrets.NGROK_AUTH_TOKEN }}

  npm-unit-test-coverage:
    name: 'npm unit test with coverage'
    runs-on: ubuntu-latest
    needs:
      - names
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v6

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - run: npm ci

      - run: npm run test:coverage

      - name: Upload coverage reports
        uses: actions/upload-artifact@v6
        if: ${{ !cancelled() }}
        with:
          name: coverage-reports
          path: coverage/
          retention-days: 7

  mvn-package:
    name: 'maven package'
    runs-on: ubuntu-latest
    needs:
      - names
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v6

      - uses: actions/setup-java@v5
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}
          cache: 'maven'

      - name: package
        id: package
        shell: bash
        run: |
          ./mvnw clean verify -DskipTests -Dmaven.compiler.source=${{ env.JAVA_VERSION }} -Dmaven.compiler.target=${{ env.JAVA_VERSION }}

      - name: Self Destruct Start Datetime (ISO 8601) now plus SELF_DESTRUCT_DELAY_HOURS
        id: self-destruct-start
        shell: bash
        run: |
          SELF_DESTRUCT_START_DATETIME=$(date -u -d "+${{ env.SELF_DESTRUCT_DELAY_HOURS }} hours" +"%Y-%m-%dT%H:%M:%SZ")
          echo "SELF_DESTRUCT_START_DATETIME=$SELF_DESTRUCT_START_DATETIME"
          echo "SELF_DESTRUCT_START_DATETIME=$SELF_DESTRUCT_START_DATETIME" >> $GITHUB_OUTPUT

    outputs:
      self-destruct-start-datetime: ${{ steps.self-destruct-start.outputs.SELF_DESTRUCT_START_DATETIME }}

  # NOTE: behaviour-test-submit-vat has been moved to test.yml as behaviour-test-proxy-submit-vat
  # It runs when runProxyBehaviourTests=true is passed to the test workflow

  test-aws-credentials:
    name: 'test aws credentials'
    runs-on: ubuntu-24.04
    environment: ${{ needs.params.outputs.github-environment }}
    steps:
      - name: Configure AWS role via GitHub OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Assume AWS deployment role
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: CDK stacks in eu-west-2 and us-east-1
        run: |
          aws cloudformation describe-stacks --region eu-west-2 --query "Stacks[].StackName" --output text | tr '\t' '\n' | sort
          aws cloudformation describe-stacks --region us-east-1 --query "Stacks[].StackName" --output text | tr '\t' '\n' | sort

  skip-deploy-check:
    name: 'skip deploy check'
    needs:
      - params
    if: ${{ needs.params.outputs.isSkippingDeploy != 'true' }}
    runs-on: ubuntu-24.04
    environment: ${{ needs.params.outputs.github-environment }}
    steps:
      - name: Check if skipDeploy is set
        id: check
        run: |
          echo "params.skipDeploy=${{ needs.params.outputs.skipDeploy }}"
          echo "params.isSkippingDeploy=${{ needs.params.outputs.isSkippingDeploy }}"
          echo "isSkippingDeploy=${{ needs.params.outputs.isSkippingDeploy }}" >> "$GITHUB_OUTPUT"

    outputs:
      isSkippingDeploy: ${{ needs.params.outputs.isSkippingDeploy }}

  docker-build:
    name: 'docker build'
    needs:
      - skip-deploy-check
    runs-on: ubuntu-24.04
    environment: ${{ needs.params.outputs.github-environment }}
    steps:
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker
        uses: docker/setup-buildx-action@v3

      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Node dependencies
        run: npm ci

      - name: Build base image
        run: |
          docker buildx build \
            --platform linux/arm64 \
            --provenance=false \
            --load \
            -t "${{ env.BASE_IMAGE_TAG_PREFIX }}:${{ github.sha }}" \
            -f Dockerfile .

      - name: Save image artifact
        run: |
          mkdir docker-image
          docker save -o docker-image/image.tar "${{ env.BASE_IMAGE_TAG_PREFIX }}:${{ github.sha }}"

      - name: Upload image artifact
        uses: actions/upload-artifact@v6
        with:
          name: docker-image
          path: docker-image/image.tar
          if-no-files-found: error

  wait-for-previous-cleanup:
    name: 'wait for previous cleanup'
    needs:
      - names
    runs-on: ubuntu-24.04
    environment: ${{ needs.params.outputs.github-environment }}
    steps:
      - name: Configure AWS role via GitHub OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Assume AWS deployment role
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Wait for any DELETE_IN_PROGRESS stacks
        run: |
          DEPLOYMENT_PREFIX="${{ needs.names.outputs.deployment-name }}-app"
          MAX_WAIT_SECONDS=300
          POLL_INTERVAL=15
          ELAPSED=0

          echo "Checking for stacks with prefix: ${DEPLOYMENT_PREFIX} in DELETE_IN_PROGRESS state"

          while [ $ELAPSED -lt $MAX_WAIT_SECONDS ]; do
            DELETING_STACKS=$(aws cloudformation list-stacks \
              --stack-status-filter DELETE_IN_PROGRESS \
              --query "StackSummaries[?starts_with(StackName, '${DEPLOYMENT_PREFIX}')].StackName" \
              --output text)

            if [ -z "$DELETING_STACKS" ] || [ "$DELETING_STACKS" == "None" ]; then
              echo "No stacks in DELETE_IN_PROGRESS state. Proceeding with deployment."
              exit 0
            fi

            echo "Found stacks still deleting: ${DELETING_STACKS}"
            echo "Waiting ${POLL_INTERVAL} seconds... (${ELAPSED}s / ${MAX_WAIT_SECONDS}s)"
            sleep $POLL_INTERVAL
            ELAPSED=$((ELAPSED + POLL_INTERVAL))
          done

          echo "Warning: Some stacks may still be deleting after ${MAX_WAIT_SECONDS}s timeout. Proceeding anyway."
          echo "Stacks still in DELETE_IN_PROGRESS: ${DELETING_STACKS}"

  validate-secrets:
    name: 'validate required secrets'
    needs:
      - names
    runs-on: ubuntu-24.04
    environment: ${{ needs.params.outputs.github-environment }}
    steps:
      - name: Configure AWS role via GitHub OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Assume AWS deployment role
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Validate all required secrets exist
        id: validate
        run: |
          ENV_NAME="${{ needs.names.outputs.environment-name }}"
          MISSING=""
          ALL_VALID=true

          echo "=== Validating secrets for environment: $ENV_NAME ==="
          echo ""

          # List of required secrets
          SECRETS=(
            "$ENV_NAME/submit/user-sub-hash-salt"
            "$ENV_NAME/submit/google/client_secret"
            "$ENV_NAME/submit/hmrc/client_secret"
            "$ENV_NAME/submit/hmrc/sandbox_client_secret"
          )

          for SECRET in "${SECRETS[@]}"; do
            echo -n "Checking: $SECRET ... "
            if aws secretsmanager describe-secret --secret-id "$SECRET" --region ${{ env.AWS_REGION }} 2>/dev/null; then
              # Verify it has a value
              VALUE=$(aws secretsmanager get-secret-value --secret-id "$SECRET" \
                --query 'SecretString' --output text --region ${{ env.AWS_REGION }} 2>/dev/null || echo "")
              if [ -n "$VALUE" ] && [ "$VALUE" != "null" ]; then
                echo "OK (has value)"
              else
                echo "EMPTY VALUE"
                MISSING="$MISSING\n  - $SECRET (exists but empty)"
                ALL_VALID=false
              fi
            else
              echo "MISSING"
              MISSING="$MISSING\n  - $SECRET"
              ALL_VALID=false
            fi
          done

          echo ""

          if [ "$ALL_VALID" = "false" ]; then
            echo "=============================================="
            echo "ERROR: Missing or invalid secrets detected!"
            echo "=============================================="
            echo -e "Missing secrets:$MISSING"
            echo ""
            echo "To fix this, run the 'deploy environment' workflow first:"
            echo "  1. Go to Actions -> 'deploy environment'"
            echo "  2. Run workflow for the '$ENV_NAME' environment"
            echo ""
            echo "Or use the 'manage secrets' workflow to check status:"
            echo "  1. Go to Actions -> 'manage secrets'"
            echo "  2. Select 'check' action for '$ENV_NAME' environment"
            echo ""
            exit 1
          fi

          echo "All required secrets validated successfully"
          echo "secrets-valid=true" >> $GITHUB_OUTPUT

      - name: Validate salt secret specifically
        run: |
          ENV_NAME="${{ needs.names.outputs.environment-name }}"
          SECRET_NAME="$ENV_NAME/submit/user-sub-hash-salt"

          echo "=== Salt Secret Validation ==="
          echo "Checking: $SECRET_NAME"

          # Get secret metadata
          METADATA=$(aws secretsmanager describe-secret --secret-id "$SECRET_NAME" --region ${{ env.AWS_REGION }} 2>/dev/null || echo "")

          if [ -z "$METADATA" ]; then
            echo "CRITICAL: Salt secret does not exist!"
            echo "This will cause all Lambda functions to fail at runtime."
            exit 1
          fi

          # Check for tags
          echo ""
          echo "Secret metadata:"
          echo "$METADATA" | jq '{Name: .Name, Created: .CreatedDate, Modified: .LastChangedDate, Tags: .Tags}'

          # Verify value exists and has expected length
          VALUE=$(aws secretsmanager get-secret-value --secret-id "$SECRET_NAME" \
            --query 'SecretString' --output text --region ${{ env.AWS_REGION }} 2>/dev/null || echo "")

          if [ -z "$VALUE" ]; then
            echo "CRITICAL: Salt secret has no value!"
            exit 1
          fi

          VALUE_LENGTH=${#VALUE}
          echo ""
          echo "Salt value length: $VALUE_LENGTH characters"

          # Base64-encoded 32-byte salt should be ~44 characters
          if [ $VALUE_LENGTH -lt 40 ]; then
            echo "WARNING: Salt value seems short (expected ~44 chars for 32-byte base64)"
          else
            echo "Salt value length appears valid"
          fi

          echo ""
          echo "Salt secret validation passed"

    outputs:
      secrets-valid: ${{ steps.validate.outputs.secrets-valid }}

  push-images:
    name: 'push images'
    needs:
      - names
      - skip-deploy-check
      - docker-build
    runs-on: ubuntu-24.04
    environment: ${{ needs.params.outputs.github-environment }}
    steps:

      - name: Configure AWS role via GitHub OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Assume AWS deployment role
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Login to Amazon ECR
        shell: bash
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} \
            | docker login \
                --username AWS \
                --password-stdin "${ECR_REPOSITORY_BASE_URL?}/${ECR_REPOSITORY_NAME?}" \
            ;
        env:
          ECR_REPOSITORY_BASE_URL: ${{ vars.SUBMIT_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
          ECR_REPOSITORY_NAME: ${{ needs.names.outputs.environment-name }}-env-ecr

      - name: Check if image already exists in ECR
        id: image-exists
        shell: bash
        run: |
          REPO_URI="${ECR_REPOSITORY_BASE_URL?}/${ECR_REPOSITORY_NAME?}"
          REPO_NAME="${REPO_URI##*/}"
          echo "Checking if image with tag ${{ github.sha }} exists in $REPO_NAME"
          if aws ecr describe-images --repository-name "$REPO_NAME" --image-ids imageTag="${{ github.sha }}" >/dev/null 2>&1; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi
        env:
          ECR_REPOSITORY_BASE_URL: ${{ vars.SUBMIT_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
          ECR_REPOSITORY_NAME: ${{ needs.names.outputs.environment-name }}-env-ecr

      - name: Checkout
        if: ${{ steps.image-exists.outputs.exists != 'true' }}
        uses: actions/checkout@v6

      - name: Setup Node
        if: ${{ steps.image-exists.outputs.exists != 'true' }}
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Node dependencies
        if: ${{ steps.image-exists.outputs.exists != 'true' }}
        run: npm ci

      - name: Download image artifact
        if: ${{ steps.image-exists.outputs.exists != 'true' }}
        uses: actions/download-artifact@v7
        with:
          name: docker-image
          path: docker-image/

      - name: Load Docker image
        if: ${{ steps.image-exists.outputs.exists != 'true' }}
        run: docker load -i docker-image/image.tar

      - name: Tag and push Docker image to ECR
        if: ${{ steps.image-exists.outputs.exists != 'true' }}
        shell: bash
        run: |
          docker tag "${{ env.BASE_IMAGE_TAG_PREFIX }}:${{ github.sha }}" "${ECR_REPOSITORY_BASE_URL?}/${ECR_REPOSITORY_NAME?}:${{ github.sha }}"
          docker tag "${{ env.BASE_IMAGE_TAG_PREFIX }}:${{ github.sha }}" "${ECR_REPOSITORY_BASE_URL?}/${ECR_REPOSITORY_NAME?}:latest"
          docker push "${ECR_REPOSITORY_BASE_URL?}/${ECR_REPOSITORY_NAME?}:${{ github.sha }}"
          docker push "${ECR_REPOSITORY_BASE_URL?}/${ECR_REPOSITORY_NAME?}:latest"
        env:
          ECR_REPOSITORY_BASE_URL: ${{ vars.SUBMIT_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
          ECR_REPOSITORY_NAME: ${{ needs.names.outputs.environment-name }}-env-ecr
    outputs:
      base-image-tag: ${{ github.sha }}

  push-images-us-east-1:
    name: 'push images us-east-1'
    needs:
      - names
      - skip-deploy-check
      - docker-build
    runs-on: ubuntu-24.04
    environment: ${{ needs.params.outputs.github-environment }}
    steps:

      - name: Configure AWS role via GitHub OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_ACTIONS_ROLE_ARN }}
          aws-region: us-east-1
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Assume AWS deployment role
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_DEPLOY_ROLE_ARN }}
          aws-region: us-east-1
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Login to Amazon ECR in us-east-1
        shell: bash
        run: |
          aws ecr get-login-password --region us-east-1 \
            | docker login \
                --username AWS \
                --password-stdin "${ECR_REPOSITORY_BASE_URL?}/${ECR_REPOSITORY_NAME?}" \
            ;
        env:
          ECR_REPOSITORY_BASE_URL: ${{ vars.SUBMIT_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
          ECR_REPOSITORY_NAME: ${{ needs.names.outputs.environment-name }}-env-ecr-us-east-1

      - name: Check if image already exists in ECR
        id: image-exists
        shell: bash
        run: |
          REPO_URI="${ECR_REPOSITORY_BASE_URL?}/${ECR_REPOSITORY_NAME?}"
          REPO_NAME="${REPO_URI##*/}"
          echo "Checking if image with tag ${{ github.sha }} exists in $REPO_NAME"
          if aws ecr describe-images --region us-east-1 --repository-name "$REPO_NAME" --image-ids imageTag="${{ github.sha }}" >/dev/null 2>&1; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi
        env:
          ECR_REPOSITORY_BASE_URL: ${{ vars.SUBMIT_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
          ECR_REPOSITORY_NAME: ${{ needs.names.outputs.environment-name }}-env-ecr-us-east-1

      - name: Checkout
        if: ${{ steps.image-exists.outputs.exists != 'true' }}
        uses: actions/checkout@v6

      - name: Setup Node
        if: ${{ steps.image-exists.outputs.exists != 'true' }}
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Node dependencies
        if: ${{ steps.image-exists.outputs.exists != 'true' }}
        run: npm ci

      - name: Download image artifact
        if: ${{ steps.image-exists.outputs.exists != 'true' }}
        uses: actions/download-artifact@v7
        with:
          name: docker-image
          path: docker-image/

      - name: Load Docker image
        if: ${{ steps.image-exists.outputs.exists != 'true' }}
        run: docker load -i docker-image/image.tar

      - name: Tag and push Docker image to ECR
        if: ${{ steps.image-exists.outputs.exists != 'true' }}
        shell: bash
        run: |
          docker tag "${{ env.BASE_IMAGE_TAG_PREFIX }}:${{ github.sha }}" "${ECR_REPOSITORY_BASE_URL?}/${ECR_REPOSITORY_NAME?}:${{ github.sha }}"
          docker tag "${{ env.BASE_IMAGE_TAG_PREFIX }}:${{ github.sha }}" "${ECR_REPOSITORY_BASE_URL?}/${ECR_REPOSITORY_NAME?}:latest"
          docker push "${ECR_REPOSITORY_BASE_URL?}/${ECR_REPOSITORY_NAME?}:${{ github.sha }}"
          docker push "${ECR_REPOSITORY_BASE_URL?}/${ECR_REPOSITORY_NAME?}:latest"
        env:
          ECR_REPOSITORY_BASE_URL: ${{ vars.SUBMIT_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
          ECR_REPOSITORY_NAME: ${{ needs.names.outputs.environment-name }}-env-ecr-us-east-1
    outputs:
      base-image-tag: ${{ github.sha }}

  deploy-application-self-destruct:
    if: ${{ needs.params.outputs.isSkippingDeploy != 'true' && github.ref != 'refs/heads/main' && needs.names.outputs.environment-name != 'prod' }}
    name: 'deploy SelfDestructStack via deploy-cdk-stack.yml'
    needs:
      - params
      - names
      - skip-deploy-check
      - mvn-package
      - push-images
    uses: ./.github/workflows/deploy-cdk-stack.yml
    permissions:
      contents: read
      packages: read
      id-token: write
      pages: write
      pull-requests: read
    with:
      stackName: ${{ needs.names.outputs.deployment-name }}-app-SelfDestructStack
      force-stack-deployment: 'true'
      environment-name: ${{ needs.names.outputs.environment-name }}
      deployment-name: ${{ needs.names.outputs.deployment-name }}
      cdk-application: 'application'
      lookup-cognito: 'true'
      self-destruct-start-datetime: ${{ needs.mvn-package.outputs.self-destruct-start-datetime }}
      base-image-tag: ${{ needs.push-images.outputs.base-image-tag }}
      # http-api-url: Looked up from API Gateway custom domain via lookup-resources action
      # website-hash: Downstream of the web publish use ${{ steps.publish-hash.outputs.WEBSITE_HASH }}

  deploy-auth:
    name: 'deploy AuthStack via deploy-cdk-stack.yml'
    needs:
      - names
      - skip-deploy-check
      - push-images
      - validate-secrets
    uses: ./.github/workflows/deploy-cdk-stack.yml
    permissions:
      contents: read
      packages: read
      id-token: write
      pages: write
      pull-requests: read
    with:
      stackName: ${{ needs.names.outputs.deployment-name }}-app-AuthStack
      force-stack-deployment: 'true'
      environment-name: ${{ needs.names.outputs.environment-name }}
      deployment-name: ${{ needs.names.outputs.deployment-name }}
      cdk-application: 'application'
      lookup-cognito: 'true'
      #self-destruct-start-datetime: ${{ needs.mvn-package.outputs.self-destruct-start-datetime }}
      base-image-tag: ${{ needs.push-images.outputs.base-image-tag }}
      # http-api-url: Looked up from API Gateway custom domain via lookup-resources action
      # website-hash: Downstream of the web publish use ${{ steps.publish-hash.outputs.WEBSITE_HASH }}

  deploy-hmrc:
    name: 'deploy HmrcStack via deploy-cdk-stack.yml'
    needs:
      - names
      - skip-deploy-check
      - push-images
      - validate-secrets
    uses: ./.github/workflows/deploy-cdk-stack.yml
    permissions:
      contents: read
      packages: read
      id-token: write
      pages: write
      pull-requests: read
    with:
      stackName: ${{ needs.names.outputs.deployment-name }}-app-HmrcStack
      force-stack-deployment: 'true'
      environment-name: ${{ needs.names.outputs.environment-name }}
      deployment-name: ${{ needs.names.outputs.deployment-name }}
      cdk-application: 'application'
      lookup-cognito: 'true'
      #self-destruct-start-datetime: ${{ needs.mvn-package.outputs.self-destruct-start-datetime }}
      base-image-tag: ${{ needs.push-images.outputs.base-image-tag }}
      # http-api-url: Looked up from API Gateway custom domain via lookup-resources action
      # website-hash: Downstream of the web publish use ${{ steps.publish-hash.outputs.WEBSITE_HASH }}

  deploy-account:
    name: 'deploy AccountStack via deploy-cdk-stack.yml'
    needs:
      - names
      - skip-deploy-check
      - push-images
      - validate-secrets
    uses: ./.github/workflows/deploy-cdk-stack.yml
    permissions:
      contents: read
      packages: read
      id-token: write
      pages: write
      pull-requests: read
    with:
      stackName: ${{ needs.names.outputs.deployment-name }}-app-AccountStack
      force-stack-deployment: 'true'
      environment-name: ${{ needs.names.outputs.environment-name }}
      deployment-name: ${{ needs.names.outputs.deployment-name }}
      cdk-application: 'application'
      lookup-cognito: 'true'
      #self-destruct-start-datetime: ${{ needs.mvn-package.outputs.self-destruct-start-datetime }}
      base-image-tag: ${{ needs.push-images.outputs.base-image-tag }}
      # http-api-url: Looked up from API Gateway custom domain via lookup-resources action
      # website-hash: Downstream of the web publish use ${{ steps.publish-hash.outputs.WEBSITE_HASH }}

  deploy-billing:
    name: 'deploy BillingStack via deploy-cdk-stack.yml'
    needs:
      - names
      - skip-deploy-check
      - push-images
      - validate-secrets
    uses: ./.github/workflows/deploy-cdk-stack.yml
    permissions:
      contents: read
      packages: read
      id-token: write
      pages: write
      pull-requests: read
    with:
      stackName: ${{ needs.names.outputs.deployment-name }}-app-BillingStack
      force-stack-deployment: 'true'
      environment-name: ${{ needs.names.outputs.environment-name }}
      deployment-name: ${{ needs.names.outputs.deployment-name }}
      cdk-application: 'application'
      lookup-cognito: 'true'
      #self-destruct-start-datetime: ${{ needs.mvn-package.outputs.self-destruct-start-datetime }}
      base-image-tag: ${{ needs.push-images.outputs.base-image-tag }}
      # http-api-url: Looked up from API Gateway custom domain via lookup-resources action
      # website-hash: Downstream of the web publish use ${{ steps.publish-hash.outputs.WEBSITE_HASH }}

  deploy-api:
    name: 'deploy api'
    needs:
      - names
      - skip-deploy-check
      - push-images
      - deploy-auth
      - deploy-hmrc
      - deploy-account
      - deploy-billing
    runs-on: ubuntu-24.04
    environment: ${{ needs.params.outputs.github-environment }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Node dependencies
        run: npm ci

      - uses: actions/setup-java@v5
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}
          cache: 'maven'

      - name: Configure AWS role via GitHub OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Assume AWS deployment role
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Cache Maven build output
        uses: actions/cache@v4
        with:
          path: target
          key: maven-target-${{ hashFiles('infra/main/java/**', 'infra/main/resources/**', 'pom.xml') }}

      - name: Deploy API stack (CDK)
        run: |
          if [ ! -f target/submit-application.jar ]; then
            echo "Maven output not cached, building with profile cdk-application..."
            ./mvnw --errors clean verify -DskipTests \
              -Dmaven.compiler.source=${{ env.JAVA_VERSION }} -Dmaven.compiler.target=${{ env.JAVA_VERSION }} \
              -P cdk-application
          else
            echo "Maven output cached (target/submit-application.jar exists), skipping build"
          fi
          cd cdk-application
          cat ../.env.${{ needs.names.outputs.environment-name }}
          npx dotenv -e ../.env.${{ needs.names.outputs.environment-name }} -- \
            npx cdk deploy \
              ${{ needs.names.outputs.deployment-name }}-app-ApiStack \
              --exclusively \
              --require-approval never \
              --ci true \
              --no-notices \
              --concurrency 4 \
              --asset-parallelism \
              --outputs-file ../cdk-submit-application.out/cdk-outputs-api.json
          cd ..
        env:
          ENVIRONMENT_NAME: ${{ needs.names.outputs.environment-name }}
          DEPLOYMENT_NAME: ${{ needs.names.outputs.deployment-name }}
          BASE_IMAGE_TAG: ${{ needs.push-images.outputs.base-image-tag }}
          # Looked up from Cognito domain convention in names job
          COGNITO_USER_POOL_ARN: ${{ needs.names.outputs.cognito-user-pool-arn }}
          COGNITO_CLIENT_ID: ${{ needs.names.outputs.cognito-client-id }}

      - run: cat cdk-submit-application.out/cdk-outputs-api.json | jq '.'

      - name: Resolve stack outputs
        id: api-outputs
        run: |
          HTTP_API_URL=$(jq -r '.["${{ needs.names.outputs.deployment-name }}-app-ApiStack"].HttpApiUrl' cdk-submit-application.out/cdk-outputs-api.json)
          echo "HTTP_API_URL=$HTTP_API_URL"
          echo "HTTP_API_URL=$HTTP_API_URL" >> $GITHUB_OUTPUT
          HTTP_API_ID=$(jq -r '.["${{ needs.names.outputs.deployment-name }}-app-ApiStack"].HttpApiId' cdk-submit-application.out/cdk-outputs-api.json)
          echo "HTTP_API_ID=$HTTP_API_ID"
          echo "HTTP_API_ID=$HTTP_API_ID" >> $GITHUB_OUTPUT
        shell: bash

      - name: Force API Gateway re-deployment
        id: force-redeploy
        run: |
          API_ID="${{ steps.api-outputs.outputs.HTTP_API_ID }}"
          echo "API_ID=$API_ID"
          if [ -z "$API_ID" ] || [ "$API_ID" = "null" ]; then
            echo "ERROR: Could not resolve HttpApiId from CDK outputs"
            exit 1
          fi

          echo "Creating new API Gateway deployment for API: $API_ID"
          DEPLOYMENT_ID=$(aws apigatewayv2 create-deployment \
            --api-id "$API_ID" \
            --description "Forced deployment from build ${{ env.BUILD_NUMBER }}" \
            --query 'DeploymentId' \
            --output text)
          echo "Created deployment: $DEPLOYMENT_ID"

          echo "Disabling AutoDeploy to allow manual stage update"
          aws apigatewayv2 update-stage \
            --api-id "$API_ID" \
            --stage-name '$default' \
            --no-auto-deploy

          echo "Updating \$default stage to use deployment: $DEPLOYMENT_ID"
          aws apigatewayv2 update-stage \
            --api-id "$API_ID" \
            --stage-name '$default' \
            --deployment-id "$DEPLOYMENT_ID"

          echo "Re-enabling AutoDeploy"
          aws apigatewayv2 update-stage \
            --api-id "$API_ID" \
            --stage-name '$default' \
            --auto-deploy

          echo "API Gateway re-deployment complete"
        shell: bash
    outputs:
      # TODO: Can this be derived from shared names?
      httpApiUrl: ${{ steps.api-outputs.outputs.HTTP_API_URL }}
      httpApiId: ${{ steps.api-outputs.outputs.HTTP_API_ID }}

  deploy-edge:
    name: 'deploy EdgeStack via deploy-cdk-stack.yml'
    needs:
      - params
      - names
      - skip-deploy-check
      - mvn-package
      - push-images
      - deploy-auth
      - deploy-hmrc
      - deploy-account
      - deploy-api
    uses: ./.github/workflows/deploy-cdk-stack.yml
    permissions:
      contents: read
      packages: read
      id-token: write
      pages: write
      pull-requests: read
    with:
      stackName: ${{ needs.names.outputs.deployment-name }}-app-EdgeStack
      force-stack-deployment: ${{ needs.params.outputs.forceAllStackDeployment }}
      environment-name: ${{ needs.names.outputs.environment-name }}
      deployment-name: ${{ needs.names.outputs.deployment-name }}
      cdk-application: 'application'
      lookup-cognito: 'true'
      #self-destruct-start-datetime: ${{ needs.mvn-package.outputs.self-destruct-start-datetime }}
      base-image-tag: ${{ needs.push-images.outputs.base-image-tag }}
      lookup-api-gateway: 'true'
      # website-hash: Downstream of the web publish use ${{ steps.publish-hash.outputs.WEBSITE_HASH }}

  deploy-publish:
    name: 'deploy publish'
    needs:
      - params
      - names
      - skip-deploy-check
      - mvn-package
      - push-images
      - deploy-edge
      - deploy-api
    runs-on: ubuntu-24.04
    environment: ${{ needs.params.outputs.github-environment }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Node dependencies
        run: npm ci

      - uses: actions/setup-java@v5
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}
          cache: 'maven'

      - name: Configure AWS role via GitHub OIDC (for RUM outputs)
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Assume AWS deployment role (for RUM outputs)
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Lookup API Gateway from domain convention
        id: lookup-api
        uses: './.github/actions/lookup-resources'
        with:
          environment-name: ${{ needs.names.outputs.environment-name }}
          deployment-name: ${{ needs.names.outputs.deployment-name }}
          lookup-cognito: 'false'
          lookup-api-gateway: 'true'

      - name: Resolve RUM config from ObservabilityStack
        id: rum-config
        shell: bash
        run: |
          set -euo pipefail
          STACK_NAME="${{ needs.names.outputs.environment-name }}-env-ObservabilityStack"
          echo "Resolving RUM outputs from $STACK_NAME in region ${{ env.AWS_REGION }}"
          JSON=$(aws cloudformation describe-stacks --stack-name "$STACK_NAME" --region "${{ env.AWS_REGION }}")
          RUM_APP_MONITOR_ID=$(echo "$JSON" | jq -r '.Stacks[0].Outputs[] | select(.OutputKey=="RumAppMonitorId") | .OutputValue')
          RUM_IDENTITY_POOL_ID=$(echo "$JSON" | jq -r '.Stacks[0].Outputs[] | select(.OutputKey=="RumIdentityPoolId") | .OutputValue')
          RUM_GUEST_ROLE_ARN=$(echo "$JSON" | jq -r '.Stacks[0].Outputs[] | select(.OutputKey=="RumGuestRoleArn") | .OutputValue')
          RUM_REGION=$(echo "$JSON" | jq -r '.Stacks[0].Outputs[] | select(.OutputKey=="RumRegion") | .OutputValue' 2>/dev/null || echo "${{ env.AWS_REGION }}")
          echo "RUM_APP_MONITOR_ID=$RUM_APP_MONITOR_ID"
          echo "RUM_IDENTITY_POOL_ID=$RUM_IDENTITY_POOL_ID"
          echo "RUM_GUEST_ROLE_ARN=$RUM_GUEST_ROLE_ARN"
          echo "RUM_REGION=$RUM_REGION"
          echo "RUM_APP_MONITOR_ID=$RUM_APP_MONITOR_ID" >> $GITHUB_OUTPUT
          echo "RUM_IDENTITY_POOL_ID=$RUM_IDENTITY_POOL_ID" >> $GITHUB_OUTPUT
          echo "RUM_GUEST_ROLE_ARN=$RUM_GUEST_ROLE_ARN" >> $GITHUB_OUTPUT
          echo "RUM_REGION=$RUM_REGION" >> $GITHUB_OUTPUT

      - name: Inject RUM placeholders into HTML files
        shell: bash
        env:
          RUM_APP_MONITOR_ID: ${{ steps.rum-config.outputs.RUM_APP_MONITOR_ID }}
          RUM_IDENTITY_POOL_ID: ${{ steps.rum-config.outputs.RUM_IDENTITY_POOL_ID }}
          RUM_GUEST_ROLE_ARN: ${{ steps.rum-config.outputs.RUM_GUEST_ROLE_ARN }}
          AWS_REGION: ${{ steps.rum-config.outputs.RUM_REGION || env.AWS_REGION }}
        run: |
          set -euo pipefail

          echo 'Injecting RUM config into HTML files under web/public'
          echo '----------------------------------------------------'

          # Fail early if required variables are missing
            : "${RUM_APP_MONITOR_ID:?Missing RUM_APP_MONITOR_ID}"
            : "${RUM_IDENTITY_POOL_ID:?Missing RUM_IDENTITY_POOL_ID}"
            : "${RUM_GUEST_ROLE_ARN:?Missing RUM_GUEST_ROLE_ARN}"
            : "${AWS_REGION:?Missing AWS_REGION}"

          # Escape sed replacement strings safely
            escape_sed_replacement() {
            printf '%s' "$1" | sed -e 's/[\/&]/\\&/g'
          }

          RUM_APP_MONITOR_ID_ESCAPED="$(escape_sed_replacement "${RUM_APP_MONITOR_ID}")"
          RUM_IDENTITY_POOL_ID_ESCAPED="$(escape_sed_replacement "${RUM_IDENTITY_POOL_ID}")"
          RUM_GUEST_ROLE_ARN_ESCAPED="$(escape_sed_replacement "${RUM_GUEST_ROLE_ARN}")"
          AWS_REGION_ESCAPED="$(escape_sed_replacement "${AWS_REGION}")"

          # Find and process HTML files safely (null-delimited)
          find web/public -type f -name '*.html' -print0 |
          while IFS= read -r -d '' html_file; do
            echo "Processing ${html_file}"

            # Perform in-place replacements (case-insensitive placeholders)
            sed -i \
            -e "s|\${RUM_APP_MONITOR_ID}|${RUM_APP_MONITOR_ID_ESCAPED}|gI" \
            -e "s|\${RUM_IDENTITY_POOL_ID}|${RUM_IDENTITY_POOL_ID_ESCAPED}|gI" \
            -e "s|\${RUM_GUEST_ROLE_ARN}|${RUM_GUEST_ROLE_ARN_ESCAPED}|gI" \
            -e "s|\${AWS_REGION}|${AWS_REGION_ESCAPED}|gI" \
            "${html_file}"
          done

          echo 'RUM placeholder injection complete'

      - name: Generate web/public/submit.env for client auth config
        shell: bash
        run: |
          set -euo pipefail
          # Load variables from the environment-specific .env file and write to web/public/submit.env
          npx dotenv -e .env.${{ needs.names.outputs.environment-name }} -- bash -c 'cat > web/public/submit.env <<EOF
          COGNITO_CLIENT_ID=${COGNITO_CLIENT_ID:-${{ needs.names.outputs.cognito-client-id }}}
          COGNITO_BASE_URI=https://${{ needs.names.outputs.environment-name }}-auth.diyaccounting.co.uk

          HMRC_CLIENT_ID=${HMRC_CLIENT_ID}
          HMRC_BASE_URI=${HMRC_BASE_URI}

          HMRC_SANDBOX_CLIENT_ID=${HMRC_SANDBOX_CLIENT_ID}
          HMRC_SANDBOX_BASE_URI=${HMRC_SANDBOX_BASE_URI}

          DIY_SUBMIT_BASE_URL=${DIY_SUBMIT_BASE_URL}
          EOF'

      - name: Compute hash of static website content
        id: publish-hash
        shell: bash
        run: |
          WEBSITE_HASH=$(find 'web/public' -type f -exec sha256sum {} + | sort -k 2 | sha256sum | awk '{print $1}')
          echo "WEBSITE_HASH=$WEBSITE_HASH"
          echo "WEBSITE_HASH=$WEBSITE_HASH" >> $GITHUB_OUTPUT

      - name: Compare current submit.commit-hash.txt with computed hash
        id: publish-compare
        shell: bash
        run: |
          EDGE_HASH_URL="${{ needs.names.outputs.base-url }}/submit.commit-hash.txt"
          echo "Fetching existing hash from $EDGE_HASH_URL"
          EXISTING_HASH=$(curl --fail --silent --show-error --location "$EDGE_HASH_URL" || echo "")
          echo "EXISTING_HASH=$EXISTING_HASH"
          echo "EXISTING_HASH=$EXISTING_HASH" >> $GITHUB_OUTPUT
          if [ "$EXISTING_HASH" == "${{ steps.publish-hash.outputs.WEBSITE_HASH }}" ]; then
            echo "skipPublishStackDeployment=true" >> "$GITHUB_OUTPUT"
          else
            echo "skipPublishStackDeployment=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Configure AWS role via GitHub OIDC
        if: ${{ needs.names.outputs.environment-name == 'prod' || needs.params.outputs.forceAllStackDeployment == 'true' || steps.publish-compare.outputs.skipPublishStackDeployment != 'true' }}
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Assume AWS deployment role
        if: ${{ needs.names.outputs.environment-name == 'prod' || needs.params.outputs.forceAllStackDeployment == 'true' || steps.publish-compare.outputs.skipPublishStackDeployment != 'true' }}
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Cache Maven build output
        if: ${{ needs.names.outputs.environment-name == 'prod' || needs.params.outputs.forceAllStackDeployment == 'true' || steps.publish-compare.outputs.skipPublishStackDeployment != 'true' }}
        uses: actions/cache@v4
        with:
          path: target
          key: maven-target-${{ hashFiles('infra/main/java/**', 'infra/main/resources/**', 'pom.xml') }}

      - name: Build CDK and synthesize and deploy the PublishStack in the Application
        if: ${{ needs.names.outputs.environment-name == 'prod' || needs.params.outputs.forceAllStackDeployment == 'true' || steps.publish-compare.outputs.skipPublishStackDeployment != 'true' }}
        run: |
          if [ ! -f target/submit-application.jar ]; then
            echo "Maven output not cached, building with profile cdk-application..."
            ./mvnw --errors clean verify -DskipTests \
              -Dmaven.compiler.source=${{ env.JAVA_VERSION }} -Dmaven.compiler.target=${{ env.JAVA_VERSION }} \
              -P cdk-application
          else
            echo "Maven output cached (target/submit-application.jar exists), skipping build"
          fi
          cd cdk-application
          cat ../.env.${{ needs.names.outputs.environment-name }}
          npx dotenv -e ../.env.${{ needs.names.outputs.environment-name }} -- \
            npx cdk deploy \
              ${{ needs.names.outputs.deployment-name }}-app-PublishStack \
              --exclusively \
              --require-approval never \
              --ci true \
              --no-notices \
              --concurrency 4 \
              --asset-parallelism \
              --outputs-file ../cdk-submit-application.out/cdk-outputs-publish.json
          cd ..
        env:
          ENVIRONMENT_NAME: ${{ needs.names.outputs.environment-name }}
          DEPLOYMENT_NAME: ${{ needs.names.outputs.deployment-name }}
          BASE_IMAGE_TAG: ${{ needs.push-images.outputs.base-image-tag }}
          WEBSITE_HASH: ${{ steps.publish-hash.outputs.WEBSITE_HASH }}
          HTTP_API_URL: ${{ steps.lookup-api.outputs.http-api-url }}
          DIY_SUBMIT_APEX_URL: ${{ needs.names.outputs.apex-url }}
          # Looked up from Cognito domain convention in names job
          COGNITO_USER_POOL_ARN: ${{ needs.names.outputs.cognito-user-pool-arn }}
          COGNITO_CLIENT_ID: ${{ needs.names.outputs.cognito-client-id }}

  deploy-ops:
    name: 'deploy OpsStack via deploy-cdk-stack.yml'
    needs:
      - params
      - names
      - skip-deploy-check
      - mvn-package
      - push-images
      - deploy-api
      - deploy-edge
    uses: ./.github/workflows/deploy-cdk-stack.yml
    permissions:
      contents: read
      packages: read
      id-token: write
      pages: write
      pull-requests: read
    with:
      stackName: ${{ needs.names.outputs.deployment-name }}-app-OpsStack
      force-stack-deployment: ${{ needs.params.outputs.forceAllStackDeployment }}
      environment-name: ${{ needs.names.outputs.environment-name }}
      deployment-name: ${{ needs.names.outputs.deployment-name }}
      cdk-application: 'application'
      lookup-cognito: 'true'
      #self-destruct-start-datetime: ${{ needs.mvn-package.outputs.self-destruct-start-datetime }}
      base-image-tag: ${{ needs.push-images.outputs.base-image-tag }}
      lookup-api-gateway: 'true'
      # website-hash: Downstream of the web publish use ${{ steps.publish-hash.outputs.WEBSITE_HASH }}

  set-origins:
    name: 'set origins'
    #if: ${{ needs.names.outputs.environment-name != 'prod' || needs.origin-test.outputs.result == 'success' }}
    needs:
      - names
      - skip-deploy-check
      - deploy-api
      - deploy-auth
      - deploy-hmrc
      - deploy-account
      - deploy-edge
      - deploy-publish
    runs-on: ubuntu-24.04
    environment: ${{ needs.names.outputs.environment-name }}
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Configure AWS role via GitHub OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Assume AWS deployment role
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Lookup CloudFront and API Gateway from domain convention
        id: lookup-resources
        uses: './.github/actions/lookup-resources'
        with:
          environment-name: ${{ needs.names.outputs.environment-name }}
          deployment-name: ${{ needs.names.outputs.deployment-name }}
          lookup-cognito: 'false'
          lookup-api-gateway: 'true'
          lookup-cloudfront: 'true'

      - name: Alias apex domain to base domain
        id: set-origins
        uses: './.github/actions/set-origins'
        with:
          origin-domain: ${{ needs.names.outputs.base-domain }}
          apex-domain: ${{ needs.names.outputs.apex-domain }}
          prod-apex-alias: ${{ needs.names.outputs.prod-apex-alias }}
          aws-account-id: ${{ vars.SUBMIT_ACCOUNT_ID }}
          hosted-zone-id: ${{ vars.ROOT_HOSTED_ZONE_ID }}
          cloudfront-distribution-id: ${{ steps.lookup-resources.outputs.cloudfront-distribution-id }}
          api-gateway-id: ${{ steps.lookup-resources.outputs.http-api-id }}
          regional-certificate-arn: ${{ vars.SUBMIT_REGIONAL_CERTIFICATE_ARN }}
          route53-actions-role-arn: ${{ vars.ROOT_ACTIONS_ROLE_ARN }}
          route53-deploy-role-arn: ${{ vars.ROOT_DEPLOY_ROLE_ARN }}
          restore-actions-role-arn: ${{ vars.SUBMIT_ACTIONS_ROLE_ARN }}
          restore-deploy-role-arn: ${{ vars.SUBMIT_DEPLOY_ROLE_ARN }}
    outputs:
      existing-deployment-name: ${{ steps.set-origins.outputs.existing-deployment-name }}

  # TODO: Uncomment to enable data migrations in the deploy pipeline.
  # Pre-deploy migrations (e.g., salt format conversion) run before CDK deploy.
  # Post-deploy migrations (e.g., backfill saltVersion) run after CDK deploy.
  # For now, run migrations manually via the run-migrations.yml workflow.
  #
  # run-post-deploy-migrations:
  #   name: 'run post-deploy migrations'
  #   needs:
  #     - names
  #     - deploy-publish
  #   uses: ./.github/workflows/run-migrations.yml
  #   permissions:
  #     contents: read
  #     id-token: write
  #   with:
  #     environment-name: ${{ needs.names.outputs.environment-name }}
  #     phase: 'post-deploy'

  enable-native-auth:
    if: ${{ !cancelled() }}
    name: 'enable native auth for behaviour tests'
    needs:
      - names
      - deploy-publish
    runs-on: ubuntu-24.04
    environment: ${{ needs.params.outputs.github-environment }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --ignore-scripts
        env:
          PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: 1

      - name: Configure AWS role via GitHub OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Assume AWS deployment role
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Enable native auth on Cognito Hosted UI
        shell: bash
        run: |
          ENV_FILE=".env.${{ needs.names.outputs.environment-name }}"
          PROVIDER=$(grep -E '^TEST_AUTH_PROVIDER=' "$ENV_FILE" | tail -n1 | cut -d'=' -f2)
          if [ "$PROVIDER" = "cognito-native" ]; then
            node scripts/toggle-cognito-native-auth.js enable "${{ needs.names.outputs.environment-name }}"
          else
            echo "Skipping native auth toggle (TEST_AUTH_PROVIDER=${PROVIDER:-unset})"
          fi

      # Each test creates its own Cognito user via synthetic-test.yml to avoid
      # race conditions when parallel tests manipulate bundles for the same user

  verify-api:
    if: ${{ !cancelled() }}
    name: 'verify API endpoints are reachable'
    needs:
      - names
      - set-origins
      - deploy-publish
    runs-on: ubuntu-24.04
    steps:
      - name: Wait for DNS propagation
        run: sleep 10

      - name: Verify API health via HEAD /api/v1/cognito/token
        run: |
          APEX_URL="${{ needs.names.outputs.apex-url }}"
          ENDPOINT="${APEX_URL}api/v1/cognito/token"
          echo "Checking API endpoint: $ENDPOINT"

          MAX_RETRIES=5
          RETRY_DELAY=10
          ATTEMPT=0

          while [ $ATTEMPT -lt $MAX_RETRIES ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "Attempt $ATTEMPT of $MAX_RETRIES..."

            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --head --max-time 15 "$ENDPOINT" || echo "000")
            echo "HTTP status: $HTTP_STATUS"

            if [ "$HTTP_STATUS" = "404" ] || [ "$HTTP_STATUS" = "000" ]; then
              echo "API route not reachable (status: $HTTP_STATUS)"
              if [ $ATTEMPT -lt $MAX_RETRIES ]; then
                echo "Retrying in ${RETRY_DELAY}s..."
                sleep $RETRY_DELAY
              fi
            else
              echo "API route is reachable (status: $HTTP_STATUS)"
              exit 0
            fi
          done

          echo "ERROR: API routes are unreachable after $MAX_RETRIES attempts."
          echo "This likely means the API Gateway deployment is stale."
          echo "The \$default stage does not include the configured routes."
          echo ""
          echo "Expected: 200, 400, or 401"
          echo "Got: $HTTP_STATUS (404 means routes are not deployed)"
          exit 1

  generate-test-pass:
    if: ${{ !cancelled() }}
    name: 'generate test pass for ${{ needs.names.outputs.environment-name }}'
    needs:
      - params
      - names
      - deploy-publish
    uses: ./.github/workflows/generate-pass.yml
    permissions:
      contents: read
      id-token: write
    with:
      environment-name: ${{ needs.names.outputs.environment-name }}
      pass-type: 'day-guest-test-pass'
      quantity: '1'
      notes: 'Auto-generated by deploy workflow run #${{ github.run_number }}'
      generate-hmrc-user: 'true'
      generate-cognito-user: ${{ (needs.names.outputs.environment-name == 'ci' || needs.params.outputs.skipCleanup == 'true') && 'true' || 'false' }}
    secrets:
      HMRC_SANDBOX_CLIENT_SECRET: ${{ secrets.HMRC_SANDBOX_CLIENT_SECRET }}

  web-test-auth:
    if: ${{ !cancelled() && needs.params.outputs.skipTestScenarios != 'true' }}
    name: 'authBehaviour-${{ needs.names.outputs.environment-name }} via synthetic test'
    needs:
      - names
      - params
      - set-origins
      - deploy-publish
      - enable-native-auth
      - verify-api
    uses: ./.github/workflows/synthetic-test.yml
    permissions:
      contents: read
      packages: read
      id-token: write
    with:
      environment-name: ${{ needs.names.outputs.environment-name }}
      deployment-name: ${{ needs.names.outputs.deployment-name }}
      behaviour-test-suite: 'authBehaviour'
      generate-test-reports: 'false'
      skip-native-auth-disable: 'true'
    secrets:
      HMRC_SANDBOX_CLIENT_SECRET: ${{ secrets.HMRC_SANDBOX_CLIENT_SECRET }}

  web-test-token-enforcement:
    if: ${{ !cancelled() && needs.params.outputs.skipTestScenarios != 'true' }}
    name: 'tokenEnforcementBehaviour-${{ needs.names.outputs.environment-name }} via synthetic test'
    needs:
      - params
      - names
      - set-origins
      - deploy-publish
      - enable-native-auth
      - verify-api
    uses: ./.github/workflows/synthetic-test.yml
    permissions:
      contents: read
      packages: read
      id-token: write
    with:
      environment-name: ${{ needs.names.outputs.environment-name }}
      deployment-name: ${{ needs.names.outputs.deployment-name }}
      behaviour-test-suite: 'tokenEnforcementBehaviour'
      generate-test-reports: 'false'
      skip-native-auth-disable: 'true'
    secrets:
      HMRC_SANDBOX_CLIENT_SECRET: ${{ secrets.HMRC_SANDBOX_CLIENT_SECRET }}

  web-test-payment:
    if: ${{ !cancelled() && needs.params.outputs.skipTestScenarios != 'true' }}
    name: 'paymentBehaviour-${{ needs.names.outputs.environment-name }} via synthetic test'
    needs:
      - params
      - names
      - set-origins
      - deploy-publish
      - enable-native-auth
      - verify-api
    uses: ./.github/workflows/synthetic-test.yml
    permissions:
      contents: read
      packages: read
      id-token: write
    with:
      environment-name: ${{ needs.names.outputs.environment-name }}
      deployment-name: ${{ needs.names.outputs.deployment-name }}
      behaviour-test-suite: 'paymentBehaviour'
      generate-test-reports: 'false'
      skip-native-auth-disable: 'true'
    secrets:
      HMRC_SANDBOX_CLIENT_SECRET: ${{ secrets.HMRC_SANDBOX_CLIENT_SECRET }}

  web-test:
    if: ${{ !cancelled() }}
    name: 'submitVatBehaviour-${{ needs.names.outputs.environment-name }} via synthetic test'
    needs:
      - names
      - set-origins
      - deploy-publish
      - enable-native-auth
      - verify-api
    uses: ./.github/workflows/synthetic-test.yml
    permissions:
      contents: read
      packages: read
      id-token: write
    with:
      environment-name: ${{ needs.names.outputs.environment-name }}
      deployment-name: ${{ needs.names.outputs.deployment-name }}
      behaviour-test-suite: 'submitVatBehaviour'
      generate-test-reports: 'true'
      skip-native-auth-disable: 'true'
    secrets:
      HMRC_SANDBOX_CLIENT_SECRET: ${{ secrets.HMRC_SANDBOX_CLIENT_SECRET }}

  web-test-bundle:
    if: ${{ !cancelled() && needs.params.outputs.skipTestScenarios != 'true' }}
    name: 'bundleBehaviour-${{ needs.names.outputs.environment-name }} via synthetic test'
    needs:
      - params
      - names
      - set-origins
      - enable-native-auth
      - web-test-auth
      - web-test-token-enforcement
      - web-test-payment
      - web-test
    uses: ./.github/workflows/synthetic-test.yml
    permissions:
      contents: read
      packages: read
      id-token: write
    with:
      environment-name: ${{ needs.names.outputs.environment-name }}
      deployment-name: ${{ needs.names.outputs.deployment-name }}
      behaviour-test-suite: 'bundleBehaviour'
      generate-test-reports: 'false'
      skip-native-auth-disable: 'true'
    secrets:
      HMRC_SANDBOX_CLIENT_SECRET: ${{ secrets.HMRC_SANDBOX_CLIENT_SECRET }}

  web-test-pass-redemption:
    if: ${{ !cancelled() && needs.params.outputs.skipTestScenarios != 'true' }}
    name: 'passRedemptionBehaviour-${{ needs.names.outputs.environment-name }} via synthetic test'
    needs:
      - params
      - names
      - set-origins
      - enable-native-auth
      - web-test-auth
      - web-test-token-enforcement
      - web-test-payment
      - web-test
    uses: ./.github/workflows/synthetic-test.yml
    permissions:
      contents: read
      packages: read
      id-token: write
    with:
      environment-name: ${{ needs.names.outputs.environment-name }}
      deployment-name: ${{ needs.names.outputs.deployment-name }}
      behaviour-test-suite: 'passRedemptionBehaviour'
      generate-test-reports: 'false'
      skip-native-auth-disable: 'true'
    secrets:
      HMRC_SANDBOX_CLIENT_SECRET: ${{ secrets.HMRC_SANDBOX_CLIENT_SECRET }}

  web-test-post-vat-return-sandbox:
    if: ${{ !cancelled() && needs.params.outputs.skipTestScenarios != 'true' }}
    name: 'postVatReturnBehaviour-${{ needs.names.outputs.environment-name }} via synthetic test'
    needs:
      - params
      - names
      - set-origins
      - enable-native-auth
      - web-test-auth
      - web-test-token-enforcement
      - web-test-payment
      - web-test
    uses: ./.github/workflows/synthetic-test.yml
    permissions:
      contents: read
      packages: read
      id-token: write
    with:
      environment-name: ${{ needs.names.outputs.environment-name }}
      deployment-name: ${{ needs.names.outputs.deployment-name }}
      behaviour-test-suite: 'postVatReturnBehaviour'
      generate-test-reports: 'false'
      skip-native-auth-disable: 'true'
    secrets:
      HMRC_SANDBOX_CLIENT_SECRET: ${{ secrets.HMRC_SANDBOX_CLIENT_SECRET }}

  web-test-get-vat-return-sandbox:
    if: ${{ !cancelled() && needs.params.outputs.skipTestScenarios != 'true' }}
    name: 'getVatReturnBehaviour-${{ needs.names.outputs.environment-name }} via synthetic test'
    needs:
      - params
      - names
      - set-origins
      - enable-native-auth
      - web-test-auth
      - web-test-token-enforcement
      - web-test-payment
      - web-test
    uses: ./.github/workflows/synthetic-test.yml
    permissions:
      contents: read
      packages: read
      id-token: write
    with:
      environment-name: ${{ needs.names.outputs.environment-name }}
      deployment-name: ${{ needs.names.outputs.deployment-name }}
      behaviour-test-suite: 'getVatReturnBehaviour'
      generate-test-reports: 'false'
      skip-native-auth-disable: 'true'
    secrets:
      HMRC_SANDBOX_CLIENT_SECRET: ${{ secrets.HMRC_SANDBOX_CLIENT_SECRET }}

  web-test-obligation-sandbox:
    if: ${{ !cancelled() && needs.params.outputs.skipTestScenarios != 'true' }}
    name: 'getVatObligationsBehaviour-${{ needs.names.outputs.environment-name }} via synthetic test'
    needs:
      - params
      - names
      - set-origins
      - enable-native-auth
      - web-test-auth
      - web-test-token-enforcement
      - web-test-payment
      - web-test
    uses: ./.github/workflows/synthetic-test.yml
    permissions:
      contents: read
      packages: read
      id-token: write
    with:
      environment-name: ${{ needs.names.outputs.environment-name }}
      deployment-name: ${{ needs.names.outputs.deployment-name }}
      behaviour-test-suite: 'getVatObligationsBehaviour'
      generate-test-reports: 'false'
      skip-native-auth-disable: 'true'
    secrets:
      HMRC_SANDBOX_CLIENT_SECRET: ${{ secrets.HMRC_SANDBOX_CLIENT_SECRET }}

  web-test-fraud-prevention-headers-vat-sandbox:
    if: ${{ !cancelled() && needs.params.outputs.skipTestScenarios != 'true' }}
    name: 'postVatReturnFraudPreventionHeadersBehaviour-${{ needs.names.outputs.environment-name }} via synthetic test'
    needs:
      - params
      - names
      - set-origins
      - enable-native-auth
      - web-test-auth
      - web-test-token-enforcement
      - web-test-payment
      - web-test
    uses: ./.github/workflows/synthetic-test.yml
    permissions:
      contents: read
      packages: read
      id-token: write
    with:
      environment-name: ${{ needs.names.outputs.environment-name }}
      deployment-name: ${{ needs.names.outputs.deployment-name }}
      behaviour-test-suite: 'postVatReturnFraudPreventionHeadersBehaviour'
      generate-test-reports: 'false'
      skip-native-auth-disable: 'true'
    secrets:
      HMRC_SANDBOX_CLIENT_SECRET: ${{ secrets.HMRC_SANDBOX_CLIENT_SECRET }}

  web-test-compliance-sandbox:
    if: ${{ !cancelled() && needs.params.outputs.skipTestScenarios != 'true' }}
    name: 'complianceBehaviour-${{ needs.names.outputs.environment-name }} via synthetic test'
    needs:
      - params
      - names
      - set-origins
      - enable-native-auth
      - web-test-auth
      - web-test-token-enforcement
      - web-test-payment
      - web-test
    uses: ./.github/workflows/synthetic-test.yml
    permissions:
      contents: read
      packages: read
      id-token: write
    with:
      environment-name: ${{ needs.names.outputs.environment-name }}
      deployment-name: ${{ needs.names.outputs.deployment-name }}
      behaviour-test-suite: 'complianceBehaviour'
      generate-test-reports: 'false'
      skip-native-auth-disable: 'true'
    secrets:
      HMRC_SANDBOX_CLIENT_SECRET: ${{ secrets.HMRC_SANDBOX_CLIENT_SECRET }}

  web-test-help-sandbox:
    if: ${{ !cancelled() && needs.params.outputs.skipTestScenarios != 'true' }}
    name: 'helpBehaviour-${{ needs.names.outputs.environment-name }} via synthetic test'
    needs:
      - params
      - names
      - set-origins
      - enable-native-auth
      - web-test-auth
      - web-test-token-enforcement
      - web-test-payment
      - web-test
    uses: ./.github/workflows/synthetic-test.yml
    permissions:
      contents: read
      packages: read
      id-token: write
    with:
      environment-name: ${{ needs.names.outputs.environment-name }}
      deployment-name: ${{ needs.names.outputs.deployment-name }}
      behaviour-test-suite: 'helpBehaviour'
      generate-test-reports: 'false'
      skip-native-auth-disable: 'true'
    secrets:
      HMRC_SANDBOX_CLIENT_SECRET: ${{ secrets.HMRC_SANDBOX_CLIENT_SECRET }}

  web-test-vatValidation-sandbox:
    if: ${{ !cancelled() && needs.params.outputs.skipTestScenarios != 'true' }}
    name: 'vatValidationBehaviour-${{ needs.names.outputs.environment-name }} via synthetic test'
    needs:
      - params
      - names
      - set-origins
      - enable-native-auth
      - web-test-auth
      - web-test-token-enforcement
      - web-test-payment
      - web-test
    uses: ./.github/workflows/synthetic-test.yml
    permissions:
      contents: read
      packages: read
      id-token: write
    with:
      environment-name: ${{ needs.names.outputs.environment-name }}
      deployment-name: ${{ needs.names.outputs.deployment-name }}
      behaviour-test-suite: 'vatValidationBehaviour'
      generate-test-reports: 'false'
      skip-native-auth-disable: 'true'
    secrets:
      HMRC_SANDBOX_CLIENT_SECRET: ${{ secrets.HMRC_SANDBOX_CLIENT_SECRET }}

  web-test-vatSchemes-sandbox:
    if: ${{ !cancelled() && needs.params.outputs.skipTestScenarios != 'true' }}
    name: 'vatSchemesBehaviour-${{ needs.names.outputs.environment-name }} via synthetic test'
    needs:
      - params
      - names
      - set-origins
      - enable-native-auth
      - web-test-auth
      - web-test-token-enforcement
      - web-test-payment
      - web-test
    uses: ./.github/workflows/synthetic-test.yml
    permissions:
      contents: read
      packages: read
      id-token: write
    with:
      environment-name: ${{ needs.names.outputs.environment-name }}
      deployment-name: ${{ needs.names.outputs.deployment-name }}
      behaviour-test-suite: 'vatSchemesBehaviour'
      generate-test-reports: 'false'
      skip-native-auth-disable: 'true'
    secrets:
      HMRC_SANDBOX_CLIENT_SECRET: ${{ secrets.HMRC_SANDBOX_CLIENT_SECRET }}

  web-test-simulator:
    if: ${{ !cancelled() && needs.params.outputs.skipTestScenarios != 'true' }}
    name: 'simulatorBehaviour-${{ needs.names.outputs.environment-name }} via synthetic test'
    needs:
      - params
      - names
      - set-origins
      - enable-native-auth
      - web-test-auth
      - web-test-token-enforcement
      - web-test-payment
      - web-test
    uses: ./.github/workflows/synthetic-test.yml
    permissions:
      contents: read
      packages: read
      id-token: write
    with:
      environment-name: ${{ needs.names.outputs.environment-name }}
      deployment-name: ${{ needs.names.outputs.deployment-name }}
      behaviour-test-suite: 'simulatorBehaviour'
      generate-test-reports: 'false'
      skip-native-auth-disable: 'true'
    secrets:
      HMRC_SANDBOX_CLIENT_SECRET: ${{ secrets.HMRC_SANDBOX_CLIENT_SECRET }}

  web-test-gateway:
    if: ${{ !cancelled() && needs.params.outputs.skipTestScenarios != 'true' }}
    name: 'gatewayBehaviour-${{ needs.names.outputs.environment-name }} via synthetic test'
    needs:
      - params
      - names
      - set-origins
      - deploy-publish
      - web-test-auth
      - web-test-token-enforcement
      - web-test-payment
      - web-test
    uses: ./.github/workflows/synthetic-test.yml
    permissions:
      contents: read
      packages: read
      id-token: write
    with:
      environment-name: ${{ needs.names.outputs.environment-name }}
      deployment-name: ${{ needs.names.outputs.deployment-name }}
      behaviour-test-suite: 'gatewayBehaviour'
      generate-test-reports: 'false'
      skip-native-auth-disable: 'true'
    secrets:
      HMRC_SANDBOX_CLIENT_SECRET: ${{ secrets.HMRC_SANDBOX_CLIENT_SECRET }}

  web-test-spreadsheets:
    if: ${{ !cancelled() && needs.params.outputs.skipTestScenarios != 'true' }}
    name: 'spreadsheetsBehaviour-${{ needs.names.outputs.environment-name }} via synthetic test'
    needs:
      - params
      - names
      - set-origins
      - deploy-publish
      - web-test-auth
      - web-test-token-enforcement
      - web-test-payment
      - web-test
    uses: ./.github/workflows/synthetic-test.yml
    permissions:
      contents: read
      packages: read
      id-token: write
    with:
      environment-name: ${{ needs.names.outputs.environment-name }}
      deployment-name: ${{ needs.names.outputs.deployment-name }}
      behaviour-test-suite: 'spreadsheetsBehaviour'
      generate-test-reports: 'false'
      skip-native-auth-disable: 'true'
    secrets:
      HMRC_SANDBOX_CLIENT_SECRET: ${{ secrets.HMRC_SANDBOX_CLIENT_SECRET }}

  web-test-generate-pass-activity:
    if: ${{ !cancelled() && needs.params.outputs.skipTestScenarios != 'true' }}
    name: 'generatePassActivityBehaviour-${{ needs.names.outputs.environment-name }} via synthetic test'
    needs:
      - params
      - names
      - set-origins
      - enable-native-auth
      - web-test-auth
      - web-test-token-enforcement
      - web-test-payment
      - web-test
    uses: ./.github/workflows/synthetic-test.yml
    permissions:
      contents: read
      packages: read
      id-token: write
    with:
      environment-name: ${{ needs.names.outputs.environment-name }}
      deployment-name: ${{ needs.names.outputs.deployment-name }}
      behaviour-test-suite: 'generatePassActivityBehaviour'
      generate-test-reports: 'false'
      skip-native-auth-disable: 'true'
    secrets:
      HMRC_SANDBOX_CLIENT_SECRET: ${{ secrets.HMRC_SANDBOX_CLIENT_SECRET }}

  disable-native-auth:
    if: ${{ !cancelled() }}
    name: 'disable native auth after behaviour tests'
    needs:
      - params
      - names
      - enable-native-auth
      - web-test-auth
      - web-test-bundle
      - web-test-pass-redemption
      - web-test-token-enforcement
      - web-test-payment
      - web-test
      - web-test-post-vat-return-sandbox
      - web-test-get-vat-return-sandbox
      - web-test-obligation-sandbox
      - web-test-fraud-prevention-headers-vat-sandbox
      - web-test-compliance-sandbox
      - web-test-help-sandbox
      - web-test-vatValidation-sandbox
      - web-test-vatSchemes-sandbox
      - web-test-simulator
      - web-test-gateway
      - web-test-spreadsheets
      - web-test-generate-pass-activity
    runs-on: ubuntu-24.04
    environment: ${{ needs.params.outputs.github-environment }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --ignore-scripts
        env:
          PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: 1

      - name: Configure AWS role via GitHub OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Assume AWS deployment role
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      # Each test deletes its own Cognito user via synthetic-test.yml

      - name: Disable native auth on Cognito Hosted UI
        if: ${{ needs.params.outputs.skipCleanup != 'true' && needs.names.outputs.environment-name != 'ci' }}
        shell: bash
        run: |
          ENV_FILE=".env.${{ needs.names.outputs.environment-name }}"
          PROVIDER=$(grep -E '^TEST_AUTH_PROVIDER=' "$ENV_FILE" | tail -n1 | cut -d'=' -f2)
          if [ "$PROVIDER" = "cognito-native" ]; then
            node scripts/toggle-cognito-native-auth.js disable "${{ needs.names.outputs.environment-name }}"
          else
            echo "Skipping native auth toggle (TEST_AUTH_PROVIDER=${PROVIDER:-unset})"
          fi

  # Set the deployment name as the last known good deployment for this environment in a parameter store parameter
  set-last-known-good-deployment:
    name: 'set last known good deployment'
    needs:
      - names
      - web-test
      - disable-native-auth
    runs-on: ubuntu-24.04
    environment: ${{ needs.names.outputs.environment-name }}
    steps:
      - name: Configure AWS role via GitHub OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Assume AWS deployment role
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Set last known good deployment in SSM Parameter Store
        run: |
          PARAMETER_NAME="/submit/${{ needs.names.outputs.environment-name }}/last-known-good-deployment"
          echo "Setting SSM Parameter Store parameter $PARAMETER_NAME to value '${{ needs.names.outputs.deployment-name }}'"
          aws ssm put-parameter \
            --name "$PARAMETER_NAME" \
            --type String \
            --value "${{ needs.names.outputs.deployment-name }}" \
            --overwrite

      # Read back the value to confirm it was set correctly
      - name: Read back last known good deployment from SSM Parameter Store
        run: |
          PARAMETER_NAME="/submit/${{ needs.names.outputs.environment-name }}/last-known-good-deployment"
          aws ssm get-parameter --name "$PARAMETER_NAME" --query "Parameter.Value" --output text | tee /tmp/last_known_good_deployment.txt
          echo "Last known good deployment: $(cat /tmp/last_known_good_deployment.txt)"

      - name: CDK stacks in eu-west-2 and us-east-1
        run: |
          aws cloudformation describe-stacks --region eu-west-2 --query "Stacks[].StackName" --output text | tr '\t' '\n' | sort
          aws cloudformation describe-stacks --region us-east-1 --query "Stacks[].StackName" --output text | tr '\t' '\n' | sort

  # Run workflow: .github/workflows/destroy.yml to destroy previous prod deployments but not the holding page (`-holding`)
  destroy-previous:
    if: ${{ needs.names.outputs.environment-name == 'prod' && needs.set-origins.outputs.existing-deployment-name != '' && !contains(needs.set-origins.outputs.existing-deployment-name, '-holding') }}
    name: 'destroy previous'
    needs:
      - names
      - skip-deploy-check
      - set-origins
      #- upload-web-test-results
      - set-last-known-good-deployment
    uses: './.github/workflows/destroy.yml'
    with:
      environment-name: ${{ needs.names.outputs.environment-name }}
      deployment-name: ${{ needs.set-origins.outputs.existing-deployment-name }}

 # TODO: If set-origins passed but web-test failed, look up the last deployment from a parameter store and set-origin back to that deployment
