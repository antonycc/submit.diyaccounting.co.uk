name: destroy
run-name: "destroy from ${{ github.ref_name }}"
concurrency:
  group: destroy-${{ github.ref_name }}
  cancel-in-progress: false

on:
  workflow_dispatch:
    inputs:
      environment-name:
        type: choice
        description: 'Environment name to use instead of computing from branch, e.g. ci or prod'
        required: false
        options:
          - '(auto)'
          - 'ci'
          - 'prod'
        default: '(auto)'
      deployment-name:
        type: string
        description: 'Deployment name to use instead of computing from branch, e.g. ci-lambdas6 or prod-ea373de'
        required: false
        default: ''
      sweep-for-stacks:
        type: boolean
        description: 'Whether to sweep for leftover stacks (true) or select by branch/environment/deployment name (false)'
        required: false
  workflow_call:
    inputs:
      environment-name:
        type: string
        description: 'Environment name to use instead of computing from branch, e.g. ci or prod'
        required: false
        default: ''
      deployment-name:
        type: string
        description: 'Deployment name to use instead of computing from branch, e.g. ci-lambdas6 or prod-ea373de'
        required: false
        default: ''
      sweep-for-stacks:
        type: boolean
        description: 'Whether to sweep for leftover stacks (true) or select by branch/environment/deployment name (false)'
        required: false
        default: false
  schedule:
    - cron: '34 2,4,6,8,10,12 * * *'

permissions:
  id-token: write
  contents: read

env:
  JAVA_VERSION: '25'
  NODE_VERSION: '24'
  AWS_REGION: 'eu-west-2'
  BASE_IMAGE_TAG_PREFIX: 'submit-base'
  GITHUB_ACTOR: ${{ github.actor }}
  SELF_DESTRUCT_DELAY_HOURS: '8'
  BASE_IMAGE_TAG: ${{ github.sha }}
  FORCE_ALL_STACK_DEPLOYMENT: 'false'
  COMMIT_HASH: ${{ github.sha }}
  BUILD_NUMBER: ${{ github.run_number }}

jobs:

  params:
    runs-on: ubuntu-24.04
    steps:
      - name: "github.event_name=[${{ github.event_name }}]"
        run: ":"
      - name: "github.ref=[${{ github.ref }}]"
        run: ":"
      - name: "inputs.environment-name=[${{ inputs.environment-name }}]"
        run: ":"
      - name: "inputs.deployment-name=[${{ inputs.deployment-name }}]"
        run: ":"
      - name: "inputs.sweep-for-stacks=[${{ inputs.sweep-for-stacks }}]"
        run: ":"
      - name: Normalise Params
        id: normalise
        shell: bash
        run: |
          # Convert '(auto)' to empty string for downstream processing
          ENV_NAME='${{ inputs.environment-name }}'; [[ "$ENV_NAME" == "(auto)" ]] && ENV_NAME=""
          echo "environment-name=${ENV_NAME}" | tee -a "$GITHUB_OUTPUT"
          # Resolve GitHub Actions environment from explicit input or branch
          GH_ENV="${ENV_NAME}"
          if [ -z "$GH_ENV" ]; then
            if [ "${{ github.ref }}" == "refs/heads/main" ]; then GH_ENV="prod"; else GH_ENV="ci"; fi
          fi
          echo "github-environment=${GH_ENV}" | tee -a "$GITHUB_OUTPUT"
          echo 'deployment-name=${{ inputs.deployment-name }}' | tee -a "$GITHUB_OUTPUT"
          X='${{ inputs.sweep-for-stacks }}' ; echo "sweep-for-stacks=${X:-false}" | tee -a "$GITHUB_OUTPUT"
          # Compute isSweeping: true if sweep-for-stacks=true OR schedule trigger
          SWEEP_FOR_STACKS='${{ inputs.sweep-for-stacks }}'
          EVENT_NAME='${{ github.event_name }}'
          if [ "${SWEEP_FOR_STACKS:-false}" = "true" ]; then
            echo "isSweeping=true" | tee -a "$GITHUB_OUTPUT"
          elif [ "$EVENT_NAME" = "schedule" ]; then
            echo "isSweeping=true" | tee -a "$GITHUB_OUTPUT"
          else
            echo "isSweeping=false" | tee -a "$GITHUB_OUTPUT"
          fi
    outputs:
      environment-name: ${{ steps.normalise.outputs.environment-name }}
      deployment-name: ${{ steps.normalise.outputs.deployment-name }}
      sweep-for-stacks: ${{ steps.normalise.outputs.sweep-for-stacks }}
      isSweeping: ${{ steps.normalise.outputs.isSweeping }}
      github-environment: ${{ steps.normalise.outputs.github-environment }}

  sweep-for-stacks:
    needs:
      - params
    if: ${{ needs.params.outputs.isSweeping == 'true' }}
    name: 'sweep for stacks'
    runs-on: ubuntu-24.04
    environment: ${{ needs.params.outputs.github-environment }}
    steps:

      - name: Configure AWS role via GitHub OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Assume AWS deployment role
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: CDK stacks in eu-west-2 and us-east-1
        run: |
          aws cloudformation describe-stacks --region eu-west-2 --query "Stacks[].StackName" --output text | tr '\t' '\n' | sort
          aws cloudformation describe-stacks --region us-east-1 --query "Stacks[].StackName" --output text | tr '\t' '\n' | sort

      # Get last known good deployment names from SSM Parameter Store that match the ci- or prod- pattern
      - name: Get last known good deployment names
        id: last-known-good-deployment-names
        run: |
          LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI="/submit/ci/last-known-good-deployment"
          LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD="/submit/prod/last-known-good-deployment"
          echo "Getting SSM Parameter Store parameter $LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI and $LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD"
          aws ssm get-parameter \
            --name "$LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI" \
            --query "Parameter.Value" \
            --output text \
            > /tmp/last-known-good-deployment-ci.txt \
            || echo "Parameter $LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI not found"
          aws ssm get-parameter \
            --name "$LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD" \
            --query "Parameter.Value" \
            --output text \
            > /tmp/last-known-good-deployment-prod.txt \
            || echo "Parameter $LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD not found"
          LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI_VALUE=$(cat /tmp/last-known-good-deployment-ci.txt || echo "")
          LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD_VALUE=$(cat /tmp/last-known-good-deployment-prod.txt || echo "")
          echo "Last known good deployment name CI: $LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI_VALUE"
          echo "Last known good deployment name PROD: $LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD_VALUE"
          echo "last-known-good-deployment-name-ci=$LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI_VALUE" >> $GITHUB_OUTPUT
          echo "last-known-good-deployment-name-prod=$LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD_VALUE" >> $GITHUB_OUTPUT

      # Get the record names of aliases in any cloudfront distributions that match the ci- or prod- pattern in the first part of the domain name
      - name: Get the published record names
        id: published-deployment-names
        run: |
          echo "Getting CloudFront distributions"
          DISTRIBUTION_IDS=$(aws cloudfront list-distributions --query "DistributionList.Items[].Id" --output text)
          PUBLISHED_DEPLOYMENT_NAMES=""
          echo "Found CloudFront Distribution IDs: $DISTRIBUTION_IDS"
          for DISTRIBUTION_ID in $DISTRIBUTION_IDS; do
            ALIASES=$(aws cloudfront get-distribution --id "$DISTRIBUTION_ID" --query "Distribution.DistributionConfig.Aliases.Items[]" --output text)
            echo "Found aliases for Distribution ID $DISTRIBUTION_ID: $ALIASES"
            for ALIAS in $ALIASES; do
              RECORD_NAME=$(echo "$ALIAS" | cut -d'.' -f1)
              if [[ "$RECORD_NAME" =~ ^(ci|prod)-.* ]]; then
                PUBLISHED_DEPLOYMENT_NAMES="$PUBLISHED_DEPLOYMENT_NAMES $RECORD_NAME"
              fi
            done
          done

          # Remove duplicates
          echo "Collected published deployment names before deduplication: $PUBLISHED_DEPLOYMENT_NAMES"
          PUBLISHED_DEPLOYMENT_NAMES=$(echo $PUBLISHED_DEPLOYMENT_NAMES | tr ' ' '\n' | sort -u | tr '\n' ' ')

          echo "Published deployment names: $PUBLISHED_DEPLOYMENT_NAMES"
          echo "published-deployment-names=$PUBLISHED_DEPLOYMENT_NAMES" >> $GITHUB_OUTPUT

      # Get deployment-related stack names from CloudFormation in eu-west-2 and us-east-1
      # and extract deployment IDs like ci-foo / prod-bar from:
      #   prod-64d48ac-app-OpsStack  -> prod-64d48ac
      #   ci-mtdreport-app-DevStack  -> ci-mtdreport
      - name: Get the deployed deployment names
        id: deployed-deployment-names
        run: |
          echo 'Getting deployed deployment names from CloudFormation stacks in eu-west-2 and us-east-1'

          # Only stacks that look like prod-xxx-app-...
          # Extract the deployment id: prod-xxx or ci-yyy
          DEPLOYED_DEPLOYMENT_NAMES=$(
            for REGION in eu-west-2 us-east-1; do
              echo "Scanning region: $REGION" >&2
              aws cloudformation describe-stacks \
                --region "$REGION" \
                --query 'Stacks[].StackName' \
                --output text
            done \
            | tr '\t' '\n' \
            | grep -E '^(ci|prod)-[a-zA-Z0-9-]+-(app|del)-' \
            | sed -E 's/^((ci|prod)-[a-zA-Z0-9-]+)-(app|del)-.*/\1/' \
            | sort -u
          )

          echo "Collected deployed deployment names (newline separated):"
          printf '%s\n' $DEPLOYED_DEPLOYMENT_NAMES

          # Convert to single space-separated bash-iterable string
          DEPLOYED_DEPLOYMENT_NAMES=$(echo "$DEPLOYED_DEPLOYMENT_NAMES" | tr '\n' ' ')

          echo "Deployed deployment names: $DEPLOYED_DEPLOYMENT_NAMES"
          echo "deployed-deployment-names=$DEPLOYED_DEPLOYMENT_NAMES" >> "$GITHUB_OUTPUT"

      # Get the deployment names that the primary domains alias to in Route 53:
      #   submit.diyaccounting.co.uk  -> prod-*.submit.diyaccounting.co.uk.
      #   ci.submit.diyaccounting.co.uk -> ci-*.submit.diyaccounting.co.uk.
      - name: Get the public record names
        id: public-deployment-names
        run: |
          echo 'Getting Route 53 hosted zone for diyaccounting.co.uk.'
          ROOT_ZONE='diyaccounting.co.uk.'
          PRIMARY_NAMES='submit.diyaccounting.co.uk. ci.submit.diyaccounting.co.uk.'
          PUBLIC_DEPLOYMENT_NAMES=''

          ZONE_ID=$(aws route53 list-hosted-zones-by-name \
            --dns-name "$ROOT_ZONE" \
            --query 'HostedZones[0].Id' \
            --output text 2>/dev/null | sed 's|/hostedzone/||')

          if [ -z "$ZONE_ID" ] || [ "$ZONE_ID" = 'None' ]; then
            echo "No hosted zone found for $ROOT_ZONE"
            exit 1
          fi

          echo "Using hosted zone $ROOT_ZONE ($ZONE_ID)"

          for PRIMARY_NAME in $PRIMARY_NAMES; do
            echo "Looking up alias target for $PRIMARY_NAME"

            # Get the alias target DNSName for the A record of the primary name
            ALIAS_TARGETS=$(aws route53 list-resource-record-sets \
              --hosted-zone-id "$ZONE_ID" \
              --query "ResourceRecordSets[?Name==\`$PRIMARY_NAME\` && Type==\`A\`].AliasTarget.DNSName" \
              --output text)

            if [ -z "$ALIAS_TARGETS" ] || [ "$ALIAS_TARGETS" = 'None' ]; then
              echo "No alias A record found for $PRIMARY_NAME"
              continue
            fi

            echo "Alias targets for $PRIMARY_NAME: $ALIAS_TARGETS"

            for TARGET in $ALIAS_TARGETS; do
              # Example TARGET:
              #   prod-64d48ac.submit.diyaccounting.co.uk.
              TARGET_STRIPPED=${TARGET%.}          # drop trailing dot
              HOST_LABEL=${TARGET_STRIPPED%%.*}    # first label (prod-64d48ac)

              if [[ "$HOST_LABEL" =~ ^(ci|prod)-.* ]]; then
                echo "Found public deployment from $PRIMARY_NAME -> $HOST_LABEL"
                PUBLIC_DEPLOYMENT_NAMES="$PUBLIC_DEPLOYMENT_NAMES $HOST_LABEL"
              else
                echo "Alias target $TARGET_STRIPPED does not look like ci-/prod-*, skipping"
              fi
            done
          done

          echo "Collected public deployment names before deduplication: $PUBLIC_DEPLOYMENT_NAMES"
          PUBLIC_DEPLOYMENT_NAMES=$(echo "$PUBLIC_DEPLOYMENT_NAMES" \
            | tr ' ' '\n' \
            | sort -u \
            | tr '\n' ' ')

          echo "Public deployment names: $PUBLIC_DEPLOYMENT_NAMES"
          echo "public-deployment-names=$PUBLIC_DEPLOYMENT_NAMES" >> "$GITHUB_OUTPUT"

      # Select environment and deployment names of stacks to destroy matching .*-[ci|prod]-.* pattern but not the public deployment names or last known good deployment names
      - name: Select environment and deployment names
        id: select-stack
        run: |
          LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI="${{ steps.last-known-good-deployment-names.outputs.last-known-good-deployment-name-ci }}"
          LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD="${{ steps.last-known-good-deployment-names.outputs.last-known-good-deployment-name-prod }}"
          PUBLIC_DEPLOYMENT_NAMES="${{ steps.public-deployment-names.outputs.public-deployment-names }}"
          PUBLISHED_DEPLOYMENT_NAMES="${{ steps.published-deployment-names.outputs.published-deployment-names }}"
          DEPLOYED_DEPLOYMENT_NAMES="${{ steps.deployed-deployment-names.outputs.deployed-deployment-names }}"
          SELF_DESTRUCT_DELAY_HOURS="${{ env.SELF_DESTRUCT_DELAY_HOURS }}"

          echo "Last known good deployment names: CI='$LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI', PROD='$LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD'"
          echo "Public deployment names: $PUBLIC_DEPLOYMENT_NAMES"
          echo "Published deployment names: $PUBLISHED_DEPLOYMENT_NAMES"
          echo "Deployed deployment names: $DEPLOYED_DEPLOYMENT_NAMES"
          echo "Self-destruct delay hours: $SELF_DESTRUCT_DELAY_HOURS"

          # Function to get the most recent creation time for a deployment's stacks
          get_deployment_age_hours() {
            local deployment_name="$1"
            local most_recent_timestamp=0

            echo "Checking age of deployment: $deployment_name" >&2

            # Validate deployment name format to prevent injection
            # Only alphanumeric, hyphens allowed - safe for JMESPath query
            if ! [[ "$deployment_name" =~ ^(ci|prod)-[a-zA-Z0-9-]+$ ]]; then
              echo "Invalid deployment name format: $deployment_name" >&2
              echo "-1"
              return
            fi

            # Find all stacks for this deployment in both regions
            # The deployment_name is safe to interpolate after validation above
            for REGION in eu-west-2 us-east-1; do
              local stack_info=$(aws cloudformation describe-stacks \
                --region "$REGION" \
                --query "Stacks[?starts_with(StackName, '${deployment_name}-')].CreationTime" \
                --output text 2>/dev/null | tr '\t' '\n' || echo "")

              if [ -n "$stack_info" ]; then
                echo "Found stacks in $REGION for $deployment_name" >&2

                # Process each creation time
                while IFS= read -r creation_time; do
                  [ -z "$creation_time" ] && continue

                  # Convert creation time to epoch seconds
                  local epoch=$(date -d "$creation_time" +%s 2>/dev/null)

                  # Skip if date parsing failed or returned invalid value
                  if [ -z "$epoch" ]; then
                    echo "Failed to parse creation time: $creation_time" >&2
                    continue
                  fi

                  if ! [[ "$epoch" =~ ^[0-9]+$ ]] || [ "$epoch" -le 0 ]; then
                    echo "Invalid epoch value: $epoch for creation time: $creation_time" >&2
                    continue
                  fi

                  if [ "$epoch" -gt "$most_recent_timestamp" ]; then
                    most_recent_timestamp="$epoch"
                  fi
                done <<< "$stack_info"
              fi
            done

            if [ "$most_recent_timestamp" -eq 0 ]; then
              echo "No valid stacks found for deployment $deployment_name" >&2
              echo "-1"
              return
            fi

            # Calculate age in hours
            local current_timestamp=$(date +%s)
            local age_seconds=$((current_timestamp - most_recent_timestamp))
            local age_hours=$((age_seconds / 3600))

            echo "Deployment $deployment_name age: $age_hours hours (most recent stack created at $(date -d "@$most_recent_timestamp" -Iseconds))" >&2
            echo "$age_hours"
          }

          STACK_DEPLOYMENT_NAMES_TO_KEEP=()

          # 1. Always keep deployments that are currently aliased from the primaries
          #    plus last-known-good deployments from SSM
          for DEPLOYMENT_NAME in $(echo "$PUBLIC_DEPLOYMENT_NAMES \
            $LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI \
            $LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD" | tr ' ' '\n'); do
            if [ -n "$DEPLOYMENT_NAME" ]; then
              STACK_DEPLOYMENT_NAMES_TO_KEEP+=("$DEPLOYMENT_NAME")
            fi
          done

          # 2. Always keep sibling site deployments (gateway, spreadsheets) and holding pages
          #    These are separate workflows with their own stacks â€” the sweeper must never touch them
          for DEPLOYMENT_NAME in $PUBLISHED_DEPLOYMENT_NAMES; do
            if [[ "$DEPLOYMENT_NAME" == *-holding ]] || \
               [[ "$DEPLOYMENT_NAME" == *-gateway ]] || \
               [[ "$DEPLOYMENT_NAME" == *-spreadsheets ]]; then
              STACK_DEPLOYMENT_NAMES_TO_KEEP+=("$DEPLOYMENT_NAME")
            fi
          done

          # Remove duplicates from STACK_DEPLOYMENT_NAMES_TO_KEEP
          echo "Removing duplicates from stacks to keep from: ${STACK_DEPLOYMENT_NAMES_TO_KEEP[*]}"
          STACK_DEPLOYMENT_NAMES_TO_KEEP=($(echo "${STACK_DEPLOYMENT_NAMES_TO_KEEP[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' '))

          echo "Stacks to skip destruction: ${STACK_DEPLOYMENT_NAMES_TO_KEEP[*]}"

          ALL_CANDIDATE_DEPLOYMENT_NAMES="$PUBLISHED_DEPLOYMENT_NAMES $DEPLOYED_DEPLOYMENT_NAMES"

          # Remove duplicates from ALL_CANDIDATE_DEPLOYMENT_NAMES
          echo "Removing duplicates from all candidate deployment names from: $ALL_CANDIDATE_DEPLOYMENT_NAMES"
          ALL_CANDIDATE_DEPLOYMENT_NAMES=$(echo "$ALL_CANDIDATE_DEPLOYMENT_NAMES" | tr ' ' '\n' | sort -u | tr '\n' ' ')

          # List all candidate stacks and filter out those matching STACK_DEPLOYMENT_NAMES_TO_KEEP
          # e.g.
          # SELECTED_ENVIRONMENT_NAME="ci"
          # SELECTED_DEPLOYMENT_NAME="ci-oldstack123"
          SELECTED_ENVIRONMENT_NAME=""
          SELECTED_DEPLOYMENT_NAME=""

          for DEPLOYMENT_NAME in $ALL_CANDIDATE_DEPLOYMENT_NAMES; do
            [ -z "$DEPLOYMENT_NAME" ] && continue

            echo "Considering deployment name: $DEPLOYMENT_NAME"

            if [[ " ${STACK_DEPLOYMENT_NAMES_TO_KEEP[*]} " =~ " ${DEPLOYMENT_NAME} " ]]; then
              echo "Skipping $DEPLOYMENT_NAME as it is in the keep list"
              continue
            fi

            # Check if deployment is old enough to be destroyed
            DEPLOYMENT_AGE_HOURS=$(get_deployment_age_hours "$DEPLOYMENT_NAME")

            if [ "$DEPLOYMENT_AGE_HOURS" -eq -1 ]; then
              echo "Could not determine age for $DEPLOYMENT_NAME, skipping"
              continue
            fi

            if [ "$DEPLOYMENT_AGE_HOURS" -lt "$SELF_DESTRUCT_DELAY_HOURS" ]; then
              echo "Skipping $DEPLOYMENT_NAME as it is only $DEPLOYMENT_AGE_HOURS hours old (minimum age: $SELF_DESTRUCT_DELAY_HOURS hours)"
              continue
            fi

            echo "Deployment $DEPLOYMENT_NAME is $DEPLOYMENT_AGE_HOURS hours old (>= $SELF_DESTRUCT_DELAY_HOURS hours), eligible for destruction"

            SELECTED_DEPLOYMENT_NAME="$DEPLOYMENT_NAME"

            if [[ "$SELECTED_DEPLOYMENT_NAME" == ci-* ]]; then
              SELECTED_ENVIRONMENT_NAME="ci"
              echo "Matched ci deployment for destruction"
            elif [[ "$SELECTED_DEPLOYMENT_NAME" == prod-* ]]; then
              SELECTED_ENVIRONMENT_NAME="prod"
              echo "Matched prod deployment for destruction"
            else
              echo "Deployment $SELECTED_DEPLOYMENT_NAME is not ci-/prod-, skipping"
              SELECTED_DEPLOYMENT_NAME=""
              SELECTED_ENVIRONMENT_NAME=""
              continue
            fi

            echo "Selected deployment for destruction: Environment='$SELECTED_ENVIRONMENT_NAME', Deployment='$SELECTED_DEPLOYMENT_NAME'"
            break
          done

          if [ -z "$SELECTED_DEPLOYMENT_NAME" ]; then
            echo "No stacks found for destruction"
            SWEEPER_HIT="false"
          else
            echo "Stacks found for destruction ${SELECTED_ENVIRONMENT_NAME}/${SELECTED_DEPLOYMENT_NAME}"
            SWEEPER_HIT="true"
          fi

          echo "SWEEPER_HIT=$SWEEPER_HIT"
          echo "SELECTED_ENVIRONMENT_NAME=$SELECTED_ENVIRONMENT_NAME"
          echo "SELECTED_DEPLOYMENT_NAME=$SELECTED_DEPLOYMENT_NAME"
          echo "SWEEPER_HIT=$SWEEPER_HIT" >> $GITHUB_OUTPUT
          echo "SELECTED_ENVIRONMENT_NAME=$SELECTED_ENVIRONMENT_NAME" >> $GITHUB_OUTPUT
          echo "SELECTED_DEPLOYMENT_NAME=$SELECTED_DEPLOYMENT_NAME" >> $GITHUB_OUTPUT

    outputs:
      sweeper-hit: ${{ steps.select-stack.outputs.SWEEPER_HIT }}
      environment-name: ${{ steps.select-stack.outputs.SELECTED_ENVIRONMENT_NAME }}
      deployment-name: ${{ steps.select-stack.outputs.SELECTED_DEPLOYMENT_NAME }}

  names:
    if: ${{ !cancelled() && needs.sweep-for-stacks.outputs.sweeper-hit != 'false' }}
    needs:
      - params
      - sweep-for-stacks
    runs-on: ubuntu-24.04
    environment: ${{ needs.params.outputs.github-environment }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6
      - name: Compute deployment name and environment
        id: deployment-config
        uses: ./.github/actions/get-names
        with:
          environment-name: ${{ needs.sweep-for-stacks.outputs.environment-name || needs.params.outputs.environment-name }}
          deployment-name: ${{ needs.sweep-for-stacks.outputs.deployment-name || needs.params.outputs.deployment-name }}
    outputs:
      environment-name: ${{ steps.deployment-config.outputs.environment-name }}
      deployment-name: ${{ steps.deployment-config.outputs.deployment-name }}
      base-domain: ${{ steps.deployment-config.outputs.base-domain }}
      base-url: ${{ steps.deployment-config.outputs.base-url }}
      apex-domain: ${{ steps.deployment-config.outputs.apex-domain }}
      apex-url: ${{ steps.deployment-config.outputs.apex-url }}
      holding-domain: ${{ steps.deployment-config.outputs.holding-domain }}
      holding-url: ${{ steps.deployment-config.outputs.holding-url }}

  destroy:
    if: ${{ !cancelled() && needs.sweep-for-stacks.outputs.sweeper-hit != 'false' }}
    needs:
      - params
      - names
      - sweep-for-stacks
    runs-on: ubuntu-latest
    environment: ${{ needs.params.outputs.github-environment }}
    steps:
      - name: Checkout default branch
        uses: actions/checkout@v6
        with:
          ref: ${{ github.event.repository.default_branch }} # e.g. main
          fetch-depth: 0

      - name: Report deleted ref
        run: |
          echo "Deleted: ${{ github.event.ref }}"
          echo "Ref type: ${{ github.event.ref_type }}"

      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - uses: actions/setup-java@v5
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}
          cache: 'maven'

      - name: Configure AWS role via GitHub OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Assume AWS deployment role
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.SUBMIT_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: CDK stacks before
        run: |
          aws cloudformation describe-stacks --region eu-west-2 --query "Stacks[].StackName" --output text | tr '\t' '\n' | sort
          aws cloudformation describe-stacks --region us-east-1 --query "Stacks[].StackName" --output text | tr '\t' '\n' | sort

      - name: Node dependencies
        run: npm ci

      - name: Build CDK
        run: ./mvnw --errors clean verify -DskipTests

      - name: Lookup Cognito from domain convention
        id: lookup
        uses: './.github/actions/lookup-resources'
        with:
          environment-name: ${{ needs.names.outputs.environment-name }}
          lookup-cognito: 'true'

      - name: Empty origin bucket
        shell: bash
        run: |
          EDGE_STACK="${{ needs.names.outputs.deployment-name }}-app-EdgeStack"
          BUCKET_NAME=$(aws cloudformation describe-stacks \
            --stack-name "${EDGE_STACK}" --region us-east-1 \
            --query 'Stacks[0].Outputs[?OutputKey==`OriginBucketName`].OutputValue' \
            --output text 2>/dev/null || echo "")
          if [ -z "$BUCKET_NAME" ] || [ "$BUCKET_NAME" = "None" ]; then
            echo "EdgeStack not found or no OriginBucketName output, skipping"
          else
            echo "Emptying origin bucket: ${BUCKET_NAME}"
            aws s3 rm "s3://${BUCKET_NAME}" --recursive \
              || echo "Origin bucket already empty or does not exist"
          fi

      - name: Clean up external API Gateway custom domain mappings
        shell: bash
        run: |
          set +e  # Best-effort cleanup
          API_STACK_NAME="${{ needs.names.outputs.deployment-name }}-app-ApiStack"
          API_ID=$(aws cloudformation describe-stacks \
            --stack-name "${API_STACK_NAME}" --region eu-west-2 \
            --query "Stacks[0].Outputs[?OutputKey=='HttpApiId'].OutputValue | [0]" \
            --output text 2>/dev/null || echo "")
          if [ -z "$API_ID" ] || [ "$API_ID" = "None" ]; then
            echo "No API ID found for stack ${API_STACK_NAME}, skipping"
            exit 0
          fi
          echo "Found API ID: $API_ID, scanning for external domain mappings"
          DOMAINS=$(aws apigatewayv2 get-domain-names --region eu-west-2 \
            --query 'Items[].DomainName' --output text 2>/dev/null || echo "")
          for DOMAIN in $DOMAINS; do
            [ -z "$DOMAIN" ] || [ "$DOMAIN" = "None" ] && continue
            MAPPINGS=$(aws apigatewayv2 get-api-mappings --domain-name "$DOMAIN" --region eu-west-2 \
              --query "Items[?ApiId=='${API_ID}'].[ApiMappingId]" --output text 2>/dev/null || echo "")
            ALL_COUNT=$(aws apigatewayv2 get-api-mappings --domain-name "$DOMAIN" --region eu-west-2 \
              --query 'length(Items)' --output text 2>/dev/null || echo "0")
            OUR_COUNT=0
            for MID in $MAPPINGS; do
              [ -z "$MID" ] || [ "$MID" = "None" ] && continue
              echo "Deleting mapping $MID from domain $DOMAIN"
              aws apigatewayv2 delete-api-mapping --domain-name "$DOMAIN" --api-mapping-id "$MID" --region eu-west-2 2>/dev/null || true
              OUR_COUNT=$((OUR_COUNT + 1))
            done
            if [ "$OUR_COUNT" -gt 0 ] && [ "$OUR_COUNT" -eq "$ALL_COUNT" ]; then
              echo "Deleting domain $DOMAIN (all mappings were ours)"
              aws apigatewayv2 delete-domain-name --domain-name "$DOMAIN" --region eu-west-2 2>/dev/null || true
            fi
          done
          echo "API Gateway custom domain mapping cleanup complete"

      - name: Delete stacks in dependency order
        shell: bash
        run: |
          DEPLOYMENT="${{ needs.names.outputs.deployment-name }}"

          delete_stack_in_region() {
            local STACK="$1" REGION="$2"
            local STATUS
            STATUS=$(aws cloudformation describe-stacks --stack-name "$STACK" --region "$REGION" \
              --query "Stacks[0].StackStatus" --output text 2>/dev/null || echo "DOES_NOT_EXIST")
            if [ "$STATUS" = "DOES_NOT_EXIST" ]; then
              echo "  $STACK does not exist in $REGION, skipping"
              return 0
            fi
            echo "  Deleting $STACK in $REGION (status: $STATUS)..."
            aws cloudformation delete-stack --stack-name "$STACK" --region "$REGION" 2>/dev/null || true
            aws cloudformation wait stack-delete-complete --stack-name "$STACK" --region "$REGION" 2>/dev/null || true
            # Check for DELETE_FAILED and force delete
            STATUS=$(aws cloudformation describe-stacks --stack-name "$STACK" --region "$REGION" \
              --query "Stacks[0].StackStatus" --output text 2>/dev/null || echo "DOES_NOT_EXIST")
            if [ "$STATUS" = "DELETE_FAILED" ]; then
              echo "  $STACK is DELETE_FAILED, force deleting"
              aws cloudformation delete-stack --stack-name "$STACK" --region "$REGION" \
                --deletion-mode FORCE_DELETE_STACK || true
              aws cloudformation wait stack-delete-complete --stack-name "$STACK" --region "$REGION" 2>/dev/null || true
            fi
          }

          # Delete in reverse dependency order (leaf stacks first)
          echo "=== Phase 1: SelfDestruct + Ops + Publish (no dependents) ==="
          delete_stack_in_region "${DEPLOYMENT}-app-SelfDestructStack" eu-west-2
          delete_stack_in_region "${DEPLOYMENT}-app-OpsStack" eu-west-2
          delete_stack_in_region "${DEPLOYMENT}-app-PublishStack" us-east-1

          echo "=== Phase 2: EdgeStack (depends on ApiStack outputs) ==="
          delete_stack_in_region "${DEPLOYMENT}-app-EdgeStack" us-east-1

          echo "=== Phase 3: ApiStack (depends on Lambda stacks) ==="
          delete_stack_in_region "${DEPLOYMENT}-app-ApiStack" eu-west-2

          echo "=== Phase 4: Lambda stacks (no cross-dependencies) ==="
          delete_stack_in_region "${DEPLOYMENT}-app-AuthStack" eu-west-2
          delete_stack_in_region "${DEPLOYMENT}-app-HmrcStack" eu-west-2
          delete_stack_in_region "${DEPLOYMENT}-app-AccountStack" eu-west-2
          delete_stack_in_region "${DEPLOYMENT}-app-BillingStack" eu-west-2

          echo "=== Stack deletion complete ==="

      - name: CDK destroy (cleanup pass)
        if: ${{ !cancelled() }}
        run: |
          cd cdk-application && \
            npx dotenv -e ../.env.${{ needs.names.outputs.environment-name }} -- \
              npx cdk destroy \
              --all \
              --force \
              --no-notices \
          && cd .. \
          || echo "CDK destroy cleanup pass completed (some stacks may already be deleted)"
        env:
          ENVIRONMENT_NAME: ${{ needs.names.outputs.environment-name }}
          DEPLOYMENT_NAME: ${{ needs.names.outputs.deployment-name }}
          BASE_IMAGE_TAG: "${{ env.BASE_IMAGE_TAG }}:latest"
          # Looked up from Cognito domain convention
          COGNITO_USER_POOL_ARN: ${{ steps.lookup.outputs.cognito-user-pool-arn }}
          COGNITO_CLIENT_ID: ${{ steps.lookup.outputs.cognito-client-id }}
          WEBSITE_HASH: 'placeholder'
          HTTP_API_URL: 'https://placeholder'

      - name: Retry DELETE_FAILED stacks
        if: ${{ !cancelled() }}
        shell: bash
        run: |
          DEPLOYMENT="${{ needs.names.outputs.deployment-name }}"
          FAILED_STACKS=$(aws cloudformation list-stacks --region eu-west-2 \
            --stack-status-filter DELETE_FAILED \
            --query "StackSummaries[?starts_with(StackName, '${DEPLOYMENT}')].StackName" \
            --output text 2>/dev/null || echo "")
          for STACK in $FAILED_STACKS; do
            [ -z "$STACK" ] || [ "$STACK" = "None" ] && continue
            echo "Stack $STACK is DELETE_FAILED, retrying with --retain-resources"
            FAILED_RESOURCES=$(aws cloudformation list-stack-resources --stack-name "$STACK" --region eu-west-2 \
              --query "StackResourceSummaries[?ResourceStatus=='DELETE_FAILED'].LogicalResourceId" \
              --output text 2>/dev/null || echo "")
            if [ -n "$FAILED_RESOURCES" ] && [ "$FAILED_RESOURCES" != "None" ]; then
              echo "Retaining: $FAILED_RESOURCES"
              aws cloudformation delete-stack --stack-name "$STACK" --region eu-west-2 \
                --retain-resources $FAILED_RESOURCES || true
            else
              echo "No failed resources found, retrying plain delete"
              aws cloudformation delete-stack --stack-name "$STACK" --region eu-west-2 || true
            fi
            echo "Waiting for $STACK deletion..."
            aws cloudformation wait stack-delete-complete --stack-name "$STACK" --region eu-west-2 2>/dev/null || true
          done

      - name: CDK stacks after
        if: ${{ !cancelled() }}
        run: |
          aws cloudformation describe-stacks --region eu-west-2 --query "Stacks[].StackName" --output text | tr '\t' '\n' | sort
          aws cloudformation describe-stacks --region us-east-1 --query "Stacks[].StackName" --output text | tr '\t' '\n' | sort
