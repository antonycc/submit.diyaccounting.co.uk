name: destroy
run-name: "destroy from ${{ github.ref_name }}"
concurrency:
  group: destroy-${{ github.ref_name }}
  cancel-in-progress: false

on:
  workflow_dispatch:
    inputs:
      environment-name:
        type: choice
        description: 'Environment name to use instead of computing from branch, e.g. ci or prod'
        required: false
        options:
          - ''
          - 'ci'
          - 'prod'
        default: ''
      deployment-name:
        type: string
        description: 'Deployment name to use instead of computing from branch, e.g. ci-lambdas6 or prod-ea373de'
        required: false
        default: ''
      sweep-for-stacks:
        type: boolean
        description: 'Whether to sweep for leftover stacks (true) or select by branch/environment/deployment name (false)'
        required: false
  workflow_call:
    inputs:
      environment-name:
        type: string
        description: 'Environment name to use instead of computing from branch, e.g. ci or prod'
        required: false
        default: ''
      deployment-name:
        type: string
        description: 'Deployment name to use instead of computing from branch, e.g. ci-lambdas6 or prod-ea373de'
        required: false
        default: ''
      sweep-for-stacks:
        type: boolean
        description: 'Whether to sweep for leftover stacks (true) or select by branch/environment/deployment name (false)'
        required: false
        default: false
  schedule:
    - cron: '0 8,10,12 * * *'

permissions:
  id-token: write
  contents: read

env:
  JAVA_VERSION: '21'
  NODE_VERSION: '22'
  ACTIONS_ROLE_ARN: 'arn:aws:iam::887764105431:role/submit-github-actions-role'
  DEPLOY_ROLE_ARN:  'arn:aws:iam::887764105431:role/submit-deployment-role'
  AWS_REGION: 'eu-west-2'
  AWS_ACCOUNT_ID: '887764105431'
  BASE_IMAGE_TAG_PREFIX: 'submit-base'
  GITHUB_ACTOR: ${{ github.actor }}
  SELF_DESTRUCT_DELAY_HOURS: '8'
  BASE_IMAGE_TAG: ${{ github.sha }}
  FORCE_ALL_STACK_DEPLOYMENT: 'false'
  COMMIT_HASH: ${{ github.sha }}
  BUILD_NUMBER: ${{ github.run_number }}

jobs:

  sweep-for-stacks:
    if: ${{ inputs.sweep-for-stacks || github.event.inputs.sweep-for-stacks == true || github.event_name == 'schedule' }}
    name: 'sweep for stacks'
    runs-on: ubuntu-24.04
    environment: ${{ github.ref == 'refs/heads/main' && 'prod' || 'ci' }}
    steps:

      - name: Configure AWS role via GitHub OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ env.ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Assume AWS deployment role
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ env.DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: CDK stacks in eu-west-2 and us-east-1
        run: |
          aws cloudformation describe-stacks --region eu-west-2 --query "Stacks[].StackName" --output text | tr '\t' '\n' | sort
          aws cloudformation describe-stacks --region us-east-1 --query "Stacks[].StackName" --output text | tr '\t' '\n' | sort

      # Get last known good deployment names from SSM Parameter Store that match the ci- or prod- pattern
      - name: Get last known good deployment names
        id: last-known-good-deployment-names
        run: |
          LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI="/submit/ci/last-known-good-deployment"
          LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD="/submit/prod/last-known-good-deployment"
          echo "Getting SSM Parameter Store parameter $LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI and $LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD"
          aws ssm get-parameter \
            --name "$LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI" \
            --query "Parameter.Value" \
            --output text \
            > /tmp/last-known-good-deployment-ci.txt \
            || echo "Parameter $LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI not found"
          aws ssm get-parameter \
            --name "$LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD" \
            --query "Parameter.Value" \
            --output text \
            > /tmp/last-known-good-deployment-prod.txt \
            || echo "Parameter $LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD not found"
          LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI_VALUE=$(cat /tmp/last-known-good-deployment-ci.txt || echo "")
          LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD_VALUE=$(cat /tmp/last-known-good-deployment-prod.txt || echo "")
          echo "Last known good deployment name CI: $LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI_VALUE"
          echo "Last known good deployment name PROD: $LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD_VALUE"
          echo "last-known-good-deployment-name-ci=$LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI_VALUE" >> $GITHUB_OUTPUT
          echo "last-known-good-deployment-name-prod=$LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD_VALUE" >> $GITHUB_OUTPUT

      # Get the record names of aliases in any cloudfront distributions that match the ci- or prod- pattern in the first part of the domain name
      - name: Get the public record names
        id: public-deployment-names
        run: |
          echo "Getting CloudFront distributions"
          DISTRIBUTION_IDS=$(aws cloudfront list-distributions --query "DistributionList.Items[].Id" --output text)
          PUBLIC_DEPLOYMENT_NAMES=""
          echo "Found CloudFront Distribution IDs: $DISTRIBUTION_IDS"
          for DISTRIBUTION_ID in $DISTRIBUTION_IDS; do
            ALIASES=$(aws cloudfront get-distribution --id "$DISTRIBUTION_ID" --query "Distribution.DistributionConfig.Aliases.Items[]" --output text)
            echo "Found aliases for Distribution ID $DISTRIBUTION_ID: $ALIASES"
            for ALIAS in $ALIASES; do
              RECORD_NAME=$(echo "$ALIAS" | cut -d'.' -f1)
              if [[ "$RECORD_NAME" =~ ^(ci|prod)-.* ]]; then
                PUBLIC_DEPLOYMENT_NAMES="$PUBLIC_DEPLOYMENT_NAMES $RECORD_NAME"
              fi
            done
          done

          # Remove duplicates
          echo "Collected public deployment names before deduplication: $PUBLIC_DEPLOYMENT_NAMES"
          PUBLIC_DEPLOYMENT_NAMES=$(echo $PUBLIC_DEPLOYMENT_NAMES | tr ' ' '\n' | sort -u | tr '\n' ' ')

          echo "Public deployment names: $PUBLIC_DEPLOYMENT_NAMES"
          echo "public-deployment-names=$PUBLIC_DEPLOYMENT_NAMES" >> $GITHUB_OUTPUT

      # Select environment and deployment names of stacks to destroy matching .*-[ci|prod]-.* pattern but not the public deployment names or last known good deployment names
      - name: Select environment and deployment names
        id: select-stack
        run: |
          LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI="${{ steps.last-known-good-deployment-names.outputs.last-known-good-deployment-name-ci }}"
          LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD="${{ steps.last-known-good-deployment-names.outputs.last-known-good-deployment-name-prod }}"
          PUBLIC_DEPLOYMENT_NAMES="${{ steps.public-deployment-names.outputs.public-deployment-names }}"

          echo "Last known good deployment names: CI='$LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI', PROD='$LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD'"
          echo "Public deployment names: $PUBLIC_DEPLOYMENT_NAMES"

          STACK_DEPLOYMENT_NAMES_TO_KEEP=()

          for DEPLOYMENT_NAME in $(echo "$PUBLIC_DEPLOYMENT_NAMES $LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI $LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD" | tr ' ' '\n'); do
            if [ -n "$DEPLOYMENT_NAME" ]; then
              STACK_DEPLOYMENT_NAMES_TO_KEEP+=("$DEPLOYMENT_NAME")
            fi
          done

          # Remove duplicates from STACK_DEPLOYMENT_NAMES_TO_KEEP in a simple way
          echo "Removing duplicates from stacks to keep from: ${STACK_DEPLOYMENT_NAMES_TO_KEEP[*]}"
          STACK_DEPLOYMENT_NAMES_TO_KEEP=($(echo "${STACK_DEPLOYMENT_NAMES_TO_KEEP[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' '))

          echo "Stacks to skip destruction: ${STACK_DEPLOYMENT_NAMES_TO_KEEP[*]}"

          # List all stacks and filter out those matching STACK_DEPLOYMENT_NAMES_TO_KEEP
          # e.g.
          # SELECTED_ENVIRONMENT_NAME="ci"
          # SELECTED_DEPLOYMENT_NAME="ci-oldstack123"
          SELECTED_ENVIRONMENT_NAME=""
          SELECTED_DEPLOYMENT_NAME=""
          for DEPLOYMENT_NAME in $(aws cloudformation describe-stacks \
            --region eu-west-2 \
            --query "Stacks[].StackName" \
            --output text \
            | tr '\t' '\n' \
            | grep -E '^(app|del)-((ci|prod)-[a-zA-Z0-9-]+)-') \
          ; do
              echo "Extract deployment name from stack name: $DEPLOYMENT_NAME"
              DEPLOYMENT_NAME_EXTRACTED=$(echo "$DEPLOYMENT_NAME" | sed -E 's/^(app|del)-((ci|prod)-[a-zA-Z0-9-]+)-.*/\2/')
              if [[ ! " ${STACK_DEPLOYMENT_NAMES_TO_KEEP[@]} " =~ " ${DEPLOYMENT_NAME_EXTRACTED} " ]]; then
                SELECTED_DEPLOYMENT_NAME="$DEPLOYMENT_NAME_EXTRACTED"
                echo "Found stack for potential destruction: $DEPLOYMENT_NAME (deployment name: $SELECTED_DEPLOYMENT_NAME)"
                if [[ "$SELECTED_DEPLOYMENT_NAME" == ci-* ]]; then
                    echo "Matched ci stack for destruction"
                    SELECTED_ENVIRONMENT_NAME="ci"
                elif [[ "$SELECTED_DEPLOYMENT_NAME" == prod-* ]]; then
                    echo "Matched prod stack for destruction"
                    SELECTED_ENVIRONMENT_NAME="prod"
                fi
                echo "Selected stack for destruction: Environment='$SELECTED_ENVIRONMENT_NAME', Deployment='$SELECTED_DEPLOYMENT_NAME'"
                break
              else
                echo "Skipping stack $DEPLOYMENT_NAME as it is in the keep list"
              fi
          done

          if [ -z "$SELECTED_DEPLOYMENT_NAME" ]; then
            echo "No stacks found for destruction"
            SWEEPER_HIT="false"
          else
            echo "Stacks found for destruction ${SELECTED_ENVIRONMENT_NAME}/${SELECTED_DEPLOYMENT_NAME}"
            SWEEPER_HIT="true"
          fi

          echo "SWEEPER_HIT=$SWEEPER_HIT"
          echo "SELECTED_ENVIRONMENT_NAME=$SELECTED_ENVIRONMENT_NAME"
          echo "SELECTED_DEPLOYMENT_NAME=$SELECTED_DEPLOYMENT_NAME"
          echo "SWEEPER_HIT=$SWEEPER_HIT" >> $GITHUB_OUTPUT
          echo "SELECTED_ENVIRONMENT_NAME=$SELECTED_ENVIRONMENT_NAME" >> $GITHUB_OUTPUT
          echo "SELECTED_DEPLOYMENT_NAME=$SELECTED_DEPLOYMENT_NAME" >> $GITHUB_OUTPUT

    outputs:
      sweeper-hit: ${{ steps.select-stack.outputs.SWEEPER_HIT }}
      environment-name: ${{ steps.select-stack.outputs.SELECTED_ENVIRONMENT_NAME }}
      deployment-name: ${{ steps.select-stack.outputs.SELECTED_DEPLOYMENT_NAME }}

  names:
    if: ${{ !cancelled() && needs.sweep-for-stacks.outputs.sweeper-hit != 'false' }}
    needs:
      - sweep-for-stacks
    runs-on: ubuntu-24.04
    environment: ${{ github.ref == 'refs/heads/main' && 'prod' || 'ci' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5
      - name: Compute deployment name and environment
        id: deployment-config
        uses: ./.github/actions/get-names
        with:
          environment-name: ${{ needs.sweep-for-stacks.outputs.environment-name || inputs.environment-name || '' }}
          deployment-name: ${{ needs.sweep-for-stacks.outputs.deployment-name || inputs.deployment-name || '' }}
    outputs:
      environment-name: ${{ steps.deployment-config.outputs.environment-name }}
      deployment-name: ${{ steps.deployment-config.outputs.deployment-name }}
      base-domain: ${{ steps.deployment-config.outputs.base-domain }}
      base-url: ${{ steps.deployment-config.outputs.base-url }}
      apex-domain: ${{ steps.deployment-config.outputs.apex-domain }}
      apex-url: ${{ steps.deployment-config.outputs.apex-url }}
      holding-domain: ${{ steps.deployment-config.outputs.holding-domain }}
      holding-url: ${{ steps.deployment-config.outputs.holding-url }}

  destroy:
    if: ${{ !cancelled() && needs.sweep-for-stacks.outputs.sweeper-hit != 'false' }}
    needs:
      - names
      - sweep-for-stacks
    runs-on: ubuntu-latest
    environment: ${{ github.ref == 'refs/heads/main' && 'prod' || 'ci' }}
    steps:
      - name: Checkout default branch
        uses: actions/checkout@v5
        with:
          ref: ${{ github.event.repository.default_branch }} # e.g. main
          fetch-depth: 0

      - name: Report deleted ref
        run: |
          echo "Deleted: ${{ github.event.ref }}"
          echo "Ref type: ${{ github.event.ref_type }}"

      - name: Checkout
        uses: actions/checkout@v5

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - uses: actions/setup-java@v5
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}
          cache: 'maven'

      - name: Configure AWS role via GitHub OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ env.ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Assume AWS deployment role
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ env.DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: CDK stacks before
        run: |
          aws cloudformation describe-stacks --region eu-west-2 --query "Stacks[].StackName" --output text | tr '\t' '\n' | sort
          aws cloudformation describe-stacks --region us-east-1 --query "Stacks[].StackName" --output text | tr '\t' '\n' | sort

      - name: Node dependencies
        run: npm ci

      - name: Build CDK
        run: ./mvnw --errors clean package -DskipTests

      - name: Destroy PublishStack
        run: |
          cd cdk-delivery && \
            npx dotenv -e ../.env.${{ needs.names.outputs.environment-name }} -- \
              npx cdk destroy \
              del-${{ needs.names.outputs.deployment-name }}-PublishStack \
              --exclusively --force \
          && cd .. \
          ;
        env:
          ENVIRONMENT_NAME: ${{ needs.names.outputs.environment-name }}
          DEPLOYMENT_NAME: ${{ needs.names.outputs.deployment-name }}
          SELF_DESTRUCT_HANDLER_SOURCE: "../infra/test/resources/fake-self-destruct-lambda.jar"
          WEBSITE_HASH: 'placeholder'

      - name: Destroy EdgeStack
        run: |
          cd cdk-delivery && \
            npx dotenv -e ../.env.${{ needs.names.outputs.environment-name }} -- \
              npx cdk destroy \
              del-${{ needs.names.outputs.deployment-name }}-EdgeStack \
              --exclusively --force \
          && cd .. \
          ;
        env:
          ENVIRONMENT_NAME: ${{ needs.names.outputs.environment-name }}
          DEPLOYMENT_NAME: ${{ needs.names.outputs.deployment-name }}
          SELF_DESTRUCT_HANDLER_SOURCE: "../infra/test/resources/fake-self-destruct-lambda.jar"
          WEBSITE_HASH: 'placeholder'

      - name: Destroy OpsStack
        run: |
          cd cdk-application && \
            npx dotenv -e ../.env.${{ needs.names.outputs.environment-name }} -- \
              npx cdk destroy \
              app-${{ needs.names.outputs.deployment-name }}-OpsStack \
              --exclusively --force \
          && cd .. \
          ;
        env:
          ENVIRONMENT_NAME: ${{ needs.names.outputs.environment-name }}
          DEPLOYMENT_NAME: ${{ needs.names.outputs.deployment-name }}
          SELF_DESTRUCT_HANDLER_SOURCE: "../infra/test/resources/fake-self-destruct-lambda.jar"
          BASE_IMAGE_TAG: "${{ env.BASE_IMAGE_TAG }}:latest"
          # Set by deploy-environment.yml after the environment's AuthStack is deployed
          COGNITO_USER_POOL_ARN: ${{ vars.COGNITO_USER_POOL_ARN }}
          COGNITO_CLIENT_ID: ${{ vars.COGNITO_CLIENT_ID }}

      - name: Destroy AccountStack
        run: |
          cd cdk-application && \
            npx dotenv -e ../.env.${{ needs.names.outputs.environment-name }} -- \
              npx cdk destroy \
              app-${{ needs.names.outputs.deployment-name }}-AccountStack \
              --exclusively --force \
          && cd .. \
          ;
        env:
          ENVIRONMENT_NAME: ${{ needs.names.outputs.environment-name }}
          DEPLOYMENT_NAME: ${{ needs.names.outputs.deployment-name }}
          SELF_DESTRUCT_HANDLER_SOURCE: "../infra/test/resources/fake-self-destruct-lambda.jar"
          BASE_IMAGE_TAG: "${{ env.BASE_IMAGE_TAG }}:latest"
          # Set by deploy-environment.yml after the environment's AuthStack is deployed
          COGNITO_USER_POOL_ARN: ${{ vars.COGNITO_USER_POOL_ARN }}
          COGNITO_CLIENT_ID: ${{ vars.COGNITO_CLIENT_ID }}

      - name: Destroy HmrcStack
        run: |
          cd cdk-application && \
            npx dotenv -e ../.env.${{ needs.names.outputs.environment-name }} -- \
              npx cdk destroy \
              app-${{ needs.names.outputs.deployment-name }}-HmrcStack \
              --exclusively --force \
          && cd .. \
          ;
        env:
          ENVIRONMENT_NAME: ${{ needs.names.outputs.environment-name }}
          DEPLOYMENT_NAME: ${{ needs.names.outputs.deployment-name }}
          SELF_DESTRUCT_HANDLER_SOURCE: "../infra/test/resources/fake-self-destruct-lambda.jar"
          BASE_IMAGE_TAG: "${{ env.BASE_IMAGE_TAG }}:latest"
          # Set by deploy-environment.yml after the environment's AuthStack is deployed
          COGNITO_USER_POOL_ARN: ${{ vars.COGNITO_USER_POOL_ARN }}
          COGNITO_CLIENT_ID: ${{ vars.COGNITO_CLIENT_ID }}

      - name: Destroy AuthStack
        run: |
          cd cdk-application && \
            npx dotenv -e ../.env.${{ needs.names.outputs.environment-name }} -- \
              npx cdk destroy \
              app-${{ needs.names.outputs.deployment-name }}-AuthStack \
              --exclusively --force \
          && cd .. \
          ;
        env:
          ENVIRONMENT_NAME: ${{ needs.names.outputs.environment-name }}
          DEPLOYMENT_NAME: ${{ needs.names.outputs.deployment-name }}
          SELF_DESTRUCT_HANDLER_SOURCE: "../infra/test/resources/fake-self-destruct-lambda.jar"
          BASE_IMAGE_TAG: "${{ env.BASE_IMAGE_TAG }}:latest"
          # Set by deploy-environment.yml after the environment's AuthStack is deployed
          COGNITO_USER_POOL_ARN: ${{ vars.COGNITO_USER_POOL_ARN }}
          COGNITO_CLIENT_ID: ${{ vars.COGNITO_CLIENT_ID }}

      - name: Destroy DevStack
        run: |
          cd cdk-application && \
            npx dotenv -e ../.env.${{ needs.names.outputs.environment-name }} -- \
              npx cdk destroy \
              app-${{ needs.names.outputs.deployment-name }}-DevStack \
              --exclusively --force \
          && cd .. \
          ;
        env:
          ENVIRONMENT_NAME: ${{ needs.names.outputs.environment-name }}
          DEPLOYMENT_NAME: ${{ needs.names.outputs.deployment-name }}
          SELF_DESTRUCT_HANDLER_SOURCE: "../infra/test/resources/fake-self-destruct-lambda.jar"
          BASE_IMAGE_TAG: "${{ env.BASE_IMAGE_TAG }}:latest"
          # Set by deploy-environment.yml after the environment's AuthStack is deployed
          COGNITO_USER_POOL_ARN: ${{ vars.COGNITO_USER_POOL_ARN }}
          COGNITO_CLIENT_ID: ${{ vars.COGNITO_CLIENT_ID }}

      - name: Destroy SelfDestructStack (Delivery)
        run: |
          cd cdk-delivery && \
            npx dotenv -e ../.env.${{ needs.names.outputs.environment-name }} -- \
              npx cdk destroy \
              del-${{ needs.names.outputs.deployment-name }}-SelfDestructStack \
              --exclusively --force \
          && cd .. \
          ;
        env:
          ENVIRONMENT_NAME: ${{ needs.names.outputs.environment-name }}
          DEPLOYMENT_NAME: ${{ needs.names.outputs.deployment-name }}
          SELF_DESTRUCT_HANDLER_SOURCE: "../infra/test/resources/fake-self-destruct-lambda.jar"
          WEBSITE_HASH: 'placeholder'

      - name: Destroy SelfDestructStack (Application)
        run: |
          cd cdk-application && \
            npx dotenv -e ../.env.${{ needs.names.outputs.environment-name }} -- \
              npx cdk destroy \
              app-${{ needs.names.outputs.deployment-name }}-SelfDestructStack \
              --exclusively --force \
          && cd .. \
          ;
        env:
          ENVIRONMENT_NAME: ${{ needs.names.outputs.environment-name }}
          DEPLOYMENT_NAME: ${{ needs.names.outputs.deployment-name }}
          SELF_DESTRUCT_HANDLER_SOURCE: "../infra/test/resources/fake-self-destruct-lambda.jar"
          BASE_IMAGE_TAG: "${{ env.BASE_IMAGE_TAG }}:latest"
          # Set by deploy-environment.yml after the environment's AuthStack is deployed
          COGNITO_USER_POOL_ARN: ${{ vars.COGNITO_USER_POOL_ARN }}
          COGNITO_CLIENT_ID: ${{ vars.COGNITO_CLIENT_ID }}

      - name: CDK stacks after
        if: ${{ !cancelled() }}
        run: |
          aws cloudformation describe-stacks --region eu-west-2 --query "Stacks[].StackName" --output text | tr '\t' '\n' | sort
          aws cloudformation describe-stacks --region us-east-1 --query "Stacks[].StackName" --output text | tr '\t' '\n' | sort
