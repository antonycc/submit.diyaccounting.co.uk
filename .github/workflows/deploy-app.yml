name: deploy-app
run-name: "lean deploy ${{ inputs.deployment-name || '(auto)' }} from ${{ github.ref_name }}"
# SPDX-FileCopyrightText: 2026 DIY Accounting Limited
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# Lean app deployment: updates Lambda function code (Docker image) and static web assets
# without running CDK. Bypasses full deploy.yml for rapid iteration (~5-8 min vs 15-25 min).

concurrency:
  group: deploy-app-${{ github.ref_name }}
  cancel-in-progress: false

on:
  workflow_dispatch:
    inputs:
      environment-name:
        type: choice
        description: 'Environment name'
        required: false
        options:
          - '(auto)'
          - 'ci'
          - 'prod'
        default: '(auto)'
      deployment-name:
        type: string
        description: 'Deployment name (e.g. ci-leanbuild or prod-ea373de). Leave empty for last-known-good.'
        required: false
        default: ''
      skip-docker:
        type: boolean
        description: 'Skip Docker build & ECR push'
        required: false
        default: false
      skip-lambdas:
        type: boolean
        description: 'Skip Lambda function updates'
        required: false
        default: false
      skip-web:
        type: boolean
        description: 'Skip web asset sync & CloudFront invalidation'
        required: false
        default: false
      skip-tests:
        type: boolean
        description: 'Skip behaviour tests after deployment'
        required: false
        default: false
      skip-cleanup:
        type: boolean
        description: 'Keep test user and native auth enabled after tests (for debugging)'
        required: false
        default: false

permissions:
  id-token: write
  contents: read

env:
  NODE_VERSION: '24'
  ACTIONS_ROLE_ARN: 'arn:aws:iam::887764105431:role/submit-github-actions-role'
  DEPLOY_ROLE_ARN:  'arn:aws:iam::887764105431:role/submit-deployment-role'
  AWS_REGION: 'eu-west-2'
  AWS_ACCOUNT_ID: '887764105431'
  BASE_IMAGE_TAG_PREFIX: 'submit-base'

jobs:

  params:
    runs-on: ubuntu-24.04
    steps:
      - name: "inputs.environment-name=[${{ inputs.environment-name }}]"
        run: ":"
      - name: "inputs.deployment-name=[${{ inputs.deployment-name }}]"
        run: ":"
      - name: "inputs.skip-docker=[${{ inputs.skip-docker }}]"
        run: ":"
      - name: "inputs.skip-lambdas=[${{ inputs.skip-lambdas }}]"
        run: ":"
      - name: "inputs.skip-web=[${{ inputs.skip-web }}]"
        run: ":"
      - name: "inputs.skip-tests=[${{ inputs.skip-tests }}]"
        run: ":"
      - name: "inputs.skip-cleanup=[${{ inputs.skip-cleanup }}]"
        run: ":"
      - name: Normalise Params
        id: normalise
        shell: bash
        run: |
          # Convert '(auto)' to empty string for downstream processing
          ENV_NAME='${{ inputs.environment-name }}'; [[ "$ENV_NAME" == "(auto)" ]] && ENV_NAME=""
          echo "environment-name=${ENV_NAME}" | tee -a "$GITHUB_OUTPUT"
          echo 'deployment-name=${{ inputs.deployment-name }}' | tee -a "$GITHUB_OUTPUT"
          X='${{ inputs.skip-docker }}' ; echo "skip-docker=${X:-false}" | tee -a "$GITHUB_OUTPUT"
          X='${{ inputs.skip-lambdas }}' ; echo "skip-lambdas=${X:-false}" | tee -a "$GITHUB_OUTPUT"
          X='${{ inputs.skip-web }}' ; echo "skip-web=${X:-false}" | tee -a "$GITHUB_OUTPUT"
          X='${{ inputs.skip-tests }}' ; echo "skip-tests=${X:-false}" | tee -a "$GITHUB_OUTPUT"
          X='${{ inputs.skip-cleanup }}' ; echo "skip-cleanup=${X:-false}" | tee -a "$GITHUB_OUTPUT"
    outputs:
      environment-name: ${{ steps.normalise.outputs.environment-name }}
      deployment-name: ${{ steps.normalise.outputs.deployment-name }}
      skip-docker: ${{ steps.normalise.outputs.skip-docker }}
      skip-lambdas: ${{ steps.normalise.outputs.skip-lambdas }}
      skip-web: ${{ steps.normalise.outputs.skip-web }}
      skip-tests: ${{ steps.normalise.outputs.skip-tests }}
      skip-cleanup: ${{ steps.normalise.outputs.skip-cleanup }}

  names:
    needs: params
    runs-on: ubuntu-24.04
    environment: ${{ github.ref == 'refs/heads/main' && 'prod' || 'ci' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Configure AWS role via GitHub OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ env.ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Assume AWS deployment role
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ env.DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Read last known good deployment from SSM (main branch)
        if: ${{ needs.params.outputs.deployment-name == '' && github.ref == 'refs/heads/main' }}
        run: |
          PARAMETER_NAME="/submit/prod/last-known-good-deployment"
          aws ssm get-parameter --name "$PARAMETER_NAME" --query "Parameter.Value" --output text | tee /tmp/last_known_good_deployment.txt
          echo "Last known good deployment: $(cat /tmp/last_known_good_deployment.txt)"

      - name: Read last known good deployment from SSM (feature branch)
        if: ${{ needs.params.outputs.deployment-name == '' && github.ref != 'refs/heads/main' }}
        run: |
          PARAMETER_NAME="/submit/ci/last-known-good-deployment"
          aws ssm get-parameter --name "$PARAMETER_NAME" --query "Parameter.Value" --output text | tee /tmp/last_known_good_deployment.txt
          echo "Last known good deployment: $(cat /tmp/last_known_good_deployment.txt)"

      - name: Determine deployment name
        id: deployment-name
        run: |
          if [ -n "${{ needs.params.outputs.deployment-name }}" ]; then
            echo "Using explicitly provided deployment name"
            echo "deployment-name=${{ needs.params.outputs.deployment-name }}" | tee -a "$GITHUB_OUTPUT"
          elif [ -s /tmp/last_known_good_deployment.txt ]; then
            echo "Using last known good deployment from SSM Parameter Store"
            echo "deployment-name=$(cat /tmp/last_known_good_deployment.txt)" | tee -a "$GITHUB_OUTPUT"
          else
            echo "ERROR: No deployment name available" >&2
            exit 1
          fi

      - name: Compute environment name and URLs
        id: deployment-config
        uses: './.github/actions/get-names'
        with:
          environment-name: ${{ needs.params.outputs.environment-name }}
          deployment-name: ${{ steps.deployment-name.outputs.deployment-name }}
    outputs:
      environment-name: ${{ steps.deployment-config.outputs.environment-name }}
      deployment-name: ${{ steps.deployment-config.outputs.deployment-name }}
      public-url: ${{ steps.deployment-config.outputs.public-url }}

  docker-build:
    name: 'build Docker image'
    if: ${{ needs.params.outputs.skip-docker != 'true' }}
    needs:
      - params
      - names
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build ARM64 Docker image
        run: |
          docker buildx build \
            --platform linux/arm64 \
            --provenance=false \
            --load \
            -t "${{ env.BASE_IMAGE_TAG_PREFIX }}:${{ github.sha }}" \
            -f Dockerfile .

      - name: Save Docker image artifact
        run: |
          mkdir docker-image
          docker save -o docker-image/image.tar "${{ env.BASE_IMAGE_TAG_PREFIX }}:${{ github.sha }}"

      - name: Upload image artifact
        uses: actions/upload-artifact@v6
        with:
          name: docker-image
          path: docker-image/image.tar
          retention-days: 1

  push-images:
    name: 'push images eu-west-2'
    if: ${{ needs.params.outputs.skip-docker != 'true' }}
    needs:
      - params
      - names
      - docker-build
    runs-on: ubuntu-24.04
    environment: ${{ github.ref == 'refs/heads/main' && 'prod' || 'ci' }}
    steps:
      - name: Configure AWS role via GitHub OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ env.ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Assume AWS deployment role
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ env.DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Login to Amazon ECR
        shell: bash
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} \
            | docker login --username AWS --password-stdin "${ECR_REPOSITORY_BASE_URL}"
        env:
          ECR_REPOSITORY_BASE_URL: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com

      - name: Check if image already exists
        id: image-exists
        shell: bash
        run: |
          if aws ecr describe-images --repository-name "${ECR_REPOSITORY_NAME}" --image-ids imageTag="${{ github.sha }}" >/dev/null 2>&1; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi
        env:
          ECR_REPOSITORY_NAME: ${{ needs.names.outputs.environment-name }}-env-ecr

      - name: Download image artifact
        if: ${{ steps.image-exists.outputs.exists != 'true' }}
        uses: actions/download-artifact@v7
        with:
          name: docker-image
          path: docker-image/

      - name: Load Docker image
        if: ${{ steps.image-exists.outputs.exists != 'true' }}
        run: docker load -i docker-image/image.tar

      - name: Tag and push to ECR
        if: ${{ steps.image-exists.outputs.exists != 'true' }}
        shell: bash
        run: |
          docker tag "${{ env.BASE_IMAGE_TAG_PREFIX }}:${{ github.sha }}" "${ECR_REPOSITORY_BASE_URL}/${ECR_REPOSITORY_NAME}:${{ github.sha }}"
          docker tag "${{ env.BASE_IMAGE_TAG_PREFIX }}:${{ github.sha }}" "${ECR_REPOSITORY_BASE_URL}/${ECR_REPOSITORY_NAME}:latest"
          docker push "${ECR_REPOSITORY_BASE_URL}/${ECR_REPOSITORY_NAME}:${{ github.sha }}"
          docker push "${ECR_REPOSITORY_BASE_URL}/${ECR_REPOSITORY_NAME}:latest"
        env:
          ECR_REPOSITORY_BASE_URL: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
          ECR_REPOSITORY_NAME: ${{ needs.names.outputs.environment-name }}-env-ecr

  push-images-us-east-1:
    name: 'push images us-east-1'
    if: ${{ needs.params.outputs.skip-docker != 'true' }}
    needs:
      - params
      - names
      - docker-build
    runs-on: ubuntu-24.04
    environment: ${{ github.ref == 'refs/heads/main' && 'prod' || 'ci' }}
    steps:
      - name: Configure AWS role via GitHub OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ env.ACTIONS_ROLE_ARN }}
          aws-region: us-east-1
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Assume AWS deployment role
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ env.DEPLOY_ROLE_ARN }}
          aws-region: us-east-1
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Login to Amazon ECR us-east-1
        shell: bash
        run: |
          aws ecr get-login-password --region us-east-1 \
            | docker login --username AWS --password-stdin "${ECR_REPOSITORY_BASE_URL}"
        env:
          ECR_REPOSITORY_BASE_URL: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com

      - name: Check if image already exists
        id: image-exists
        shell: bash
        run: |
          if aws ecr describe-images --region us-east-1 --repository-name "${ECR_REPOSITORY_NAME}" --image-ids imageTag="${{ github.sha }}" >/dev/null 2>&1; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi
        env:
          ECR_REPOSITORY_NAME: ${{ needs.names.outputs.environment-name }}-env-ecr-us-east-1

      - name: Download image artifact
        if: ${{ steps.image-exists.outputs.exists != 'true' }}
        uses: actions/download-artifact@v7
        with:
          name: docker-image
          path: docker-image/

      - name: Load Docker image
        if: ${{ steps.image-exists.outputs.exists != 'true' }}
        run: docker load -i docker-image/image.tar

      - name: Tag and push to ECR us-east-1
        if: ${{ steps.image-exists.outputs.exists != 'true' }}
        shell: bash
        run: |
          docker tag "${{ env.BASE_IMAGE_TAG_PREFIX }}:${{ github.sha }}" "${ECR_REPOSITORY_BASE_URL}/${ECR_REPOSITORY_NAME}:${{ github.sha }}"
          docker tag "${{ env.BASE_IMAGE_TAG_PREFIX }}:${{ github.sha }}" "${ECR_REPOSITORY_BASE_URL}/${ECR_REPOSITORY_NAME}:latest"
          docker push "${ECR_REPOSITORY_BASE_URL}/${ECR_REPOSITORY_NAME}:${{ github.sha }}"
          docker push "${ECR_REPOSITORY_BASE_URL}/${ECR_REPOSITORY_NAME}:latest"
        env:
          ECR_REPOSITORY_BASE_URL: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
          ECR_REPOSITORY_NAME: ${{ needs.names.outputs.environment-name }}-env-ecr-us-east-1

  update-lambdas:
    name: 'update Lambda functions'
    if: ${{ needs.params.outputs.skip-lambdas != 'true' }}
    needs:
      - params
      - names
      - push-images
      - push-images-us-east-1
    runs-on: ubuntu-24.04
    environment: ${{ github.ref == 'refs/heads/main' && 'prod' || 'ci' }}
    steps:
      - name: Configure AWS role via GitHub OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ env.ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Assume AWS deployment role
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ env.DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: List and update Lambda functions
        shell: bash
        run: |
          set -euo pipefail
          APP_PREFIX="${{ needs.names.outputs.deployment-name }}-app"
          IMAGE_URI="${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ needs.names.outputs.environment-name }}-env-ecr:${{ github.sha }}"

          echo "Listing Lambda functions with prefix: ${APP_PREFIX}-"
          FUNCTIONS=$(aws lambda list-functions \
            --region ${{ env.AWS_REGION }} \
            --query "Functions[?starts_with(FunctionName, '${APP_PREFIX}-')].FunctionName" \
            --output json)

          COUNT=$(echo "$FUNCTIONS" | jq length)
          echo "Found ${COUNT} Lambda functions to update"

          if [ "$COUNT" -eq 0 ]; then
            echo "WARNING: No Lambda functions found. The deployment may not exist yet."
            exit 1
          fi

          # Update each function
          echo "$FUNCTIONS" | jq -r '.[]' | while read -r FN; do
            echo ""
            echo "=== Updating ${FN} ==="

            echo "  Updating function code to ${IMAGE_URI}..."
            aws lambda update-function-code \
              --function-name "${FN}" \
              --image-uri "${IMAGE_URI}" \
              --region ${{ env.AWS_REGION }} \
              --output text --query 'FunctionName' || { echo "  FAILED to update ${FN}"; continue; }

            echo "  Waiting for update to complete..."
            aws lambda wait function-updated \
              --function-name "${FN}" \
              --region ${{ env.AWS_REGION }}

            echo "  Publishing new version..."
            VERSION=$(aws lambda publish-version \
              --function-name "${FN}" \
              --region ${{ env.AWS_REGION }} \
              --output text --query 'Version')
            echo "  Published version ${VERSION}"

            echo "  Updating alias 'pc' -> version ${VERSION}..."
            aws lambda update-alias \
              --function-name "${FN}" \
              --name pc \
              --function-version "${VERSION}" \
              --region ${{ env.AWS_REGION }} \
              --output text --query 'AliasArn' 2>/dev/null \
              || echo "  No 'pc' alias for ${FN} (skipped)"
          done

          echo ""
          echo "All Lambda functions updated."

  sync-web-assets:
    name: 'sync web assets to S3'
    if: ${{ needs.params.outputs.skip-web != 'true' }}
    needs:
      - params
      - names
    runs-on: ubuntu-24.04
    environment: ${{ github.ref == 'refs/heads/main' && 'prod' || 'ci' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --ignore-scripts
        env:
          PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: 1

      - name: Configure AWS role via GitHub OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ env.ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Assume AWS deployment role
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ env.DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Resolve RUM config from ObservabilityStack
        id: rum-config
        shell: bash
        run: |
          set -euo pipefail
          STACK_NAME="${{ needs.names.outputs.environment-name }}-env-ObservabilityStack"
          echo "Resolving RUM outputs from $STACK_NAME in region ${{ env.AWS_REGION }}"
          JSON=$(aws cloudformation describe-stacks --stack-name "$STACK_NAME" --region "${{ env.AWS_REGION }}")
          RUM_APP_MONITOR_ID=$(echo "$JSON" | jq -r '.Stacks[0].Outputs[] | select(.OutputKey=="RumAppMonitorId") | .OutputValue')
          RUM_IDENTITY_POOL_ID=$(echo "$JSON" | jq -r '.Stacks[0].Outputs[] | select(.OutputKey=="RumIdentityPoolId") | .OutputValue')
          RUM_GUEST_ROLE_ARN=$(echo "$JSON" | jq -r '.Stacks[0].Outputs[] | select(.OutputKey=="RumGuestRoleArn") | .OutputValue')
          RUM_REGION=$(echo "$JSON" | jq -r '.Stacks[0].Outputs[] | select(.OutputKey=="RumRegion") | .OutputValue' 2>/dev/null || echo "${{ env.AWS_REGION }}")
          echo "RUM_APP_MONITOR_ID=$RUM_APP_MONITOR_ID" | tee -a "$GITHUB_OUTPUT"
          echo "RUM_IDENTITY_POOL_ID=$RUM_IDENTITY_POOL_ID" | tee -a "$GITHUB_OUTPUT"
          echo "RUM_GUEST_ROLE_ARN=$RUM_GUEST_ROLE_ARN" | tee -a "$GITHUB_OUTPUT"
          echo "RUM_REGION=$RUM_REGION" | tee -a "$GITHUB_OUTPUT"

      - name: Inject RUM placeholders into HTML files
        shell: bash
        env:
          RUM_APP_MONITOR_ID: ${{ steps.rum-config.outputs.RUM_APP_MONITOR_ID }}
          RUM_IDENTITY_POOL_ID: ${{ steps.rum-config.outputs.RUM_IDENTITY_POOL_ID }}
          RUM_GUEST_ROLE_ARN: ${{ steps.rum-config.outputs.RUM_GUEST_ROLE_ARN }}
          AWS_REGION: ${{ steps.rum-config.outputs.RUM_REGION }}
        run: |
          set -euo pipefail
          : "${RUM_APP_MONITOR_ID:?Missing RUM_APP_MONITOR_ID}"
          : "${RUM_IDENTITY_POOL_ID:?Missing RUM_IDENTITY_POOL_ID}"
          : "${RUM_GUEST_ROLE_ARN:?Missing RUM_GUEST_ROLE_ARN}"
          : "${AWS_REGION:?Missing AWS_REGION}"

          escape_sed_replacement() {
            printf '%s' "$1" | sed -e 's/[\/&]/\\&/g'
          }

          RUM_APP_MONITOR_ID_ESCAPED="$(escape_sed_replacement "${RUM_APP_MONITOR_ID}")"
          RUM_IDENTITY_POOL_ID_ESCAPED="$(escape_sed_replacement "${RUM_IDENTITY_POOL_ID}")"
          RUM_GUEST_ROLE_ARN_ESCAPED="$(escape_sed_replacement "${RUM_GUEST_ROLE_ARN}")"
          AWS_REGION_ESCAPED="$(escape_sed_replacement "${AWS_REGION}")"

          find web/public -type f -name '*.html' -print0 |
          while IFS= read -r -d '' html_file; do
            echo "Processing ${html_file}"
            sed -i \
              -e "s|\${RUM_APP_MONITOR_ID}|${RUM_APP_MONITOR_ID_ESCAPED}|gI" \
              -e "s|\${RUM_IDENTITY_POOL_ID}|${RUM_IDENTITY_POOL_ID_ESCAPED}|gI" \
              -e "s|\${RUM_GUEST_ROLE_ARN}|${RUM_GUEST_ROLE_ARN_ESCAPED}|gI" \
              -e "s|\${AWS_REGION}|${AWS_REGION_ESCAPED}|gI" \
              "${html_file}"
          done
          echo 'RUM placeholder injection complete'

      - name: Generate submit.env
        shell: bash
        run: |
          set -euo pipefail
          npx dotenv -e .env.${{ needs.names.outputs.environment-name }} -- bash -c 'cat > web/public/submit.env <<EOF
          COGNITO_CLIENT_ID=${COGNITO_CLIENT_ID}
          COGNITO_BASE_URI=https://${{ needs.names.outputs.environment-name }}-auth.diyaccounting.co.uk

          HMRC_CLIENT_ID=${HMRC_CLIENT_ID}
          HMRC_BASE_URI=${HMRC_BASE_URI}

          HMRC_SANDBOX_CLIENT_ID=${HMRC_SANDBOX_CLIENT_ID}
          HMRC_SANDBOX_BASE_URI=${HMRC_SANDBOX_BASE_URI}

          DIY_SUBMIT_BASE_URL=${DIY_SUBMIT_BASE_URL}
          EOF'

      - name: Generate metadata files
        shell: bash
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo -n "${VERSION}" > web/public/submit.version.txt
          echo -n "${{ github.sha }}" > web/public/submit.commit-hash.txt
          echo -n "${{ needs.names.outputs.deployment-name }}" > web/public/submit.deployment-name.txt
          echo -n "${{ needs.names.outputs.environment-name }}" > web/public/submit.environment-name.txt

      - name: Sync to S3
        shell: bash
        run: |
          BUCKET_NAME="${{ needs.names.outputs.deployment-name }}-app-origin-us-east-1"
          # Replace dots with dashes (matching SubmitSharedNames.java convertDotSeparatedToDashSeparated)
          BUCKET_NAME="${BUCKET_NAME//./-}"
          echo "Syncing web/public/ to s3://${BUCKET_NAME}/"
          aws s3 sync web/public/ "s3://${BUCKET_NAME}/" --region us-east-1

      - name: Invalidate CloudFront
        shell: bash
        run: |
          set -euo pipefail
          ORIGIN_DOMAIN="${{ needs.names.outputs.deployment-name }}.submit.diyaccounting.co.uk"
          echo "Looking up CloudFront distribution with OriginFor tag: ${ORIGIN_DOMAIN}"

          CLOUDFRONT_DISTRIBUTION_ARN=$(aws resourcegroupstaggingapi get-resources \
            --resource-type-filters cloudfront:distribution \
            --region us-east-1 \
            --tag-filters "Key=OriginFor,Values=${ORIGIN_DOMAIN}" \
            --query 'ResourceTagMappingList[0].ResourceARN' \
            --output text 2>/dev/null || echo "")

          if [ -z "$CLOUDFRONT_DISTRIBUTION_ARN" ] || [ "$CLOUDFRONT_DISTRIBUTION_ARN" = "None" ]; then
            echo "ERROR: No CloudFront distribution found with OriginFor tag ${ORIGIN_DOMAIN}" >&2
            exit 1
          fi
          DISTRIBUTION_ID="${CLOUDFRONT_DISTRIBUTION_ARN##*/}"
          echo "Found CloudFront Distribution ID: ${DISTRIBUTION_ID}"

          echo "Creating invalidation..."
          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id "${DISTRIBUTION_ID}" \
            --paths \
              "/activities/*" "/auth/*" "/docs/*" "/errors/*" "/hmrc/*" \
              "/images/*" "/lib/*" "/prefetch/*" "/tests/*" "/widgets/*" \
              "/about.html" "/accessibility.html" "/bundles.html" "/faqs.toml" \
              "/guide.html" "/help.html" "/mcp.html" \
              "/diy-accounting-spreadsheets.html" "/diy-accounting-limited.html" "/spreadsheets.html" \
              "/android-chrome-192.png" "/android-chrome-512.png" "/apple-touch-icon.png" \
              "/favicon.ico" "/favicon.svg" "/favicon-16.png" "/favicon-32.png" \
              "/index.html" "/privacy.html" \
              "/submit.catalogue.toml" "/submit.build-number.txt" "/submit.commit-hash.txt" \
              "/submit.css" "/submit.deployment-name.txt" "/submit.env" \
              "/submit.environment-name.txt" "/submit.js" "/submit.version.txt" \
              "/terms.html" "/site.webmanifest" "/simulator.html" "/developer-mode.js" \
            --region us-east-1 \
            --query 'Invalidation.Id' --output text)
          echo "Invalidation created: ${INVALIDATION_ID}"

          echo "Waiting for invalidation to complete..."
          aws cloudfront wait invalidation-completed \
            --distribution-id "${DISTRIBUTION_ID}" \
            --id "${INVALIDATION_ID}" \
            --region us-east-1
          echo "CloudFront invalidation complete."

  behaviour-tests:
    name: 'behaviour tests submitVatBehaviour-${{ needs.names.outputs.environment-name }}'
    if: ${{ needs.params.outputs.skip-tests != 'true' && !cancelled() && !failure() }}
    needs:
      - params
      - names
      - update-lambdas
      - sync-web-assets
    runs-on: ubuntu-24.04
    container: mcr.microsoft.com/playwright:v1.58.1-jammy
    environment: ${{ github.ref == 'refs/heads/main' && 'prod' || 'ci' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --ignore-scripts
        env:
          PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: 1

      - name: Configure AWS role via GitHub OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ env.ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Assume AWS deployment role
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ env.DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Enable native auth on Cognito Hosted UI
        shell: bash
        run: |
          ENV_FILE=".env.${{ needs.names.outputs.environment-name }}"
          PROVIDER=$(grep -E '^TEST_AUTH_PROVIDER=' "$ENV_FILE" | tail -n1 | cut -d'=' -f2)
          if [ "$PROVIDER" = "cognito-native" ]; then
            node scripts/toggle-cognito-native-auth.js enable "${{ needs.names.outputs.environment-name }}"
          else
            echo "Skipping native auth toggle (TEST_AUTH_PROVIDER=${PROVIDER:-unset})"
          fi

      - name: Create Cognito test user
        id: cognito-test-user
        shell: bash
        run: |
          ENV_FILE=".env.${{ needs.names.outputs.environment-name }}"
          PROVIDER=$(grep -E '^TEST_AUTH_PROVIDER=' "$ENV_FILE" | tail -n1 | cut -d'=' -f2)
          if [ "$PROVIDER" = "cognito-native" ]; then
            node 'scripts/create-cognito-test-user.js' "${{ needs.names.outputs.environment-name }}"
            echo "user-created-here=true" >> "$GITHUB_OUTPUT"
          else
            echo "Skipping Cognito test user creation (TEST_AUTH_PROVIDER=${PROVIDER:-unset})"
            echo "user-created-here=false" >> "$GITHUB_OUTPUT"
          fi

      - name: 'Run submitVatBehaviour-${{ needs.names.outputs.environment-name }}'
        id: behaviour-test
        if: ${{ !cancelled() }}
        run: |
          npm run 'test:submitVatBehaviour-${{ needs.names.outputs.environment-name }}' || exit_code=$? \
          ; RESULT=${exit_code:-0} \
          ; echo "RESULT=$RESULT" | tee -a "$GITHUB_OUTPUT" \
          ; cp ./target/submit*.log ./target/behaviour-test-results/ || true \
          ; exit ${exit_code:-0} \
          ;
        env:
          DIY_SUBMIT_BASE_URL: ${{ needs.names.outputs.public-url }}
          HMRC_ACCOUNT: sandbox
          HMRC_SANDBOX_CLIENT_SECRET: ${{ secrets.HMRC_SANDBOX_CLIENT_SECRET }}
          TEST_AUTH_USERNAME: ${{ steps.cognito-test-user.outputs.test-auth-username }}
          TEST_AUTH_PASSWORD: ${{ steps.cognito-test-user.outputs.test-auth-password }}

      - name: Configure AWS role via GitHub OIDC (cleanup)
        if: ${{ !cancelled() }}
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ env.ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Assume AWS deployment role (cleanup)
        if: ${{ !cancelled() }}
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ env.DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Delete Cognito test user
        if: ${{ !cancelled() && needs.params.outputs.skip-cleanup != 'true' && steps.cognito-test-user.outputs.user-created-here == 'true' }}
        shell: bash
        run: |
          echo "Deleting test user created by this workflow..."
          node scripts/delete-cognito-test-user.js "${{ needs.names.outputs.environment-name }}" "${{ steps.cognito-test-user.outputs.test-auth-username }}"

      - name: Disable native auth on Cognito Hosted UI
        if: ${{ !cancelled() && needs.params.outputs.skip-cleanup != 'true' }}
        shell: bash
        run: |
          ENV_FILE=".env.${{ needs.names.outputs.environment-name }}"
          PROVIDER=$(grep -E '^TEST_AUTH_PROVIDER=' "$ENV_FILE" | tail -n1 | cut -d'=' -f2)
          if [ "$PROVIDER" = "cognito-native" ]; then
            node scripts/toggle-cognito-native-auth.js disable "${{ needs.names.outputs.environment-name }}"
          else
            echo "Skipping native auth toggle (TEST_AUTH_PROVIDER=${PROVIDER:-unset})"
          fi

      - name: Upload test artifacts
        if: ${{ !cancelled() }}
        uses: actions/upload-artifact@v6
        with:
          name: submitVatBehaviour-artifacts
          retention-days: 7
          path: |
            target/behaviour-test-results/
