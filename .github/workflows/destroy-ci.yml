name: destroy-ci
run-name: "destroy ci from ${{ github.ref_name }}"
concurrency:
  group: destroy-ci-${{ github.ref_name }}
  cancel-in-progress: false

on:
  workflow_dispatch:
    inputs:
      deployment-name:
        type: string
        description: 'Deployment name to destroy, e.g. ci-lambdas6'
        required: false
        default: ''
      sweep-for-stacks:
        type: boolean
        description: 'Whether to sweep for leftover stacks (true) or select by deployment name (false)'
        required: false
  workflow_call:
    inputs:
      deployment-name:
        type: string
        description: 'Deployment name to destroy, e.g. ci-lambdas6'
        required: false
        default: ''
      sweep-for-stacks:
        type: boolean
        description: 'Whether to sweep for leftover stacks (true) or select by deployment name (false)'
        required: false
        default: false
  schedule:
    - cron: '34 2,4,6,8,10,12 * * *'

permissions:
  id-token: write
  contents: read

env:
  JAVA_VERSION: '25'
  NODE_VERSION: '24'
  AWS_REGION: 'eu-west-2'
  BASE_IMAGE_TAG_PREFIX: 'submit-base'
  GITHUB_ACTOR: ${{ github.actor }}
  SELF_DESTRUCT_DELAY_HOURS: '8'
  BASE_IMAGE_TAG: ${{ github.sha }}
  FORCE_ALL_STACK_DEPLOYMENT: 'false'
  COMMIT_HASH: ${{ github.sha }}
  BUILD_NUMBER: ${{ github.run_number }}

jobs:

  params:
    runs-on: ubuntu-24.04
    steps:
      - name: "github.event_name=[${{ github.event_name }}]"
        run: ":"
      - name: "github.ref=[${{ github.ref }}]"
        run: ":"
      - name: "inputs.deployment-name=[${{ inputs.deployment-name }}]"
        run: ":"
      - name: "inputs.sweep-for-stacks=[${{ inputs.sweep-for-stacks }}]"
        run: ":"
      - name: Normalise Params
        id: normalise
        shell: bash
        run: |
          echo 'deployment-name=${{ inputs.deployment-name }}' | tee -a "$GITHUB_OUTPUT"
          X='${{ inputs.sweep-for-stacks }}' ; echo "sweep-for-stacks=${X:-false}" | tee -a "$GITHUB_OUTPUT"
          # Compute isSweeping: true if sweep-for-stacks=true OR schedule trigger
          SWEEP_FOR_STACKS='${{ inputs.sweep-for-stacks }}'
          EVENT_NAME='${{ github.event_name }}'
          if [ "${SWEEP_FOR_STACKS:-false}" = "true" ]; then
            echo "isSweeping=true" | tee -a "$GITHUB_OUTPUT"
          elif [ "$EVENT_NAME" = "schedule" ]; then
            echo "isSweeping=true" | tee -a "$GITHUB_OUTPUT"
          else
            echo "isSweeping=false" | tee -a "$GITHUB_OUTPUT"
          fi
    outputs:
      deployment-name: ${{ steps.normalise.outputs.deployment-name }}
      sweep-for-stacks: ${{ steps.normalise.outputs.sweep-for-stacks }}
      isSweeping: ${{ steps.normalise.outputs.isSweeping }}

  sweep-for-stacks:
    needs:
      - params
    if: ${{ needs.params.outputs.isSweeping == 'true' }}
    name: 'sweep for ci stacks'
    runs-on: ubuntu-24.04
    environment: ci
    steps:

      - name: Configure AWS role via GitHub OIDC
        uses: aws-actions/configure-aws-credentials@v6
        with:
          role-to-assume: ${{ vars.SUBMIT_ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Assume AWS deployment role
        uses: aws-actions/configure-aws-credentials@v6
        with:
          role-to-assume: ${{ vars.SUBMIT_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: CDK stacks in eu-west-2 and us-east-1
        run: |
          aws cloudformation describe-stacks --region eu-west-2 --query "Stacks[].StackName" --output text | tr '\t' '\n' | sort
          aws cloudformation describe-stacks --region us-east-1 --query "Stacks[].StackName" --output text | tr '\t' '\n' | sort

      - name: Get last known good ci deployment name
        id: last-known-good-deployment-names
        run: |
          PARAMETER_NAME="/submit/ci/last-known-good-deployment"
          echo "Getting SSM Parameter Store parameter $PARAMETER_NAME"
          LAST_KNOWN_GOOD=$(aws ssm get-parameter \
            --name "$PARAMETER_NAME" \
            --query "Parameter.Value" \
            --output text 2>/dev/null || echo "")
          echo "Last known good ci deployment: $LAST_KNOWN_GOOD"
          echo "last-known-good-deployment-name=$LAST_KNOWN_GOOD" >> $GITHUB_OUTPUT

      # Get the record names of aliases in any cloudfront distributions that match the ci- pattern
      - name: Get the published record names
        id: published-deployment-names
        run: |
          echo "Getting CloudFront distributions"
          DISTRIBUTION_IDS=$(aws cloudfront list-distributions --query "DistributionList.Items[].Id" --output text)
          PUBLISHED_DEPLOYMENT_NAMES=""
          echo "Found CloudFront Distribution IDs: $DISTRIBUTION_IDS"
          for DISTRIBUTION_ID in $DISTRIBUTION_IDS; do
            ALIASES=$(aws cloudfront get-distribution --id "$DISTRIBUTION_ID" --query "Distribution.DistributionConfig.Aliases.Items[]" --output text)
            echo "Found aliases for Distribution ID $DISTRIBUTION_ID: $ALIASES"
            for ALIAS in $ALIASES; do
              RECORD_NAME=$(echo "$ALIAS" | cut -d'.' -f1)
              if [[ "$RECORD_NAME" =~ ^ci-.* ]]; then
                PUBLISHED_DEPLOYMENT_NAMES="$PUBLISHED_DEPLOYMENT_NAMES $RECORD_NAME"
              fi
            done
          done

          echo "Collected published deployment names before deduplication: $PUBLISHED_DEPLOYMENT_NAMES"
          PUBLISHED_DEPLOYMENT_NAMES=$(echo $PUBLISHED_DEPLOYMENT_NAMES | tr ' ' '\n' | sort -u | tr '\n' ' ')

          echo "Published deployment names: $PUBLISHED_DEPLOYMENT_NAMES"
          echo "published-deployment-names=$PUBLISHED_DEPLOYMENT_NAMES" >> $GITHUB_OUTPUT

      # Get ci-prefixed deployment stack names from CloudFormation
      - name: Get the deployed deployment names
        id: deployed-deployment-names
        run: |
          echo 'Getting deployed ci deployment names from CloudFormation stacks in eu-west-2 and us-east-1'

          DEPLOYED_DEPLOYMENT_NAMES=$(
            for REGION in eu-west-2 us-east-1; do
              echo "Scanning region: $REGION" >&2
              aws cloudformation describe-stacks \
                --region "$REGION" \
                --query 'Stacks[].StackName' \
                --output text
            done \
            | tr '\t' '\n' \
            | grep -E '^ci-[a-zA-Z0-9-]+-(app|del)-' \
            | sed -E 's/^(ci-[a-zA-Z0-9-]+)-(app|del)-.*/\1/' \
            | sort -u
          )

          echo "Collected deployed deployment names (newline separated):"
          printf '%s\n' $DEPLOYED_DEPLOYMENT_NAMES

          DEPLOYED_DEPLOYMENT_NAMES=$(echo "$DEPLOYED_DEPLOYMENT_NAMES" | tr '\n' ' ')

          echo "Deployed deployment names: $DEPLOYED_DEPLOYMENT_NAMES"
          echo "deployed-deployment-names=$DEPLOYED_DEPLOYMENT_NAMES" >> "$GITHUB_OUTPUT"

      # Route 53 is in the management account â€” switch credentials for the query
      - name: Configure management account role via GitHub OIDC (for Route 53)
        uses: aws-actions/configure-aws-credentials@v6
        with:
          role-to-assume: ${{ vars.ROOT_ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Assume management account deployment role (for Route 53)
        uses: aws-actions/configure-aws-credentials@v6
        with:
          role-to-assume: ${{ vars.ROOT_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      # Get the deployment name that ci.submit.diyaccounting.co.uk aliases to in Route 53
      - name: Get the public record names
        id: public-deployment-names
        run: |
          echo 'Getting Route 53 hosted zone for diyaccounting.co.uk.'
          ROOT_ZONE='diyaccounting.co.uk.'
          PRIMARY_NAME='ci.submit.diyaccounting.co.uk.'
          PUBLIC_DEPLOYMENT_NAMES=''

          ZONE_ID=$(aws route53 list-hosted-zones-by-name \
            --dns-name "$ROOT_ZONE" \
            --query 'HostedZones[0].Id' \
            --output text 2>/dev/null | sed 's|/hostedzone/||')

          if [ -z "$ZONE_ID" ] || [ "$ZONE_ID" = 'None' ]; then
            echo "No hosted zone found for $ROOT_ZONE"
            exit 1
          fi

          echo "Using hosted zone $ROOT_ZONE ($ZONE_ID)"
          echo "Looking up alias target for $PRIMARY_NAME"

          ALIAS_TARGETS=$(aws route53 list-resource-record-sets \
            --hosted-zone-id "$ZONE_ID" \
            --query "ResourceRecordSets[?Name==\`$PRIMARY_NAME\` && Type==\`A\`].AliasTarget.DNSName" \
            --output text)

          if [ -z "$ALIAS_TARGETS" ] || [ "$ALIAS_TARGETS" = 'None' ]; then
            echo "No alias A record found for $PRIMARY_NAME"
          else
            echo "Alias targets for $PRIMARY_NAME: $ALIAS_TARGETS"
            for TARGET in $ALIAS_TARGETS; do
              TARGET_STRIPPED=${TARGET%.}
              HOST_LABEL=${TARGET_STRIPPED%%.*}
              if [[ "$HOST_LABEL" =~ ^ci-.* ]]; then
                echo "Found public deployment from $PRIMARY_NAME -> $HOST_LABEL"
                PUBLIC_DEPLOYMENT_NAMES="$PUBLIC_DEPLOYMENT_NAMES $HOST_LABEL"
              else
                echo "Alias target $TARGET_STRIPPED does not look like ci-*, skipping"
              fi
            done
          fi

          echo "Collected public deployment names before deduplication: $PUBLIC_DEPLOYMENT_NAMES"
          PUBLIC_DEPLOYMENT_NAMES=$(echo "$PUBLIC_DEPLOYMENT_NAMES" \
            | tr ' ' '\n' \
            | sort -u \
            | tr '\n' ' ')

          echo "Public deployment names: $PUBLIC_DEPLOYMENT_NAMES"
          echo "public-deployment-names=$PUBLIC_DEPLOYMENT_NAMES" >> "$GITHUB_OUTPUT"

      # Switch back to submit-ci account for remaining steps
      - name: Restore submit-ci AWS role via GitHub OIDC
        uses: aws-actions/configure-aws-credentials@v6
        with:
          role-to-assume: ${{ vars.SUBMIT_ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Restore submit-ci AWS deployment role
        uses: aws-actions/configure-aws-credentials@v6
        with:
          role-to-assume: ${{ vars.SUBMIT_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      # Select ci deployment names of stacks to destroy, excluding public/last-known-good
      - name: Select deployment names for destruction
        id: select-stack
        run: |
          LAST_KNOWN_GOOD_DEPLOYMENT_NAME="${{ steps.last-known-good-deployment-names.outputs.last-known-good-deployment-name }}"
          PUBLIC_DEPLOYMENT_NAMES="${{ steps.public-deployment-names.outputs.public-deployment-names }}"
          PUBLISHED_DEPLOYMENT_NAMES="${{ steps.published-deployment-names.outputs.published-deployment-names }}"
          DEPLOYED_DEPLOYMENT_NAMES="${{ steps.deployed-deployment-names.outputs.deployed-deployment-names }}"
          SELF_DESTRUCT_DELAY_HOURS="${{ env.SELF_DESTRUCT_DELAY_HOURS }}"

          echo "Last known good deployment name: '$LAST_KNOWN_GOOD_DEPLOYMENT_NAME'"
          echo "Public deployment names: $PUBLIC_DEPLOYMENT_NAMES"
          echo "Published deployment names: $PUBLISHED_DEPLOYMENT_NAMES"
          echo "Deployed deployment names: $DEPLOYED_DEPLOYMENT_NAMES"
          echo "Self-destruct delay hours: $SELF_DESTRUCT_DELAY_HOURS"

          # Function to get the most recent creation time for a deployment's stacks
          get_deployment_age_hours() {
            local deployment_name="$1"
            local most_recent_timestamp=0

            echo "Checking age of deployment: $deployment_name" >&2

            if ! [[ "$deployment_name" =~ ^ci-[a-zA-Z0-9-]+$ ]]; then
              echo "Invalid deployment name format: $deployment_name" >&2
              echo "-1"
              return
            fi

            for REGION in eu-west-2 us-east-1; do
              local stack_info=$(aws cloudformation describe-stacks \
                --region "$REGION" \
                --query "Stacks[?starts_with(StackName, '${deployment_name}-')].CreationTime" \
                --output text 2>/dev/null | tr '\t' '\n' || echo "")

              if [ -n "$stack_info" ]; then
                echo "Found stacks in $REGION for $deployment_name" >&2

                while IFS= read -r creation_time; do
                  [ -z "$creation_time" ] && continue
                  local epoch=$(date -d "$creation_time" +%s 2>/dev/null)
                  if [ -z "$epoch" ]; then
                    echo "Failed to parse creation time: $creation_time" >&2
                    continue
                  fi
                  if ! [[ "$epoch" =~ ^[0-9]+$ ]] || [ "$epoch" -le 0 ]; then
                    echo "Invalid epoch value: $epoch for creation time: $creation_time" >&2
                    continue
                  fi
                  if [ "$epoch" -gt "$most_recent_timestamp" ]; then
                    most_recent_timestamp="$epoch"
                  fi
                done <<< "$stack_info"
              fi
            done

            if [ "$most_recent_timestamp" -eq 0 ]; then
              echo "No valid stacks found for deployment $deployment_name" >&2
              echo "-1"
              return
            fi

            local current_timestamp=$(date +%s)
            local age_seconds=$((current_timestamp - most_recent_timestamp))
            local age_hours=$((age_seconds / 3600))

            echo "Deployment $deployment_name age: $age_hours hours (most recent stack created at $(date -d "@$most_recent_timestamp" -Iseconds))" >&2
            echo "$age_hours"
          }

          STACK_DEPLOYMENT_NAMES_TO_KEEP=()

          # Keep deployments that are currently aliased from the primary plus last-known-good
          for DEPLOYMENT_NAME in $(echo "$PUBLIC_DEPLOYMENT_NAMES $LAST_KNOWN_GOOD_DEPLOYMENT_NAME" | tr ' ' '\n'); do
            if [ -n "$DEPLOYMENT_NAME" ]; then
              STACK_DEPLOYMENT_NAMES_TO_KEEP+=("$DEPLOYMENT_NAME")
            fi
          done

          # Keep sibling site deployments (gateway, spreadsheets) and holding pages
          for DEPLOYMENT_NAME in $PUBLISHED_DEPLOYMENT_NAMES; do
            if [[ "$DEPLOYMENT_NAME" == *-holding ]] || \
               [[ "$DEPLOYMENT_NAME" == *-gateway ]] || \
               [[ "$DEPLOYMENT_NAME" == *-spreadsheets ]]; then
              STACK_DEPLOYMENT_NAMES_TO_KEEP+=("$DEPLOYMENT_NAME")
            fi
          done

          # Remove duplicates
          echo "Removing duplicates from stacks to keep from: ${STACK_DEPLOYMENT_NAMES_TO_KEEP[*]}"
          STACK_DEPLOYMENT_NAMES_TO_KEEP=($(echo "${STACK_DEPLOYMENT_NAMES_TO_KEEP[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' '))

          echo "Stacks to skip destruction: ${STACK_DEPLOYMENT_NAMES_TO_KEEP[*]}"

          ALL_CANDIDATE_DEPLOYMENT_NAMES="$PUBLISHED_DEPLOYMENT_NAMES $DEPLOYED_DEPLOYMENT_NAMES"
          ALL_CANDIDATE_DEPLOYMENT_NAMES=$(echo "$ALL_CANDIDATE_DEPLOYMENT_NAMES" | tr ' ' '\n' | sort -u | tr '\n' ' ')

          SELECTED_DEPLOYMENT_NAME=""

          for DEPLOYMENT_NAME in $ALL_CANDIDATE_DEPLOYMENT_NAMES; do
            [ -z "$DEPLOYMENT_NAME" ] && continue

            echo "Considering deployment name: $DEPLOYMENT_NAME"

            # Only consider ci-prefixed deployments
            if [[ "$DEPLOYMENT_NAME" != ci-* ]]; then
              echo "Skipping $DEPLOYMENT_NAME (not a ci deployment)"
              continue
            fi

            if [[ " ${STACK_DEPLOYMENT_NAMES_TO_KEEP[*]} " =~ " ${DEPLOYMENT_NAME} " ]]; then
              echo "Skipping $DEPLOYMENT_NAME as it is in the keep list"
              continue
            fi

            DEPLOYMENT_AGE_HOURS=$(get_deployment_age_hours "$DEPLOYMENT_NAME")

            if [ "$DEPLOYMENT_AGE_HOURS" -eq -1 ]; then
              echo "Could not determine age for $DEPLOYMENT_NAME, skipping"
              continue
            fi

            if [ "$DEPLOYMENT_AGE_HOURS" -lt "$SELF_DESTRUCT_DELAY_HOURS" ]; then
              echo "Skipping $DEPLOYMENT_NAME as it is only $DEPLOYMENT_AGE_HOURS hours old (minimum age: $SELF_DESTRUCT_DELAY_HOURS hours)"
              continue
            fi

            echo "Deployment $DEPLOYMENT_NAME is $DEPLOYMENT_AGE_HOURS hours old (>= $SELF_DESTRUCT_DELAY_HOURS hours), eligible for destruction"

            SELECTED_DEPLOYMENT_NAME="$DEPLOYMENT_NAME"
            echo "Selected deployment for destruction: Environment='ci', Deployment='$SELECTED_DEPLOYMENT_NAME'"
            break
          done

          if [ -z "$SELECTED_DEPLOYMENT_NAME" ]; then
            echo "No ci stacks found for destruction"
            SWEEPER_HIT="false"
          else
            echo "Stacks found for destruction ci/${SELECTED_DEPLOYMENT_NAME}"
            SWEEPER_HIT="true"
          fi

          echo "SWEEPER_HIT=$SWEEPER_HIT"
          echo "SELECTED_DEPLOYMENT_NAME=$SELECTED_DEPLOYMENT_NAME"
          echo "SWEEPER_HIT=$SWEEPER_HIT" >> $GITHUB_OUTPUT
          echo "SELECTED_DEPLOYMENT_NAME=$SELECTED_DEPLOYMENT_NAME" >> $GITHUB_OUTPUT

    outputs:
      sweeper-hit: ${{ steps.select-stack.outputs.SWEEPER_HIT }}
      deployment-name: ${{ steps.select-stack.outputs.SELECTED_DEPLOYMENT_NAME }}

  names:
    if: ${{ !cancelled() && needs.sweep-for-stacks.outputs.sweeper-hit != 'false' }}
    needs:
      - params
      - sweep-for-stacks
    runs-on: ubuntu-24.04
    environment: ci
    steps:
      - name: Checkout
        uses: actions/checkout@v6
      - name: Compute deployment name and environment
        id: deployment-config
        uses: ./.github/actions/get-names
        with:
          environment-name: ci
          deployment-name: ${{ needs.sweep-for-stacks.outputs.deployment-name || needs.params.outputs.deployment-name }}
    outputs:
      environment-name: ${{ steps.deployment-config.outputs.environment-name }}
      deployment-name: ${{ steps.deployment-config.outputs.deployment-name }}
      base-domain: ${{ steps.deployment-config.outputs.base-domain }}
      base-url: ${{ steps.deployment-config.outputs.base-url }}
      apex-domain: ${{ steps.deployment-config.outputs.apex-domain }}
      apex-url: ${{ steps.deployment-config.outputs.apex-url }}
      holding-domain: ${{ steps.deployment-config.outputs.holding-domain }}
      holding-url: ${{ steps.deployment-config.outputs.holding-url }}

  destroy:
    if: ${{ !cancelled() && needs.sweep-for-stacks.outputs.sweeper-hit != 'false' }}
    needs:
      - params
      - names
      - sweep-for-stacks
    runs-on: ubuntu-latest
    environment: ci
    steps:
      - name: Checkout default branch
        uses: actions/checkout@v6
        with:
          ref: ${{ github.event.repository.default_branch }} # e.g. main
          fetch-depth: 0

      - name: Report deleted ref
        run: |
          echo "Deleted: ${{ github.event.ref }}"
          echo "Ref type: ${{ github.event.ref_type }}"

      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - uses: actions/setup-java@v5
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}
          cache: 'maven'

      - name: Configure AWS role via GitHub OIDC
        uses: aws-actions/configure-aws-credentials@v6
        with:
          role-to-assume: ${{ vars.SUBMIT_ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Assume AWS deployment role
        uses: aws-actions/configure-aws-credentials@v6
        with:
          role-to-assume: ${{ vars.SUBMIT_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: CDK stacks before
        run: |
          aws cloudformation describe-stacks --region eu-west-2 --query "Stacks[].StackName" --output text | tr '\t' '\n' | sort
          aws cloudformation describe-stacks --region us-east-1 --query "Stacks[].StackName" --output text | tr '\t' '\n' | sort

      - name: Node dependencies
        run: npm ci

      - name: Build CDK
        run: ./mvnw --errors clean verify -DskipTests

      - name: Lookup Cognito from domain convention
        id: lookup
        uses: './.github/actions/lookup-resources'
        with:
          environment-name: ${{ needs.names.outputs.environment-name }}
          lookup-cognito: 'true'

      - name: Empty origin bucket
        shell: bash
        run: |
          EDGE_STACK="${{ needs.names.outputs.deployment-name }}-app-EdgeStack"
          BUCKET_NAME=$(aws cloudformation describe-stacks \
            --stack-name "${EDGE_STACK}" --region us-east-1 \
            --query 'Stacks[0].Outputs[?OutputKey==`OriginBucketName`].OutputValue' \
            --output text 2>/dev/null || echo "")
          if [ -z "$BUCKET_NAME" ] || [ "$BUCKET_NAME" = "None" ]; then
            echo "EdgeStack not found or no OriginBucketName output, skipping"
          else
            echo "Emptying origin bucket: ${BUCKET_NAME}"
            aws s3 rm "s3://${BUCKET_NAME}" --recursive \
              || echo "Origin bucket already empty or does not exist"
          fi

      - name: Clean up external API Gateway custom domain mappings
        shell: bash
        run: |
          set +e  # Best-effort cleanup
          API_STACK_NAME="${{ needs.names.outputs.deployment-name }}-app-ApiStack"
          API_ID=$(aws cloudformation describe-stacks \
            --stack-name "${API_STACK_NAME}" --region eu-west-2 \
            --query "Stacks[0].Outputs[?OutputKey=='HttpApiId'].OutputValue | [0]" \
            --output text 2>/dev/null || echo "")
          if [ -z "$API_ID" ] || [ "$API_ID" = "None" ]; then
            echo "No API ID found for stack ${API_STACK_NAME}, skipping"
            exit 0
          fi
          echo "Found API ID: $API_ID, scanning for external domain mappings"
          DOMAINS=$(aws apigatewayv2 get-domain-names --region eu-west-2 \
            --query 'Items[].DomainName' --output text 2>/dev/null || echo "")
          for DOMAIN in $DOMAINS; do
            [ -z "$DOMAIN" ] || [ "$DOMAIN" = "None" ] && continue
            MAPPINGS=$(aws apigatewayv2 get-api-mappings --domain-name "$DOMAIN" --region eu-west-2 \
              --query "Items[?ApiId=='${API_ID}'].[ApiMappingId]" --output text 2>/dev/null || echo "")
            ALL_COUNT=$(aws apigatewayv2 get-api-mappings --domain-name "$DOMAIN" --region eu-west-2 \
              --query 'length(Items)' --output text 2>/dev/null || echo "0")
            OUR_COUNT=0
            for MID in $MAPPINGS; do
              [ -z "$MID" ] || [ "$MID" = "None" ] && continue
              echo "Deleting mapping $MID from domain $DOMAIN"
              aws apigatewayv2 delete-api-mapping --domain-name "$DOMAIN" --api-mapping-id "$MID" --region eu-west-2 2>/dev/null || true
              OUR_COUNT=$((OUR_COUNT + 1))
            done
            if [ "$OUR_COUNT" -gt 0 ] && [ "$OUR_COUNT" -eq "$ALL_COUNT" ]; then
              echo "Deleting domain $DOMAIN (all mappings were ours)"
              aws apigatewayv2 delete-domain-name --domain-name "$DOMAIN" --region eu-west-2 2>/dev/null || true
            fi
          done
          echo "API Gateway custom domain mapping cleanup complete"

      - name: Delete stacks in dependency order
        shell: bash
        run: |
          DEPLOYMENT="${{ needs.names.outputs.deployment-name }}"

          delete_stack_in_region() {
            local STACK="$1" REGION="$2"
            local STATUS
            STATUS=$(aws cloudformation describe-stacks --stack-name "$STACK" --region "$REGION" \
              --query "Stacks[0].StackStatus" --output text 2>/dev/null || echo "DOES_NOT_EXIST")
            if [ "$STATUS" = "DOES_NOT_EXIST" ]; then
              echo "  $STACK does not exist in $REGION, skipping"
              return 0
            fi
            echo "  Deleting $STACK in $REGION (status: $STATUS)..."
            aws cloudformation delete-stack --stack-name "$STACK" --region "$REGION" 2>/dev/null || true
            aws cloudformation wait stack-delete-complete --stack-name "$STACK" --region "$REGION" 2>/dev/null || true
            # Check for DELETE_FAILED and force delete
            STATUS=$(aws cloudformation describe-stacks --stack-name "$STACK" --region "$REGION" \
              --query "Stacks[0].StackStatus" --output text 2>/dev/null || echo "DOES_NOT_EXIST")
            if [ "$STATUS" = "DELETE_FAILED" ]; then
              echo "  $STACK is DELETE_FAILED, force deleting"
              aws cloudformation delete-stack --stack-name "$STACK" --region "$REGION" \
                --deletion-mode FORCE_DELETE_STACK || true
              aws cloudformation wait stack-delete-complete --stack-name "$STACK" --region "$REGION" 2>/dev/null || true
            fi
          }

          # Delete in reverse dependency order (leaf stacks first)
          echo "=== Phase 1: SelfDestruct + Ops + Publish (no dependents) ==="
          delete_stack_in_region "${DEPLOYMENT}-app-SelfDestructStack" eu-west-2
          delete_stack_in_region "${DEPLOYMENT}-app-OpsStack" eu-west-2
          delete_stack_in_region "${DEPLOYMENT}-app-PublishStack" us-east-1

          echo "=== Phase 2: EdgeStack (depends on ApiStack outputs) ==="
          delete_stack_in_region "${DEPLOYMENT}-app-EdgeStack" us-east-1

          echo "=== Phase 3: ApiStack (depends on Lambda stacks) ==="
          delete_stack_in_region "${DEPLOYMENT}-app-ApiStack" eu-west-2

          echo "=== Phase 4: Lambda stacks (no cross-dependencies) ==="
          delete_stack_in_region "${DEPLOYMENT}-app-AuthStack" eu-west-2
          delete_stack_in_region "${DEPLOYMENT}-app-HmrcStack" eu-west-2
          delete_stack_in_region "${DEPLOYMENT}-app-AccountStack" eu-west-2
          delete_stack_in_region "${DEPLOYMENT}-app-BillingStack" eu-west-2

          echo "=== Stack deletion complete ==="

      - name: CDK destroy (cleanup pass)
        if: ${{ !cancelled() }}
        run: |
          cd cdk-application && \
            npx dotenv -e ../.env.ci -- \
              npx cdk destroy \
              --all \
              --force \
              --no-notices \
          && cd .. \
          || echo "CDK destroy cleanup pass completed (some stacks may already be deleted)"
        env:
          ENVIRONMENT_NAME: ci
          DEPLOYMENT_NAME: ${{ needs.names.outputs.deployment-name }}
          BASE_IMAGE_TAG: "${{ env.BASE_IMAGE_TAG }}:latest"
          COGNITO_USER_POOL_ARN: ${{ steps.lookup.outputs.cognito-user-pool-arn }}
          COGNITO_CLIENT_ID: ${{ steps.lookup.outputs.cognito-client-id }}
          WEBSITE_HASH: 'placeholder'
          HTTP_API_URL: 'https://placeholder'

      - name: Retry DELETE_FAILED stacks
        if: ${{ !cancelled() }}
        shell: bash
        run: |
          DEPLOYMENT="${{ needs.names.outputs.deployment-name }}"
          FAILED_STACKS=$(aws cloudformation list-stacks --region eu-west-2 \
            --stack-status-filter DELETE_FAILED \
            --query "StackSummaries[?starts_with(StackName, '${DEPLOYMENT}')].StackName" \
            --output text 2>/dev/null || echo "")
          for STACK in $FAILED_STACKS; do
            [ -z "$STACK" ] || [ "$STACK" = "None" ] && continue
            echo "Stack $STACK is DELETE_FAILED, retrying with --retain-resources"
            FAILED_RESOURCES=$(aws cloudformation list-stack-resources --stack-name "$STACK" --region eu-west-2 \
              --query "StackResourceSummaries[?ResourceStatus=='DELETE_FAILED'].LogicalResourceId" \
              --output text 2>/dev/null || echo "")
            if [ -n "$FAILED_RESOURCES" ] && [ "$FAILED_RESOURCES" != "None" ]; then
              echo "Retaining: $FAILED_RESOURCES"
              aws cloudformation delete-stack --stack-name "$STACK" --region eu-west-2 \
                --retain-resources $FAILED_RESOURCES || true
            else
              echo "No failed resources found, retrying plain delete"
              aws cloudformation delete-stack --stack-name "$STACK" --region eu-west-2 || true
            fi
            echo "Waiting for $STACK deletion..."
            aws cloudformation wait stack-delete-complete --stack-name "$STACK" --region eu-west-2 2>/dev/null || true
          done

      - name: CDK stacks after
        if: ${{ !cancelled() }}
        run: |
          aws cloudformation describe-stacks --region eu-west-2 --query "Stacks[].StackName" --output text | tr '\t' '\n' | sort
          aws cloudformation describe-stacks --region us-east-1 --query "Stacks[].StackName" --output text | tr '\t' '\n' | sort
