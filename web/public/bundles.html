<!-- bundles.html -->
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>DIY Accounting Submit - Bundles</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="/favicon.ico" sizes="any" />
    <link rel="icon" href="/favicon.svg" type="image/svg+xml" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="manifest" href="/site.webmanifest" />
    <link rel="stylesheet" href="submit.css" />
    <!-- CloudWatch RUM configuration placeholders; replace values during deployment -->
    <meta name="rum:appMonitorId" content="${RUM_APP_MONITOR_ID}" />
    <meta name="rum:region" content="${AWS_REGION}" />
    <meta name="rum:identityPoolId" content="${RUM_IDENTITY_POOL_ID}" />
    <meta name="rum:guestRoleArn" content="${RUM_GUEST_ROLE_ARN}" />
    <script src="./lib/analytics.js"></script>
    <script src="./lib/session-beacon.js"></script>
  </head>
  <body>
    <a href="#mainContent" class="skip-link">Skip to main content</a>
    <header>
      <div class="header-nav">
        <div class="header-left">
          <a href="index.html" title="Home" class="home-link">
            <svg class="home-icon" viewBox="0 0 24 24" aria-hidden="true">
              <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" />
            </svg>
          </a>
          <a href="about.html" title="About & Help" class="info-link">
            <svg class="info-icon" viewBox="0 0 24 24" aria-hidden="true">
              <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z" />
            </svg>
          </a>
        </div>
        <div class="auth-section">
          <span class="entitlement-status">Activity: unrestricted</span>
          <span class="login-status">Not logged in</span>
          <a href="auth/login.html" class="login-link">Log in</a>
        </div>
      </div>
      <h1>DIY Accounting Submit</h1>
      <p class="subtitle">Submit UK VAT returns to HMRC under Making Tax Digital (MTD)</p>
      <nav class="main-nav" aria-label="Main navigation">
        <a href="index.html">Activities</a>
        <a href="hmrc/receipt/receipts.html">Receipts</a>
        <a href="bundles.html" class="active">Bundles</a>
        <a href="spreadsheets.html">Spreadsheets</a>
      </nav>
    </header>

    <main id="mainContent">
      <div id="statusMessagesContainer" role="alert" aria-live="polite"></div>

      <div id="loadingSpinner" class="spinner" style="display: none"></div>

      <div class="form-container" style="text-align: center">
        <h2>Bundles</h2>

        <div class="bundles-list" id="catalogBundles"></div>

        <div style="margin-top: 3em; padding-top: 2em; border-top: 1px solid #ddd">
          <h3>Have a Pass?</h3>
          <p style="color: #666; font-size: 0.9em">Enter a four-word passphrase to redeem your invitation.</p>
          <div id="passEntryForm" style="margin: 1em auto; max-width: 440px; text-align: left">
            <label for="passInput" style="display: block; margin-bottom: 0.4em; font-weight: 600">Passphrase</label>
            <input
              type="text"
              id="passInput"
              placeholder="word-word-word-word"
              autocomplete="off"
              spellcheck="false"
              style="width: 100%; padding: 0.6em; font-size: 1em; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box"
            />
            <div style="margin-top: 0.75em; text-align: center">
              <button type="button" id="redeemPassBtn" class="btn" style="min-width: 160px">Redeem Pass</button>
            </div>
            <div
              id="passStatus"
              role="alert"
              aria-live="polite"
              style="margin-top: 0.75em; display: none; padding: 0.6em; border-radius: 4px; font-size: 0.9em"
            ></div>
          </div>
        </div>

        <div id="waitlistSection" style="display: none; margin-top: 3em; padding-top: 2em; border-top: 1px solid #ddd">
          <h3>Register for Early Access</h3>
          <p style="color: #666; font-size: 0.9em">
            We're getting ready to launch. Register for early access and we'll send you an invitation.
          </p>
          <div style="margin: 1em auto; text-align: center">
            <button type="button" id="waitlistJoinBtn" class="btn" style="min-width: 180px">Register for Early Access</button>
          </div>
        </div>

        <div style="margin-top: 3em; padding-top: 2em; border-top: 1px solid #ddd">
          <h3>Your Current Bundles</h3>
          <div id="currentBundles" style="margin: 1em 0"></div>
        </div>
      </div>
    </main>

    <footer>
      <div class="footer-content">
        <div class="footer-left">
          <a href="#" id="viewSourceLink" style="display: none">view source</a>
          <a id="latestTestsLink" style="display: inline" target="_blank" href="tests/index.html">tests</a>
          <a id="apiDocsLink" style="display: inline" target="_blank" href="docs/api/index.html"> api </a>
          <a href="privacy.html">privacy</a>
          <a href="terms.html">terms</a>
          <a href="accessibility.html">accessibility</a>
        </div>
        <div class="footer-center">
          <p>&copy; 2025-2026 DIY Accounting Limited</p>
        </div>
        <div class="footer-right" id="localstorageContainer"></div>
      </div>
    </footer>

    <script type="module" src="submit.js"></script>
    <script src="developer-mode.js"></script>
    <script src="lib/request-cache.js"></script>
    <script src="lib/bundle-cache.js"></script>
    <script src="lib/toml-parser.js"></script>
    <script src="lib/feature-flags.js"></script>
    <script src="widgets/entitlement-status.js"></script>
    <script src="widgets/auth-status.js"></script>
    <script src="widgets/status-messages.js"></script>
    <script src="widgets/loading-spinner.js"></script>
    <script type="module" src="widgets/view-source-link.js"></script>
    <script src="widgets/localstorage-viewer.js"></script>

    <script>
      // --- helpers
      const getIdToken = () => {
        try {
          return localStorage.getItem("cognitoIdToken");
        } catch (e) {
          // In opaque origins (e.g., setContent in tests), localStorage may be inaccessible
          return null;
        }
      };

      // Lightweight wrappers that use page-level cache when available, with safe fallbacks for tests
      const __rc = typeof window !== "undefined" && window.requestCache ? window.requestCache : null;
      const fetchAndParse = async (url, opts = {}) => {
        try {
          if (__rc && typeof __rc.getJSON === "function" && !url.endsWith(".toml")) return __rc.getJSON(url, opts);
        } catch {}
        // Fallback: Use fetchWithIdToken if authorization is needed
        const init = opts.init || {};
        const hasAuthHeader = init.headers && (init.headers.Authorization || init.headers.authorization);
        let res;
        if (hasAuthHeader && window.fetchWithIdToken) {
          res = await window.fetchWithIdToken(url, init);
        } else {
          res = await fetch(url, init);
        }

        try {
          if (url.endsWith(".toml")) {
            const text = await res.text();
            return window.TOML ? window.TOML.parse(text) : null;
          }
          return await res.json();
        } catch {
          return null;
        }
      };
      const invalidate = (prefix) => {
        try {
          if (__rc && typeof __rc.invalidate === "function") return __rc.invalidate(prefix);
        } catch {}
      };

      // In-memory bundles state for this page
      let __userBundles = [];
      let __fullBundleData = []; // Full bundle objects from API (with token info, allocated flag, etc.)
      let __fetchBundlesController = null;
      let __catalogueData = null; // Catalogue TOML data (stored for re-renders)
      let __currentEnv = null; // Current environment name

      const parseUserBundles = () => (Array.isArray(__userBundles) ? __userBundles : []);

      // Fetch bundles from API endpoint (single source of truth, with lightweight caching)
      const fetchUserBundles = async () => {
        const idToken = getIdToken();
        if (!idToken) {
          __userBundles = [];
          return __userBundles;
        }

        const userInfoJson = localStorage.getItem("userInfo");
        let userId = null;
        try {
          const userInfo = JSON.parse(userInfoJson);
          userId = userInfo && userInfo.sub;
        } catch {}

        if (userId) {
          const cached = await window.bundleCache.getBundles(userId);
          if (cached && Array.isArray(cached)) {
            __userBundles = cached;
            return __userBundles;
          }
        }

        // Abort previous fetch if any
        if (__fetchBundlesController) {
          __fetchBundlesController.abort();
        }
        __fetchBundlesController = new AbortController();
        const signal = __fetchBundlesController.signal;

        try {
          const bundlesData = await fetchAndParse("/api/v1/bundle", {
            ttlMs: 0,
            init: { headers: { Authorization: `Bearer ${idToken}` }, signal },
          });
          if (bundlesData && bundlesData.bundles && Array.isArray(bundlesData.bundles)) {
            __fullBundleData = bundlesData.bundles;
            __userBundles = bundlesData.bundles.filter((b) => b.allocated).map((b) => b.bundleId);
            if (userId) {
              await window.bundleCache.setBundles(userId, __userBundles, 5 * 60 * 1000); // 5 minutes TTL
            }
            return __userBundles;
          }
        } catch (err) {
          if (err.name === "AbortError") {
            console.log("Fetch user bundles aborted");
            return __userBundles;
          }
          console.warn("Failed to fetch bundles:", err);
        } finally {
          if (__fetchBundlesController?.signal === signal) {
            __fetchBundlesController = null;
          }
        }
        __userBundles = [];
        return __userBundles;
      };

      const hasBundle = (bundles, id) =>
        (bundles || []).some((b) => {
          if (typeof b === "string") return b === id;
          return b?.bundleId === id;
        });

      const markToRequest = (btn, message = "Request bundle") => {
        const tg = btn.getAttribute("data-tokens-granted");
        const tokenLabel = tg ? ` (${tg} token${tg !== "1" ? "s" : ""})` : "";
        btn.textContent = message + tokenLabel;
        btn.disabled = false;
        btn.style.backgroundColor = "#2c5aa0";
      };

      const markGranted = (btn, message = "Added ✓") => {
        btn.textContent = message;
        btn.disabled = true;
        btn.style.backgroundColor = "#0a8927";
      };

      // --- request individual bundle
      async function requestBundle(bundleId, bundleName, qualifiers = {}, fireAndForget = true) {
        const idToken = getIdToken();
        if (!idToken) {
          showStatus("Please log in first to request bundles.", "warning");
          window.location.href = "auth/login.html";
          return false;
        }

        // Show status immediately before making the request
        showStatus(`Requesting bundle "${bundleName}"...`, "info");

        try {
          const r = await window.fetchWithIdToken("/api/v1/bundle", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            fireAndForget,
            body: JSON.stringify({ bundleId, qualifiers }),
          });
          const body = await r.json().catch(() => ({}));

          if (r.ok) {
            if (r.status === 202 || body.status === "granted" || body.status === "already_granted") {
              showStatus(`Bundle "${bundleName}" added successfully.`, "success");
              // Update local state and write through to persistent cache
              if (!hasBundle(__userBundles, bundleId)) {
                __userBundles.push(bundleId);
              }
              const userInfoJson = localStorage.getItem("userInfo");
              let userId = null;
              try {
                const userInfo = JSON.parse(userInfoJson);
                userId = userInfo && userInfo.sub;
              } catch {}
              if (userId) {
                await window.bundleCache.setBundles(userId, __userBundles, 5 * 60 * 1000);
              }
              // Refresh in-memory cache and re-render
              invalidate("/api/v1/bundle");
              try {
                renderCurrentBundles();
              } catch {}
              try {
                updateBundleStatus();
              } catch {}
              // Notify developer mode toggle to refresh
              window.dispatchEvent(new CustomEvent("bundle-changed"));
              return true;
            } else {
              showStatus(`Bundle ${bundleId} request failed: unexpected response`, "error");
            }
          } else {
            showStatus(`Failed to request bundle: ${body.error || "Unknown error"}`, "error");
          }
        } catch (err) {
          showStatus(`Failed to request bundle. Error: ${err?.message || err}.`, "error");
        }
        return false;
      }

      // --- render one catalog card
      const cardHtml = (b) => {
        const rawName = (b && (b.name || b.id)) || "";
        const safeName = String(rawName).replace(/\"/g, "&quot;");
        const tg = b.tokensGranted;
        const tgAttr = tg !== undefined ? ` data-tokens-granted="${tg}"` : "";
        const tokenLabel = tg !== undefined ? ` (${tg} token${tg !== 1 ? "s" : ""})` : "";
        const enable = b.enable || "never";

        // Check capacity availability from API response (for bundles with a cap)
        const fullEntry = __fullBundleData.find((fb) => fb.bundleId === b.id);
        const capacityAvailable = fullEntry?.bundleCapacityAvailable !== false;

        // Check if pass validation enables this bundle
        let passCode = null;
        try {
          const pv = sessionStorage.getItem("passValidation");
          if (pv) {
            const parsed = JSON.parse(pv);
            if (parsed.bundleId === b.id && parsed.valid) passCode = parsed.code;
          }
        } catch {}

        const allocation = b.allocation || "";

        // on-pass without valid pass: disabled with reason on button
        if (enable === "on-pass" && !passCode) {
          return `
          <div class="service-item" style="text-align:left">
            <button type="button" class="btn service-btn" data-bundle-id="${b.id}" data-bundle-name="${safeName}"${tgAttr} data-requires-pass="true" data-disabled-reason="on-pass" disabled>Pass required \u2014 ${rawName}</button>
            <p style="font-size:0.85em; color:#856404; margin:0.5em 0 0;">Enter a pass invitation above to unlock this bundle</p>
          </div>`;
        }

        // on-pass-on-subscription with valid pass: show Subscribe or Manage button
        if (allocation === "on-pass-on-subscription" && passCode) {
          const isLoggedIn = !!getIdToken();
          if (!isLoggedIn) {
            return `
            <div class="service-item" style="text-align:left">
              <button type="button" class="btn service-btn" data-bundle-id="${b.id}" data-bundle-name="${safeName}"${tgAttr} disabled>Log in to subscribe \u2014 ${rawName}</button>
              <p style="font-size:0.85em; color:#0c5460; margin:0.5em 0 0;">Log in to subscribe to this bundle</p>
            </div>`;
          }
          // Check if user already has this bundle with an active subscription
          const existingSub = __fullBundleData.find((fb) => fb.bundleId === b.id && fb.allocated && fb.stripeSubscriptionId);
          if (existingSub) {
            return `
            <div class="service-item" style="text-align:left">
              <button type="button" class="btn service-btn" data-bundle-id="${b.id}" data-bundle-name="${safeName}" data-manage-subscription="true" style="background-color: #17a2b8;">Manage Subscription \u2014 ${rawName}</button>
              <p style="font-size:0.85em; color:#155724; margin:0.5em 0 0;">Active subscription</p>
            </div>`;
          }
          return `
          <div class="service-item" style="text-align:left">
            <button type="button" class="btn service-btn" data-bundle-id="${b.id}" data-bundle-name="${safeName}" data-subscribe="true" style="background-color: #6f42c1;">Subscribe \u00a39.99/mo \u2014 ${rawName}</button>
            <p style="font-size:0.85em; color:#383d41; margin:0.5em 0 0;">Monthly subscription via Stripe</p>
          </div>`;
        }

        // on-subscription: disabled with reason on button
        if (enable === "on-subscription") {
          return `
          <div class="service-item" style="text-align:left">
            <button type="button" class="btn service-btn" data-bundle-id="${b.id}" data-bundle-name="${safeName}"${tgAttr} data-disabled-reason="on-subscription" disabled>Subscription required \u2014 ${rawName}</button>
            <p style="font-size:0.85em; color:#856404; margin:0.5em 0 0;">A subscription is needed for this bundle</p>
          </div>`;
        }

        // Capacity full: disabled with reason on button (pass bypasses cap)
        if (!capacityAvailable && !passCode) {
          return `
          <div class="service-item" style="text-align:left">
            <button type="button" class="btn service-btn" data-bundle-id="${b.id}" data-bundle-name="${safeName}"${tgAttr} data-disabled-reason="capacity" disabled>Limit reached \u2014 ${rawName}</button>
            <p style="font-size:0.85em; color:#856404; margin:0.5em 0 0;">Global user limit reached, please try again tomorrow</p>
          </div>`;
        }

        // on-pass with valid pass: enabled, pass code attached
        if (enable === "on-pass" && passCode) {
          const safeCode = String(passCode).replace(/\"/g, "&quot;");
          const isLoggedIn = !!getIdToken();
          if (!isLoggedIn) {
            return `
            <div class="service-item" style="text-align:left">
              <button type="button" class="btn service-btn" data-bundle-id="${b.id}" data-bundle-name="${safeName}"${tgAttr} data-pass-code="${safeCode}" disabled>Log in to add \u2014 ${rawName}</button>
              <p style="font-size:0.85em; color:#0c5460; margin:0.5em 0 0;">Log in to add this bundle</p>
            </div>`;
          }
          return `
          <div class="service-item" style="text-align:left">
            <button type="button" class="btn service-btn" data-bundle-id="${b.id}" data-bundle-name="${safeName}"${tgAttr} data-pass-code="${safeCode}">Request ${rawName}${tokenLabel}</button>
          </div>`;
        }

        // enable = "always": normal enabled button
        return `
          <div class="service-item" style="text-align:left">
            <button type="button" class="btn service-btn" data-bundle-id="${b.id}" data-bundle-name="${safeName}"${tgAttr}>Request ${rawName}${tokenLabel}</button>
          </div>`;
      };

      // --- click handler for all request buttons
      document.addEventListener("click", async (e) => {
        const btn = e.target.closest("button[data-bundle-id]");
        if (!btn || btn.disabled) return;

        const bundleId = btn.getAttribute("data-bundle-id");
        const bundleName = btn.getAttribute("data-bundle-name") || bundleId;
        const original = btn.textContent;

        // Pass-enabled bundle: redeem the pass to grant the bundle
        const passCode = btn.getAttribute("data-pass-code");
        if (passCode) {
          btn.textContent = "Redeeming...";
          btn.disabled = true;
          const success = await redeemPassCode(passCode);
          if (success) {
            markGranted(btn, `Added ✓ ${bundleName}`);
            // Clear pass validation after successful redemption
            try {
              sessionStorage.removeItem("passValidation");
            } catch {}
          } else {
            btn.textContent = original;
            btn.disabled = false;
          }
          return;
        }

        // Normal bundle request
        const card = btn.closest(".service-item");
        const qualifiers = {};
        const tx = card?.querySelector('input[name="transactionId"]');
        if (tx?.value) qualifiers.transactionId = tx.value;
        const tier = card?.querySelector('input[name="subscriptionTier"]');
        if (tier?.value) qualifiers.subscriptionTier = tier.value;

        btn.textContent = "Requesting...";
        btn.disabled = true;

        const success = await requestBundle(bundleId, bundleName, qualifiers, true);
        if (success) {
          markGranted(btn, `Added ✓ ${bundleName}`);
        } else {
          btn.textContent = original;
          btn.disabled = false;
        }
      });

      // --- Subscribe click handler
      document.addEventListener("click", async (e) => {
        const btn = e.target.closest("button[data-subscribe]");
        if (!btn || btn.disabled) return;

        const idToken = getIdToken();
        if (!idToken) {
          showStatus("Please log in first to subscribe.", "warning");
          window.location.href = "auth/login.html";
          return;
        }

        btn.textContent = "Redirecting to checkout...";
        btn.disabled = true;

        try {
          const response = await window.fetchWithIdToken("/api/v1/billing/checkout-session", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
          });
          const body = await response.json().catch(() => ({}));

          if (response.ok && body.checkoutUrl) {
            window.location.href = body.checkoutUrl;
          } else {
            showStatus(`Failed to start checkout: ${body.error || body.message || "Unknown error"}`, "error");
            btn.textContent = "Subscribe £9.99/mo";
            btn.disabled = false;
          }
        } catch (err) {
          showStatus(`Failed to start checkout: ${err?.message || err}`, "error");
          btn.textContent = "Subscribe £9.99/mo";
          btn.disabled = false;
        }
      });

      // --- Manage Subscription click handler
      document.addEventListener("click", async (e) => {
        const btn = e.target.closest("button[data-manage-subscription]");
        if (!btn || btn.disabled) return;

        const idToken = getIdToken();
        if (!idToken) {
          showStatus("Please log in first.", "warning");
          return;
        }

        btn.textContent = "Loading portal...";
        btn.disabled = true;

        try {
          const response = await window.fetchWithIdToken("/api/v1/billing/portal", {
            headers: { "Content-Type": "application/json" },
          });
          const body = await response.json().catch(() => ({}));

          if (response.ok && body.portalUrl) {
            window.location.href = body.portalUrl;
          } else {
            showStatus(`Failed to open subscription portal: ${body.error || body.message || "Unknown error"}`, "error");
            btn.textContent = "Manage Subscription";
            btn.disabled = false;
          }
        } catch (err) {
          showStatus(`Failed to open subscription portal: ${err?.message || err}`, "error");
          btn.textContent = "Manage Subscription";
          btn.disabled = false;
        }
      });

      // --- reflect previously granted
      function updateBundleStatus() {
        const bundles = parseUserBundles();
        document.querySelectorAll("button[data-bundle-id]").forEach((btn) => {
          const id = btn.getAttribute("data-bundle-id");
          const name = btn.getAttribute("data-bundle-name") || id;
          if (hasBundle(bundles, id)) {
            markGranted(btn, `Added ✓ ${name}`);
          } else if (!btn.hasAttribute("data-disabled-reason")) {
            // Re-enable buttons that are not structurally disabled (on-pass/on-subscription/capacity)
            markToRequest(btn, `Request ${name}`);
          }
        });
      }

      // --- render catalogue bundles (reusable, reads from __catalogueData)
      function renderCatalogueBundles() {
        const container = document.getElementById("catalogBundles");
        if (!__catalogueData || !__catalogueData.bundles) {
          container.innerHTML = '<p class="service-description">Catalog unavailable.</p>';
          return;
        }
        const cards = (__catalogueData.bundles || [])
          .filter((b) => b["allocation"] && b["allocation"] !== "automatic")
          .filter((b) => b["enable"] !== "never")
          .filter((b) => {
            if (!b.hidden) return true;
            // Show hidden bundles if a valid pass unlocks them
            try {
              const pv = sessionStorage.getItem("passValidation");
              if (pv) {
                const parsed = JSON.parse(pv);
                if (parsed.bundleId === b.id && parsed.valid) return true;
              }
            } catch {}
            return false;
          })
          .filter((b) => {
            const listed = b?.listedInEnvironments;
            if (!Array.isArray(listed) || listed.length === 0) return true;
            if (!__currentEnv) return false;
            return listed.includes(__currentEnv);
          })
          .map(cardHtml)
          .join("\n");
        container.innerHTML = cards || '<p class="service-description">No bundles available.</p>';
        updateBundleStatus();
      }

      // Read current environment from submit.environment-name.txt
      async function readEnvironment() {
        try {
          const envRes = await fetch("submit.environment-name.txt", { cache: "no-store" });
          if (envRes.ok) {
            const text = (await envRes.text()).trim();
            return text || null;
          }
        } catch {}
        return null;
      }

      // --- bootstrap: fetch catalog and render
      (async function () {
        const container = document.getElementById("catalogBundles");
        try {
          await fetchUserBundles();
          try {
            renderCurrentBundles();
          } catch {}

          const idToken = getIdToken();
          const headers = idToken ? { Authorization: `Bearer ${idToken}` } : undefined;
          __catalogueData = await fetchAndParse("/submit.catalogue.toml", {
            ttlMs: 300000,
            init: headers ? { headers } : undefined,
          });
          if (!__catalogueData || !__catalogueData.bundles) {
            container.innerHTML = '<p class="service-description">Catalog unavailable.</p>';
            return;
          }

          __currentEnv = await readEnvironment();
          renderCatalogueBundles();
          // Re-render current bundles now that catalogue names are available
          try {
            renderCurrentBundles();
          } catch {}
        } catch (err) {
          try {
            console.error("[bundles.html] Catalog bootstrap error:", err && (err.stack || err.message || err));
          } catch {}
          container.innerHTML = '<p class="service-description">Failed to load catalog.</p>';
        }
      })();

      // --- render current user bundles with remove buttons
      function renderCurrentBundles() {
        const container = document.getElementById("currentBundles");
        const bundles = parseUserBundles();

        const bundleCards = bundles
          .map((bundleEntry) => {
            const bundleId = typeof bundleEntry === "string" ? bundleEntry : bundleEntry.bundleId;

            // Look up display name from catalogue
            const catBundle = __catalogueData?.bundles?.find((cb) => cb.id === bundleId);
            const displayName = catBundle?.name || bundleId;

            // Look up full bundle data for token info
            const fullData = __fullBundleData.find((b) => b.bundleId === bundleId && b.allocated);
            const tokensRemaining = fullData?.tokensRemaining;
            const tokensGranted = fullData?.tokensGranted ?? catBundle?.tokensGranted;
            const tokenResetAt = fullData?.tokenResetAt;

            // Build info fragments
            const fragments = [];
            if (tokensGranted !== undefined) {
              fragments.push(`${tokensGranted} token${tokensGranted !== 1 ? "s" : ""} allocated`);
            }
            if (tokensRemaining !== undefined) {
              fragments.push(`${tokensRemaining} remaining`);
            }
            if (tokenResetAt) {
              const resetDate = new Date(tokenResetAt);
              if (!isNaN(resetDate.getTime())) {
                fragments.push(`refreshes ${resetDate.toLocaleDateString()}`);
              }
            }
            const expiryStr = fullData?.expiry;
            if (expiryStr) {
              const expiryDate = new Date(expiryStr);
              if (!isNaN(expiryDate.getTime())) {
                fragments.push(`expires ${expiryDate.toLocaleDateString()}`);
              }
            }

            const infoLine =
              fragments.length > 0 ? `<div style="font-size: 0.85em; color: #666; margin-top: 0.25em;">${fragments.join(" · ")}</div>` : "";

            return `
            <div class="service-item" style="text-align:left; margin-bottom: 1em; background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 5px; padding: 1em;">
              <span style="display:flex; align-items:center; gap:0.75em">
                <span>${displayName}</span>
                <button type="button" class="btn" data-remove-bundle-id="${bundleId}"
                  style="background-color: #dc3545; border-color: #dc3545; color: white; font-size: 0.8em; padding: 0.15em 0.5em; min-width: unset; width:auto; display:inline-flex; align-items:center;">
                    Remove
                </button>
              </span>
              ${infoLine}
            </div>`;
          })
          .join("");

        container.innerHTML = bundleCards;
      }

      // --- click handler for remove buttons
      document.addEventListener("click", async (e) => {
        if (e.target.closest("button[data-remove-bundle-id]")) {
          const btn = e.target.closest("button[data-remove-bundle-id]");
          const bundleId = btn.getAttribute("data-remove-bundle-id");
          await removeBundle(bundleId);
        }
      });

      // --- remove individual bundle
      async function removeBundle(bundleId, fireAndForget = true) {
        const idToken = getIdToken();
        if (!idToken) {
          showStatus("Please log in first to remove bundles.", "warning");
          window.location.href = "auth/login.html";
          return;
        }

        // Show status immediately before making the request
        showStatus(`Removing bundle "${bundleId}"...`, "info");

        try {
          const response = await window.fetchWithIdToken("/api/v1/bundle", {
            method: "DELETE",
            headers: {
              "Content-Type": "application/json",
            },
            fireAndForget,
            body: JSON.stringify({ bundleId }),
          });

          const result = await response.json().catch(() => ({}));

          if (response.ok) {
            // Update local state and write through to persistent cache
            __userBundles = __userBundles.filter((b) => (typeof b === "string" ? b : b.bundleId) !== bundleId);
            const userInfoJson = localStorage.getItem("userInfo");
            let userId = null;
            try {
              const userInfo = JSON.parse(userInfoJson);
              userId = userInfo && userInfo.sub;
            } catch {}
            if (userId) {
              await window.bundleCache.setBundles(userId, __userBundles, 5 * 60 * 1000);
            }
            invalidate("/api/v1/bundle");
            renderCurrentBundles();
            updateBundleStatus(); // Update the request buttons
            // Notify developer mode toggle to refresh
            window.dispatchEvent(new CustomEvent("bundle-changed"));
            showStatus(`Bundle "${bundleId}" removed successfully.`, "success");
          } else {
            showStatus(`Failed to remove bundle: ${result.error || "Unknown error"}`, "error");
          }
        } catch (error) {
          showStatus("Failed to remove bundle. Please try again.", "error");
          console.error("Remove bundle error:", error);
        }
      }

      // --- pass redemption ---
      const passReasonMessages = {
        not_found: "Pass not found. Please check the code and try again.",
        expired: "This pass has expired.",
        exhausted: "This pass has been fully used.",
        revoked: "This pass has been revoked.",
        wrong_email: "This pass is restricted to a different email address.",
        email_required: "This pass requires email verification.",
        not_yet_valid: "This pass is not yet valid.",
      };

      function showPassStatus(message, type) {
        const el = document.getElementById("passStatus");
        if (!el) return;
        el.textContent = message;
        el.style.display = "block";
        el.style.backgroundColor =
          type === "success"
            ? "var(--color-success-bg, #d4edda)"
            : type === "error"
              ? "var(--color-error-bg, #f8d7da)"
              : "var(--color-info-bg, #d1ecf1)";
        el.style.color =
          type === "success"
            ? "var(--color-success-text, #155724)"
            : type === "error"
              ? "var(--color-error-text, #721c24)"
              : "var(--color-info-text, #0c5460)";
        el.style.border = `1px solid ${type === "success" ? "var(--color-success-border, #c3e6cb)" : type === "error" ? "var(--color-error-border, #f5c6cb)" : "var(--color-info-border, #bee5eb)"}`;
      }

      async function redeemPassCode(code) {
        const idToken = getIdToken();
        if (!idToken) {
          try {
            sessionStorage.setItem("pendingPass", code);
          } catch {}
          showPassStatus("Please log in to redeem your pass.", "info");
          return false;
        }

        const btn = document.getElementById("redeemPassBtn");
        if (btn) {
          btn.textContent = "Redeeming...";
          btn.disabled = true;
        }

        try {
          const response = await window.fetchWithIdToken("/api/v1/pass", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ code }),
          });
          const body = await response.json().catch(() => ({}));

          if (body.requiresSubscription) {
            // Pass is valid but bundle requires subscription — store validation and re-render
            try {
              sessionStorage.setItem("passValidation", JSON.stringify({ code, bundleId: body.bundleId, valid: true }));
            } catch {}
            showPassStatus(`Pass valid! Click "Subscribe" to start your subscription.`, "success");
            renderCatalogueBundles();
            return true;
          }

          if (body.redeemed) {
            showPassStatus(`Pass redeemed! Bundle "${body.bundleId}" has been added.`, "success");
            // Update local state
            if (!hasBundle(__userBundles, body.bundleId)) {
              __userBundles.push(body.bundleId);
            }
            invalidate("/api/v1/bundle");
            // Clear persistent bundle cache so fetchUserBundles hits the API
            try {
              const uij = localStorage.getItem("userInfo");
              const uid = uij && JSON.parse(uij)?.sub;
              if (uid) await window.bundleCache.clearBundles(uid);
            } catch {}
            // Refresh full bundle data
            await fetchUserBundles();
            try {
              renderCurrentBundles();
            } catch {}
            try {
              updateBundleStatus();
            } catch {}
            window.dispatchEvent(new CustomEvent("bundle-changed"));
            // Clear pending pass
            try {
              sessionStorage.removeItem("pendingPass");
            } catch {}
            // Remove ?pass= from URL without reload
            const url = new URL(window.location);
            url.searchParams.delete("pass");
            window.history.replaceState({}, "", url);
            return true;
          } else {
            const msg = passReasonMessages[body.reason] || `Pass redemption failed: ${body.reason || "unknown error"}`;
            showPassStatus(msg, "error");
            return false;
          }
        } catch (err) {
          showPassStatus(`Failed to redeem pass: ${err?.message || err}`, "error");
          return false;
        } finally {
          if (btn) {
            btn.textContent = "Redeem Pass";
            btn.disabled = false;
          }
        }
      }

      // --- validate pass code (GET, public, no auth needed)
      async function validatePassCode(code) {
        try {
          const response = await fetch(`/api/v1/pass?code=${encodeURIComponent(code)}`);
          return await response.json();
        } catch (err) {
          return { valid: false, reason: "network_error" };
        }
      }

      // --- handle pass entry: validate first, then enable bundle or auto-redeem
      async function handlePassEntry(code) {
        const btn = document.getElementById("redeemPassBtn");
        if (btn) {
          btn.textContent = "Checking...";
          btn.disabled = true;
        }

        try {
          const result = await validatePassCode(code);

          if (!result.valid) {
            const msg = passReasonMessages[result.reason] || `Pass not valid: ${result.reason || "unknown"}`;
            showPassStatus(msg, "error");
            return;
          }

          // Pass is valid — store validation in sessionStorage
          const bundleId = result.bundleId;
          try {
            sessionStorage.setItem("passValidation", JSON.stringify({ code, bundleId, valid: true }));
          } catch {}

          const isLoggedIn = !!getIdToken();

          // Look up bundle from catalogue
          const catBundle = __catalogueData?.bundles?.find((cb) => cb.id === bundleId);
          const bundleName = catBundle?.name || bundleId;
          const isHidden = !!catBundle?.hidden;

          if (isLoggedIn) {
            const isSubscriptionBundle = catBundle?.allocation === "on-pass-on-subscription";
            if (isSubscriptionBundle) {
              showPassStatus(`Pass valid! Click "Subscribe" to start your subscription.`, "success");
            } else {
              showPassStatus(`Pass valid! Click "Request ${bundleName}" to add the bundle.`, "success");
            }
          } else {
            try {
              sessionStorage.setItem("pendingPass", code);
              sessionStorage.setItem("postLoginRedirect", window.location.pathname + "?pass=" + encodeURIComponent(code));
            } catch {}
            showPassStatus(`Pass valid! Log in to add the "${bundleName}" bundle.`, "info");
          }
          // Re-render catalogue to show the pass-unlocked bundle
          renderCatalogueBundles();
        } catch (err) {
          showPassStatus(`Failed to check pass: ${err?.message || err}`, "error");
        } finally {
          if (btn) {
            btn.textContent = "Redeem Pass";
            btn.disabled = false;
          }
        }
      }

      // Pass form click handler
      document.getElementById("redeemPassBtn")?.addEventListener("click", async () => {
        const input = document.getElementById("passInput");
        const code = (input?.value || "").trim().toLowerCase();
        if (!code) {
          showPassStatus("Please enter a passphrase.", "error");
          return;
        }
        await handlePassEntry(code);
      });

      // Allow Enter key to submit
      document.getElementById("passInput")?.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          document.getElementById("redeemPassBtn")?.click();
        }
      });

      // --- initialize current bundles display
      setTimeout(() => {
        renderCurrentBundles();
      }, 100);

      // Waitlist section logic
      async function initWaitlistSection() {
        var section = document.getElementById("waitlistSection");
        if (!section) return;

        var isLoggedIn = !!getIdToken();
        var alreadyRegistered = false;
        try {
          alreadyRegistered = localStorage.getItem("waitlistRegistered") === "true";
        } catch {}

        if (!isLoggedIn || alreadyRegistered) return;

        // Check feature flag
        if (window.featureFlags && typeof window.featureFlags.isFeatureEnabled === "function") {
          var enabled = await window.featureFlags.isFeatureEnabled("waitlist");
          if (!enabled) return;
        }

        section.style.display = "block";

        var joinBtn = document.getElementById("waitlistJoinBtn");
        if (joinBtn) {
          // If already registered, update button state
          if (alreadyRegistered) {
            joinBtn.textContent = "You're registered!";
            joinBtn.style.backgroundColor = "#0a8927";
            joinBtn.disabled = true;
            return;
          }

          joinBtn.addEventListener("click", async function () {
            joinBtn.disabled = true;
            joinBtn.textContent = "Registering...";
            try {
              var response = await window.fetchWithIdToken("/api/v1/interest", { method: "POST" });
              if (response.ok) {
                joinBtn.textContent = "You're registered!";
                joinBtn.style.backgroundColor = "#0a8927";
                try {
                  localStorage.setItem("waitlistRegistered", "true");
                } catch {}
              } else {
                joinBtn.textContent = "Try again";
                joinBtn.disabled = false;
              }
            } catch (err) {
              console.error("Waitlist registration failed:", err);
              joinBtn.textContent = "Try again";
              joinBtn.disabled = false;
            }
          });
        }
      }

      // --- page init
      try {
        sessionStorage.removeItem("currentActivity");
      } catch {}

      // Initialize page - wait for submit.js module to be ready
      function initPage() {
        checkAuthStatus();
        initWaitlistSection();

        // Handle checkout result from Stripe redirect
        const urlParams = new URLSearchParams(window.location.search);
        const checkoutResult = urlParams.get("checkout");
        if (checkoutResult === "success") {
          showStatus("Subscription activated! Your bundle has been added.", "success");
          // Clear URL param without reload
          const url = new URL(window.location);
          url.searchParams.delete("checkout");
          window.history.replaceState({}, "", url);
          // Invalidate bundle cache and re-fetch
          invalidate("/api/v1/bundle");
          try {
            const uij = localStorage.getItem("userInfo");
            const uid = uij && JSON.parse(uij)?.sub;
            if (uid) window.bundleCache.clearBundles(uid);
          } catch {}
          fetchUserBundles().then(() => {
            try { renderCurrentBundles(); } catch {}
            try { renderCatalogueBundles(); } catch {}
            window.dispatchEvent(new CustomEvent("bundle-changed"));
          });
        } else if (checkoutResult === "canceled") {
          showStatus("Checkout was canceled. You can try again when you're ready.", "info");
          const url = new URL(window.location);
          url.searchParams.delete("checkout");
          window.history.replaceState({}, "", url);
        }

        // Handle ?pass= URL parameter
        const passFromUrl = urlParams.get("pass");
        if (passFromUrl) {
          const input = document.getElementById("passInput");
          if (input) input.value = passFromUrl;
          // Validate pass (whether new or returning from login)
          handlePassEntry(passFromUrl.trim().toLowerCase());
        } else {
          // Check for pending pass from previous session (saved before login redirect)
          try {
            const pendingPass = sessionStorage.getItem("pendingPass");
            if (pendingPass && getIdToken()) {
              const input = document.getElementById("passInput");
              if (input) input.value = pendingPass;
              handlePassEntry(pendingPass.trim().toLowerCase());
            }
          } catch {}
        }
      }

      if (window.__submitReady__) {
        initPage();
      } else {
        document.addEventListener("submit-ready", initPage, { once: true });
      }
    </script>
  </body>
</html>
