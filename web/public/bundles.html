<!-- bundles.html -->
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>DIY Accounting Submit - Bundles</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="submit.css" />
    <!-- CloudWatch RUM configuration placeholders; replace values during deployment -->
    <meta name="rum:appMonitorId" content="${RUM_APP_MONITOR_ID}" />
    <meta name="rum:region" content="${AWS_REGION}" />
    <meta name="rum:identityPoolId" content="${RUM_IDENTITY_POOL_ID}" />
    <meta name="rum:guestRoleArn" content="${RUM_GUEST_ROLE_ARN}" />
  </head>
  <body>
    <a href="#mainContent" class="skip-link">Skip to main content</a>
    <header>
      <div class="header-nav">
        <div class="header-left">
          <a href="index.html" title="Home" class="home-link">
            <svg class="home-icon" viewBox="0 0 24 24" aria-hidden="true">
              <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" />
            </svg>
          </a>
          <a href="about.html" title="About & Help" class="info-link">
            <svg class="info-icon" viewBox="0 0 24 24" aria-hidden="true">
              <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z" />
            </svg>
          </a>
        </div>
        <div class="auth-section">
          <span class="entitlement-status">Activity: unrestricted</span>
          <span class="login-status">Not logged in</span>
          <a href="auth/login.html" class="login-link">Log in</a>
        </div>
      </div>
      <h1>DIY Accounting Submit</h1>
      <p class="subtitle">Submit UK VAT returns to HMRC under Making Tax Digital (MTD)</p>
      <nav class="main-nav" aria-label="Main navigation">
        <a href="index.html">Activities</a>
        <a href="hmrc/receipt/receipts.html">Receipts</a>
        <a href="bundles.html" class="active">Bundles</a>
      </nav>
    </header>

    <main id="mainContent">
      <div id="statusMessagesContainer" role="alert" aria-live="polite"></div>

      <div id="loadingSpinner" class="spinner" style="display: none"></div>

      <div class="form-container" style="text-align: center">
        <h2>Bundles</h2>

        <div class="bundles-list" id="catalogBundles"></div>

        <div style="margin-top: 3em; padding-top: 2em; border-top: 1px solid #ddd">
          <h3>Have a Pass?</h3>
          <p style="color: #666; font-size: 0.9em;">Enter a four-word passphrase to redeem your invitation.</p>
          <div id="passEntryForm" style="margin: 1em auto; max-width: 440px; text-align: left;">
            <input type="text" id="passInput" placeholder="word-word-word-word" autocomplete="off" spellcheck="false"
              style="width: 100%; padding: 0.6em; font-size: 1em; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box;" />
            <div style="margin-top: 0.75em; text-align: center;">
              <button type="button" id="redeemPassBtn" class="btn" style="min-width: 160px;">Redeem Pass</button>
            </div>
            <div id="passStatus" role="alert" aria-live="polite" style="margin-top: 0.75em; display: none; padding: 0.6em; border-radius: 4px; font-size: 0.9em;"></div>
          </div>
        </div>

        <div style="margin-top: 3em; padding-top: 2em; border-top: 1px solid #ddd">
          <h3>Your Current Bundles</h3>
          <div id="currentBundles" style="margin: 1em 0"></div>
        </div>
      </div>
    </main>

    <footer>
      <div class="footer-content">
        <div class="footer-left">
          <a href="#" id="viewSourceLink" style="display: none">view source</a>
          <a id="latestTestsLink" style="display: inline" target="_blank" href="tests/index.html">tests</a>
          <a id="apiDocsLink" style="display: inline" target="_blank" href="docs/api/index.html"> api </a>
        </div>
        <div class="footer-center">
          <p>&copy; 2025-2026 DIY Accounting Limited</p>
        </div>
        <div class="footer-right" id="localstorageContainer"></div>
      </div>
    </footer>

    <script type="module" src="submit.js"></script>
    <script src="developer-mode.js"></script>
    <script src="lib/request-cache.js"></script>
    <script src="lib/bundle-cache.js"></script>
    <script src="lib/toml-parser.js"></script>
    <script src="widgets/entitlement-status.js"></script>
    <script src="widgets/auth-status.js"></script>
    <script src="widgets/status-messages.js"></script>
    <script src="widgets/loading-spinner.js"></script>
    <script type="module" src="widgets/view-source-link.js"></script>
    <script src="widgets/localstorage-viewer.js"></script>

    <script>
      // --- helpers
      const getIdToken = () => {
        try {
          return localStorage.getItem("cognitoIdToken");
        } catch (e) {
          // In opaque origins (e.g., setContent in tests), localStorage may be inaccessible
          return null;
        }
      };

      // Lightweight wrappers that use page-level cache when available, with safe fallbacks for tests
      const __rc = typeof window !== "undefined" && window.requestCache ? window.requestCache : null;
      const fetchAndParse = async (url, opts = {}) => {
        try {
          if (__rc && typeof __rc.getJSON === "function" && !url.endsWith(".toml")) return __rc.getJSON(url, opts);
        } catch {}
        // Fallback: Use fetchWithIdToken if authorization is needed
        const init = opts.init || {};
        const hasAuthHeader = init.headers && (init.headers.Authorization || init.headers.authorization);
        let res;
        if (hasAuthHeader && window.fetchWithIdToken) {
          res = await window.fetchWithIdToken(url, init);
        } else {
          res = await fetch(url, init);
        }

        try {
          if (url.endsWith(".toml")) {
            const text = await res.text();
            return window.TOML ? window.TOML.parse(text) : null;
          }
          return await res.json();
        } catch {
          return null;
        }
      };
      const invalidate = (prefix) => {
        try {
          if (__rc && typeof __rc.invalidate === "function") return __rc.invalidate(prefix);
        } catch {}
      };

      // In-memory bundles state for this page
      let __userBundles = [];
      let __fullBundleData = []; // Full bundle objects from API (with token info, allocated flag, etc.)
      let __fetchBundlesController = null;

      const parseUserBundles = () => (Array.isArray(__userBundles) ? __userBundles : []);

      // Fetch bundles from API endpoint (single source of truth, with lightweight caching)
      const fetchUserBundles = async () => {
        const idToken = getIdToken();
        if (!idToken) {
          __userBundles = [];
          return __userBundles;
        }

        const userInfoJson = localStorage.getItem("userInfo");
        let userId = null;
        try {
          const userInfo = JSON.parse(userInfoJson);
          userId = userInfo && userInfo.sub;
        } catch {}

        if (userId) {
          const cached = await window.bundleCache.getBundles(userId);
          if (cached && Array.isArray(cached)) {
            __userBundles = cached;
            return __userBundles;
          }
        }

        // Abort previous fetch if any
        if (__fetchBundlesController) {
          __fetchBundlesController.abort();
        }
        __fetchBundlesController = new AbortController();
        const signal = __fetchBundlesController.signal;

        try {
          const bundlesData = await fetchAndParse("/api/v1/bundle", {
            ttlMs: 0,
            init: { headers: { Authorization: `Bearer ${idToken}` }, signal },
          });
          if (bundlesData && bundlesData.bundles && Array.isArray(bundlesData.bundles)) {
            __fullBundleData = bundlesData.bundles;
            __userBundles = bundlesData.bundles.filter((b) => b.allocated).map((b) => b.bundleId);
            if (userId) {
              await window.bundleCache.setBundles(userId, __userBundles, 5 * 60 * 1000); // 5 minutes TTL
            }
            return __userBundles;
          }
        } catch (err) {
          if (err.name === "AbortError") {
            console.log("Fetch user bundles aborted");
            return __userBundles;
          }
          console.warn("Failed to fetch bundles:", err);
        } finally {
          if (__fetchBundlesController?.signal === signal) {
            __fetchBundlesController = null;
          }
        }
        __userBundles = [];
        return __userBundles;
      };

      const hasBundle = (bundles, id) =>
        (bundles || []).some((b) => {
          if (typeof b === "string") return b === id;
          return b?.bundleId === id;
        });

      const markToRequest = (btn, message = "Request bundle") => {
        btn.textContent = message;
        btn.disabled = false;
        btn.style.backgroundColor = "#2c5aa0";
      };

      const markGranted = (btn, message = "Added ✓") => {
        btn.textContent = message;
        btn.disabled = true;
        btn.style.backgroundColor = "#0a8927";
      };

      // --- request individual bundle
      async function requestBundle(bundleId, bundleName, qualifiers = {}, fireAndForget = true) {
        const idToken = getIdToken();
        if (!idToken) {
          showStatus("Please log in first to request bundles.", "warning");
          window.location.href = "auth/login.html";
          return false;
        }

        // Show status immediately before making the request
        showStatus(`Requesting bundle "${bundleName}"...`, "info");

        try {
          const r = await window.fetchWithIdToken("/api/v1/bundle", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            fireAndForget,
            body: JSON.stringify({ bundleId, qualifiers }),
          });
          const body = await r.json().catch(() => ({}));

          if (r.ok) {
            if (r.status === 202 || body.status === "granted" || body.status === "already_granted") {
              showStatus(`Bundle "${bundleName}" added successfully.`, "success");
              // Update local state and write through to persistent cache
              if (!hasBundle(__userBundles, bundleId)) {
                __userBundles.push(bundleId);
              }
              const userInfoJson = localStorage.getItem("userInfo");
              let userId = null;
              try {
                const userInfo = JSON.parse(userInfoJson);
                userId = userInfo && userInfo.sub;
              } catch {}
              if (userId) {
                await window.bundleCache.setBundles(userId, __userBundles, 5 * 60 * 1000);
              }
              // Refresh in-memory cache and re-render
              invalidate("/api/v1/bundle");
              try {
                renderCurrentBundles();
              } catch {}
              try {
                updateBundleStatus();
              } catch {}
              // Notify developer mode toggle to refresh
              window.dispatchEvent(new CustomEvent("bundle-changed"));
              return true;
            } else {
              showStatus(`Bundle ${bundleId} request failed: unexpected response`, "error");
            }
          } else {
            showStatus(`Failed to request bundle: ${body.error || "Unknown error"}`, "error");
          }
        } catch (err) {
          showStatus(`Failed to request bundle. Error: ${err?.message || err}.`, "error");
        }
        return false;
      }

      // --- render one catalog card
      const cardHtml = (b) => {
        // Ensure we always work with strings and avoid using String.replaceAll for broader compatibility
        const rawName = (b && (b.name || b.id)) || "";
        const safeName = String(rawName).replace(/\"/g, "&quot;");
        // Check capacity availability from API response (for bundles with a cap)
        const fullEntry = __fullBundleData.find((fb) => fb.bundleId === b.id);
        const capacityAvailable = fullEntry?.bundleCapacityAvailable !== false;
        if (!capacityAvailable) {
          return `
          <div class="service-item" style="text-align:left">
            <button type="button" class="btn service-btn" data-bundle-id="${b.id}" data-bundle-name="${safeName}" disabled
              style="opacity:0.6; cursor:not-allowed;">Request ${rawName}</button>
            <p style="font-size:0.85em; color:#856404; margin:0.5em 0 0;">Global user limit reached, please try again tomorrow.</p>
          </div>`;
        }
        return `
          <div class="service-item" style="text-align:left">
            <button type="button" class="btn service-btn" data-bundle-id="${b.id}" data-bundle-name="${safeName}">Request ${rawName}</button>
          </div>`;
      };

      // --- click handler for all request buttons
      document.addEventListener("click", async (e) => {
        const btn = e.target.closest("button[data-bundle-id]");
        if (!btn) return;

        const bundleId = btn.getAttribute("data-bundle-id");
        const bundleName = btn.getAttribute("data-bundle-name") || bundleId;
        const card = btn.closest(".service-item");
        const original = btn.textContent;

        const qualifiers = {};
        const tx = card?.querySelector('input[name="transactionId"]');
        if (tx?.value) qualifiers.transactionId = tx.value;
        const tier = card?.querySelector('input[name="subscriptionTier"]');
        if (tier?.value) qualifiers.subscriptionTier = tier.value;

        btn.textContent = "Requesting...";
        btn.disabled = true;

        const success = await requestBundle(bundleId, bundleName, qualifiers, true);
        if (success) {
          markGranted(btn, `Added ✓ ${bundleName}`);
        } else {
          btn.textContent = original;
          btn.disabled = false;
        }
      });

      // --- reflect previously granted
      function updateBundleStatus() {
        const bundles = parseUserBundles();
        document.querySelectorAll("button[data-bundle-id]").forEach((btn) => {
          const id = btn.getAttribute("data-bundle-id");
          const name = btn.getAttribute("data-bundle-name") || id;
          if (hasBundle(bundles, id)) {
            markGranted(btn, `Added ✓ ${name}`);
          } else {
            markToRequest(btn, `Request ${name}`);
          }
        });
      }

      // --- bootstrap: fetch catalog and render
      (async function () {
        const container = document.getElementById("catalogBundles");
        try {
          // Fetch user bundles first
          await fetchUserBundles();
          // Ensure current bundles (with remove actions) are rendered immediately on page load
          try {
            renderCurrentBundles();
          } catch {}

          const idToken = getIdToken();
          const headers = idToken ? { Authorization: `Bearer ${idToken}` } : undefined;
          const catalog = await fetchAndParse("/submit.catalogue.toml", {
            ttlMs: 300000,
            init: headers ? { headers } : undefined,
          });
          if (!catalog || !catalog.bundles) {
            container.innerHTML = '<p class="service-description">Catalog unavailable.</p>';
            return;
          }

          // Read current environment from submit.environment-name.txt in docroot (next to index.html)
          async function readEnvironment() {
            try {
              const envRes = await fetch("submit.environment-name.txt", { cache: "no-store" });
              if (envRes.ok) {
                const text = (await envRes.text()).trim();
                return text || null;
              }
            } catch {}
            return null; // Unknown environment
          }

          const env = await readEnvironment();

          const cards = (catalog.bundles || [])
            .filter((b) => b["allocation"] && b["allocation"] !== "automatic")
            // Hide on-pass bundles from the requestable list (they require an invitation pass)
            .filter((b) => b["display"] !== "on-pass")
            // If the bundle specifies listedInEnvironments, only list it when current env is included
            .filter((b) => {
              const listed = b?.listedInEnvironments;
              if (!Array.isArray(listed) || listed.length === 0) return true; // visible everywhere by default
              if (!env) return false; // if environment unknown, hide bundles that specify restrictions
              return listed.includes(env);
            })
            .map(cardHtml)
            .join("\n");
          container.innerHTML = cards || '<p class="service-description">No bundles available.</p>';
          updateBundleStatus();
        } catch (err) {
          try {
            console.error("[bundles.html] Catalog bootstrap error:", err && (err.stack || err.message || err));
          } catch {}
          container.innerHTML = '<p class="service-description">Failed to load catalog.</p>';
        }
      })();

      // --- render current user bundles with remove buttons
      function renderCurrentBundles() {
        const container = document.getElementById("currentBundles");
        const bundles = parseUserBundles();

        const bundleCards = bundles
          .map((bundleEntry) => {
            const bundleId = typeof bundleEntry === "string" ? bundleEntry : bundleEntry.bundleId;

            // Look up full bundle data for token info
            const fullData = __fullBundleData.find((b) => b.bundleId === bundleId && b.allocated);
            const tokensRemaining = fullData?.tokensRemaining;
            const tokenResetAt = fullData?.tokenResetAt;

            // Build info fragments
            const fragments = [];
            if (tokensRemaining !== undefined) {
              fragments.push(`${tokensRemaining} token${tokensRemaining !== 1 ? "s" : ""} remaining`);
            }
            if (tokenResetAt) {
              const resetDate = new Date(tokenResetAt);
              if (!isNaN(resetDate.getTime())) {
                fragments.push(`refreshes ${resetDate.toLocaleDateString()}`);
              }
            }
            const expiryStr = fullData?.expiry;
            if (expiryStr) {
              const expiryDate = new Date(expiryStr);
              if (!isNaN(expiryDate.getTime())) {
                fragments.push(`expires ${expiryDate.toLocaleDateString()}`);
              }
            }

            const infoLine = fragments.length > 0
              ? `<div style="font-size: 0.85em; color: #666; margin-top: 0.25em;">${fragments.join(" · ")}</div>`
              : "";

            return `
            <div class="service-item" style="text-align:left; margin-bottom: 1em; background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 5px; padding: 1em;">
              <span style="display:flex; align-items:center; gap:0.75em">
                <span>${bundleId}</span>
                <button type="button" class="btn" data-remove-bundle-id="${bundleId}"
                  style="background-color: #dc3545; border-color: #dc3545; color: white; font-size: 0.8em; padding: 0.15em 0.5em; min-width: unset; width:auto; display:inline-flex; align-items:center;">
                    Remove
                </button>
              </span>
              ${infoLine}
            </div>`;
          })
          .join("");

        container.innerHTML = bundleCards;
      }

      // --- click handler for remove buttons
      document.addEventListener("click", async (e) => {
        if (e.target.closest("button[data-remove-bundle-id]")) {
          const btn = e.target.closest("button[data-remove-bundle-id]");
          const bundleId = btn.getAttribute("data-remove-bundle-id");
          await removeBundle(bundleId);
        }
      });

      // --- remove individual bundle
      async function removeBundle(bundleId, fireAndForget = true) {
        const idToken = getIdToken();
        if (!idToken) {
          showStatus("Please log in first to remove bundles.", "warning");
          window.location.href = "auth/login.html";
          return;
        }

        // Show status immediately before making the request
        showStatus(`Removing bundle "${bundleId}"...`, "info");

        try {
          const response = await window.fetchWithIdToken("/api/v1/bundle", {
            method: "DELETE",
            headers: {
              "Content-Type": "application/json",
            },
            fireAndForget,
            body: JSON.stringify({ bundleId }),
          });

          const result = await response.json().catch(() => ({}));

          if (response.ok) {
            // Update local state and write through to persistent cache
            __userBundles = __userBundles.filter((b) => (typeof b === "string" ? b : b.bundleId) !== bundleId);
            const userInfoJson = localStorage.getItem("userInfo");
            let userId = null;
            try {
              const userInfo = JSON.parse(userInfoJson);
              userId = userInfo && userInfo.sub;
            } catch {}
            if (userId) {
              await window.bundleCache.setBundles(userId, __userBundles, 5 * 60 * 1000);
            }
            invalidate("/api/v1/bundle");
            renderCurrentBundles();
            updateBundleStatus(); // Update the request buttons
            // Notify developer mode toggle to refresh
            window.dispatchEvent(new CustomEvent("bundle-changed"));
            showStatus(`Bundle "${bundleId}" removed successfully.`, "success");
          } else {
            showStatus(`Failed to remove bundle: ${result.error || "Unknown error"}`, "error");
          }
        } catch (error) {
          showStatus("Failed to remove bundle. Please try again.", "error");
          console.error("Remove bundle error:", error);
        }
      }

      // --- pass redemption ---
      const passReasonMessages = {
        not_found: "Pass not found. Please check the code and try again.",
        expired: "This pass has expired.",
        exhausted: "This pass has been fully used.",
        revoked: "This pass has been revoked.",
        wrong_email: "This pass is restricted to a different email address.",
        email_required: "This pass requires email verification.",
        not_yet_valid: "This pass is not yet valid.",
      };

      function showPassStatus(message, type) {
        const el = document.getElementById("passStatus");
        if (!el) return;
        el.textContent = message;
        el.style.display = "block";
        el.style.backgroundColor = type === "success" ? "var(--color-success-bg, #d4edda)" : type === "error" ? "var(--color-error-bg, #f8d7da)" : "var(--color-info-bg, #d1ecf1)";
        el.style.color = type === "success" ? "var(--color-success-text, #155724)" : type === "error" ? "var(--color-error-text, #721c24)" : "var(--color-info-text, #0c5460)";
        el.style.border = `1px solid ${type === "success" ? "var(--color-success-border, #c3e6cb)" : type === "error" ? "var(--color-error-border, #f5c6cb)" : "var(--color-info-border, #bee5eb)"}`;
      }

      async function redeemPassCode(code) {
        const idToken = getIdToken();
        if (!idToken) {
          try { sessionStorage.setItem("pendingPass", code); } catch {}
          showPassStatus("Please log in to redeem your pass.", "info");
          return false;
        }

        const btn = document.getElementById("redeemPassBtn");
        if (btn) { btn.textContent = "Redeeming..."; btn.disabled = true; }

        try {
          const response = await window.fetchWithIdToken("/api/v1/pass", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ code }),
          });
          const body = await response.json().catch(() => ({}));

          if (body.redeemed) {
            showPassStatus(`Pass redeemed! Bundle "${body.bundleId}" has been added.`, "success");
            // Update local state
            if (!hasBundle(__userBundles, body.bundleId)) {
              __userBundles.push(body.bundleId);
            }
            invalidate("/api/v1/bundle");
            // Clear persistent bundle cache so fetchUserBundles hits the API
            try {
              const uij = localStorage.getItem("userInfo");
              const uid = uij && JSON.parse(uij)?.sub;
              if (uid) await window.bundleCache.clearBundles(uid);
            } catch {}
            // Refresh full bundle data
            await fetchUserBundles();
            try { renderCurrentBundles(); } catch {}
            try { updateBundleStatus(); } catch {}
            window.dispatchEvent(new CustomEvent("bundle-changed"));
            // Clear pending pass
            try { sessionStorage.removeItem("pendingPass"); } catch {}
            // Remove ?pass= from URL without reload
            const url = new URL(window.location);
            url.searchParams.delete("pass");
            window.history.replaceState({}, "", url);
            return true;
          } else {
            const msg = passReasonMessages[body.reason] || `Pass redemption failed: ${body.reason || "unknown error"}`;
            showPassStatus(msg, "error");
            return false;
          }
        } catch (err) {
          showPassStatus(`Failed to redeem pass: ${err?.message || err}`, "error");
          return false;
        } finally {
          if (btn) { btn.textContent = "Redeem Pass"; btn.disabled = false; }
        }
      }

      // Pass form click handler
      document.getElementById("redeemPassBtn")?.addEventListener("click", async () => {
        const input = document.getElementById("passInput");
        const code = (input?.value || "").trim().toLowerCase();
        if (!code) {
          showPassStatus("Please enter a passphrase.", "error");
          return;
        }
        await redeemPassCode(code);
      });

      // Allow Enter key to submit
      document.getElementById("passInput")?.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          document.getElementById("redeemPassBtn")?.click();
        }
      });

      // --- initialize current bundles display
      setTimeout(() => {
        renderCurrentBundles();
      }, 100);

      // --- page init
      try {
        sessionStorage.removeItem("currentActivity");
      } catch {}

      // Initialize page - wait for submit.js module to be ready
      function initPage() {
        checkAuthStatus();

        // Handle ?pass= URL parameter
        const urlParams = new URLSearchParams(window.location.search);
        const passFromUrl = urlParams.get("pass");
        if (passFromUrl) {
          const input = document.getElementById("passInput");
          if (input) input.value = passFromUrl;
          // Auto-submit if authenticated
          if (getIdToken()) {
            redeemPassCode(passFromUrl.trim().toLowerCase());
          } else {
            try {
              sessionStorage.setItem("pendingPass", passFromUrl);
              sessionStorage.setItem("postLoginRedirect", window.location.pathname + "?pass=" + encodeURIComponent(passFromUrl));
            } catch {}
            showPassStatus("Please log in to redeem your pass.", "info");
          }
        } else {
          // Check for pending pass from previous session (saved before login redirect)
          try {
            const pendingPass = sessionStorage.getItem("pendingPass");
            if (pendingPass && getIdToken()) {
              const input = document.getElementById("passInput");
              if (input) input.value = pendingPass;
              redeemPassCode(pendingPass.trim().toLowerCase());
            }
          } catch {}
        }
      }

      if (window.__submitReady__) {
        initPage();
      } else {
        document.addEventListener("submit-ready", initPage, { once: true });
      }
    </script>
  </body>
</html>
