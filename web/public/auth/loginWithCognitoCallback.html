<!-- loginWithCognitoCallback.html -->
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>DIY Accounting Submit - Login with Google via Cognito callback</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../submit.css" />
    <!-- CloudWatch RUM configuration placeholders; replace values during deployment -->
    <meta name="rum:appMonitorId" content="${RUM_APP_MONITOR_ID}" />
    <meta name="rum:region" content="${AWS_REGION}" />
    <meta name="rum:identityPoolId" content="${RUM_IDENTITY_POOL_ID}" />
    <meta name="rum:guestRoleArn" content="${RUM_GUEST_ROLE_ARN}" />
    <script src="../lib/analytics.js"></script>
    <!-- HEAD-prefetch to help mitigate API cold starts for this page's calls -->
    <!--script async src="../prefetch/prefetch-cognito-token-head.js"></script-->
    <!--script async src="../prefetch/prefetch-bundle-head.js"></script-->
  </head>
  <body>
    <a href="#mainContent" class="skip-link">Skip to main content</a>
    <header>
      <div class="header-nav">
        <div class="header-left">
          <a href="../index.html" title="Home" class="home-link">
            <svg class="home-icon" viewBox="0 0 24 24" aria-hidden="true">
              <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" />
            </svg>
          </a>
          <a href="../about.html" title="About & Help" class="info-link">
            <svg class="info-icon" viewBox="0 0 24 24" aria-hidden="true">
              <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z" />
            </svg>
          </a>
        </div>
        <div class="auth-section">
          <span class="entitlement-status">Activity: unrestricted</span>
          <span class="login-status">Not logged in</span>
          <a href="../auth/login.html" class="login-link">Log in</a>
        </div>
      </div>
      <h1>DIY Accounting Submit - Login with Google via Cognito callback</h1>
      <p class="subtitle">Submit UK VAT returns to HMRC under Making Tax Digital (MTD)</p>
    </header>

    <main id="mainContent">
      <div id="statusMessagesContainer" role="alert" aria-live="polite"></div>

      <div id="loadingSpinner" class="spinner" style="display: none"></div>

      <div class="form-container" style="text-align: center">
        <h2 id="welcomeHeading">Welcome</h2>
        <p>Return home.</p>
        <button type="button" class="btn" onclick="window.location.href = '../index.html'">Home</button>
      </div>
    </main>

    <footer>
      <div class="footer-left">
        <a href="#" id="viewSourceLink" style="display: none">view source</a>
        <a id="latestTestsLink" style="display: inline" target="_blank" href="tests/index.html">tests</a>
        <a id="apiDocsLink" style="display: inline" target="_blank" href="../docs/api/index.html"> api </a>
        <a href="../privacy.html">privacy</a>
        <a href="../terms.html">terms</a>
        <a href="../accessibility.html">accessibility</a>
      </div>
      <div class="footer-content">
        <div class="footer-center">
          <p>&copy; 2025-2026 DIY Accounting Limited</p>
        </div>
      </div>
    </footer>

    <script src="../lib/env-loader.js"></script>
    <script>
      (async function () {
        try {
          await window.loadEnv();
        } catch (e) {
          console.warn("Failed to load environment:", e);
        }
      })();
    </script>
    <script type="module" src="../submit.js"></script>
    <script src="../lib/request-cache.js"></script>
    <script src="../lib/toml-parser.js"></script>
    <script src="../widgets/entitlement-status.js"></script>
    <script src="../widgets/auth-status.js"></script>
    <script src="../widgets/status-messages.js"></script>
    <script src="../widgets/loading-spinner.js"></script>
    <script>
      // Check for authentication callback
      function checkAuthCallback() {
        const urlParams = new URLSearchParams(window.location.search);
        const code = urlParams.get("code");
        const state = urlParams.get("state");
        const error = urlParams.get("error");
        const errorDescription = urlParams.get("error_description");

        if (code) {
          console.log("Authentication callback received with code:", code);
          handleAuthCallback(code, state);
        } else if (error || errorDescription) {
          console.error("OAuth error received:", error, errorDescription);
          showStatus(`Authentication error: ${errorDescription || error}`, "error");
        }
      }

      function base64UrlDecode(str) {
        // Replace URL-safe chars
        str = str.replace(/-/g, "+").replace(/_/g, "/");
        // Add padding if missing
        const pad = str.length % 4;
        if (pad) {
          str += "=".repeat(4 - pad);
        }
        return atob(str);
      }

      // Handle authentication callback from Cognito
      async function handleAuthCallback(code, state) {
        try {
          showLoading();

          // CRITICAL: Validate state parameter to prevent CSRF attacks
          // State must match what was stored in sessionStorage before redirect
          const storedState = sessionStorage.getItem("cognito_oauth_state");
          if (!state || state !== storedState) {
            console.error("OAuth state mismatch - possible CSRF attack", {
              receivedState: state ? state.substring(0, 8) + "..." : "none",
              hasStoredState: !!storedState,
            });
            showStatus("Security validation failed. Please try logging in again.", "error");
            sessionStorage.removeItem("cognito_oauth_state");
            hideLoading();
            return;
          }

          // Clear state immediately after validation (single use)
          sessionStorage.removeItem("cognito_oauth_state");

          showStatus("Exchanging authorization code for access token...", "info");

          const url = `/api/v1/cognito/token`;
          const body = {
            grant_type: "authorization_code",
            code: code,
          };
          console.log(`Exchanging token. Remote call initiated: POST ${url} ++ Body: ${body}`);

          const tokenResponse = await fetch(url, {
            method: "POST",
            headers: {
              "Content-Type": "application/x-www-form-urlencoded",
            },
            body: new URLSearchParams(body),
          });

          if (!tokenResponse.ok) {
            throw new Error("Failed to exchange authorization code for tokens");
          }

          const tokens = await tokenResponse.json();
          console.log("Received tokens from Cognito " + JSON.stringify(tokens));

          // Store tokens in localStorage (support both snake_case and camelCase fields)
          const accessToken = tokens.accessToken || tokens.access_token;
          const idToken = tokens.idToken || tokens.id_token;
          const refreshToken = tokens.refreshToken || tokens.refresh_token;

          if (accessToken) {
            localStorage.setItem("cognitoAccessToken", accessToken);
          }
          if (idToken) {
            localStorage.setItem("cognitoIdToken", idToken);
          }
          if (refreshToken) {
            localStorage.setItem("cognitoRefreshToken", refreshToken);
          }

          // Decode ID token to get user info
          if (!idToken) {
            throw new Error("Missing idToken in exchange-token response");
          }
          const base64Payload = idToken.split(".")[1];
          const jsonPayload = base64UrlDecode(base64Payload);
          const idTokenPayload = JSON.parse(jsonPayload);

          console.log("Received id_token from Cognito " + JSON.stringify(idTokenPayload));

          // Validate nonce to prevent replay attacks
          // The nonce in the ID token must match the one we stored before the redirect
          const storedNonce = sessionStorage.getItem("cognito_oauth_nonce");
          if (storedNonce) {
            if (!idTokenPayload.nonce || idTokenPayload.nonce !== storedNonce) {
              console.error("OAuth nonce mismatch - possible replay attack", {
                hasTokenNonce: !!idTokenPayload.nonce,
                hasStoredNonce: !!storedNonce,
              });
              showStatus("Security validation failed (nonce mismatch). Please try logging in again.", "error");
              sessionStorage.removeItem("cognito_oauth_nonce");
              hideLoading();
              return;
            }
            // Clear nonce after successful validation (single use)
            sessionStorage.removeItem("cognito_oauth_nonce");
          }

          // Handle optional email gracefully
          const userEmail = idTokenPayload.email;

          localStorage.setItem(
            "userInfo",
            JSON.stringify({
              sub: idTokenPayload.sub,
              email: userEmail,
              given_name: idTokenPayload.given_name,
              family_name: idTokenPayload.family_name,
            }),
          );

          console.log("User authenticated successfully using Cognito:", userEmail || "no email provided");
          // GA4: login event after successful Cognito authentication
          if (typeof gtag === "function") {
            gtag("event", "login", { method: "cognito" });
          }
          showStatus("Authenticated successfully. Fetching bundles...", "info");

          // Extract MFA status from the ID token
          // 1. Check amr (Authentication Methods Reference) claim — standard OIDC, provided by some IdPs
          // 2. Fallback: detect federated login via identities claim + auth_time
          //    Google and other federated IdPs enforce 2FA but don't expose amr in their tokens;
          //    Cognito includes identities and auth_time for federated users
          const amrClaims = idTokenPayload.amr || [];
          const mfaIndicators = ["mfa", "swk", "hwk", "otp"]; // mfa=multi-factor, swk=software key, hwk=hardware key, otp=one-time password
          const hasMFA = Array.isArray(amrClaims) && amrClaims.some((method) => mfaIndicators.includes(method));
          const isFederatedLogin = Array.isArray(idTokenPayload.identities) && idTokenPayload.identities.length > 0;
          const authTime = idTokenPayload.auth_time;

          // Generate a stable unique-reference for HMRC Gov-Client-Multi-Factor header.
          // HMRC requires: "Use the same hashing function consistently so that this can be
          // recognised across API calls." SHA-256(sub + ":" + factorType) gives a stable
          // identifier per user per MFA method. sub is already an opaque UUID (no PII).
          async function stableUniqueReference(sub, factorType) {
            const encoder = new TextEncoder();
            const data = encoder.encode(sub + ":" + factorType);
            const hashBuffer = await crypto.subtle.digest("SHA-256", data);
            return Array.from(new Uint8Array(hashBuffer))
              .map((b) => b.toString(16).padStart(2, "0"))
              .join("");
          }

          if (hasMFA) {
            // amr claims explicitly indicate MFA (e.g. Cognito native TOTP, or IdPs that provide amr)
            // Map specific amr claims to HMRC MFA type values:
            //   otp = TOTP authenticator app → type=TOTP
            //   mfa/swk/hwk = other MFA methods (federated IdP, security key) → type=OTHER
            const mfaType = amrClaims.includes("otp") ? "TOTP" : "OTHER";
            const mfaMetadata = {
              type: mfaType,
              timestamp: authTime ? new Date(authTime * 1000).toISOString() : new Date().toISOString(),
              uniqueReference: await stableUniqueReference(idTokenPayload.sub, mfaType),
            };
            sessionStorage.setItem("mfaMetadata", JSON.stringify(mfaMetadata));
            console.log("MFA detected from amr claims:", amrClaims, "type:", mfaType, "Stored metadata:", mfaMetadata);
          } else if (idTokenPayload["custom:mfa_method"] === "TOTP") {
            // Cognito native auth with TOTP MFA — detected via Pre Token Generation trigger
            // (Cognito doesn't populate amr for native TOTP, so this custom claim is the signal)
            const mfaMetadata = {
              type: "TOTP",
              timestamp: authTime ? new Date(authTime * 1000).toISOString() : new Date().toISOString(),
              uniqueReference: await stableUniqueReference(idTokenPayload.sub, "TOTP"),
            };
            sessionStorage.setItem("mfaMetadata", JSON.stringify(mfaMetadata));
            console.log("MFA detected from custom:mfa_method claim. type: TOTP. Stored metadata:", mfaMetadata);
          } else if (isFederatedLogin && authTime) {
            // Federated login (Google, etc.) — IdP handles MFA but doesn't expose amr;
            // use auth_time from the token as the authentication timestamp
            const providerNames = idTokenPayload.identities.map((id) => id.providerName || id.providerType).join(", ");
            const mfaMetadata = {
              type: "OTHER",
              timestamp: new Date(authTime * 1000).toISOString(),
              uniqueReference: await stableUniqueReference(idTokenPayload.sub, "OTHER"),
            };
            sessionStorage.setItem("mfaMetadata", JSON.stringify(mfaMetadata));
            console.log("MFA inferred from federated login (" + providerNames + "), auth_time:", authTime, "Stored metadata:", mfaMetadata);
          } else {
            // No MFA detected - remove any existing metadata
            sessionStorage.removeItem("mfaMetadata");
            console.log("No MFA detected. amr:", amrClaims, "federated:", isFederatedLogin, "auth_time:", authTime);
          }

          // Store login provider for logout flow (Google logout requires extra redirect)
          if (isFederatedLogin) {
            var providerName = idTokenPayload.identities[0].providerName || idTokenPayload.identities[0].providerType;
            localStorage.setItem("loginProvider", providerName);
          } else {
            localStorage.setItem("loginProvider", "cognito");
          }

          // No longer store bundles in localStorage; bundles will be fetched by pages as needed from /api/v1/bundle
          showStatus("Authenticated successfully. Redirecting...", "info");

          // Clear URL parameters
          window.history.replaceState({}, document.title, window.location.pathname);

          // Redirect to stored return URL (e.g. bundles.html?pass=CODE) or home
          let redirectUrl = "../index.html";
          try {
            const postLoginRedirect = sessionStorage.getItem("postLoginRedirect");
            if (postLoginRedirect) {
              sessionStorage.removeItem("postLoginRedirect");
              redirectUrl = "../" + postLoginRedirect;
            }
          } catch {}
          window.location.href = redirectUrl;
        } catch (error) {
          console.error("Authentication callback error:", error);
          showStatus(`Authentication failed: ${error.message}`, "error");
        } finally {
          hideLoading();
        }
      }

      // Check if this page was loaded as a callback from authentication
      checkAuthCallback();
    </script>
  </body>
</html>
