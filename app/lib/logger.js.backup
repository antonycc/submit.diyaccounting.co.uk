// SPDX-License-Identifier: AGPL-3.0-only
// Copyright (C) 2025-2026 DIY Accounting Ltd

// app/lib/logger.js

import fs from "fs";
import path from "path";
import pino from "pino";
import { AsyncLocalStorage } from "node:async_hooks";
import { dotenvConfigIfNotBlank } from "./env.js";

dotenvConfigIfNotBlank({ path: ".env" });

// Configure pino logger to mimic previous Winston behaviours controlled by env vars:
// - LOG_TO_CONSOLE: enable console logging when not set to "false" (default on)
// - LOG_TO_FILE: enable file logging only when set to "true" (default off)
// - LOG_FILE_PATH: optional explicit file path; otherwise default to ./target/submit-<ISO>.log
// - LOG_LEVEL: set minimum log level (trace, debug, info, warn, error, fatal) (default: info)

const logToConsole = process.env.LOG_TO_CONSOLE !== "false"; // default on
const logToFile = process.env.LOG_TO_FILE === "true"; // default off

// Validate and get log level from environment
const VALID_LOG_LEVELS = ["trace", "debug", "info", "warn", "error", "fatal"];
const envLogLevel = (process.env.LOG_LEVEL || "info").toLowerCase();
const logLevel = VALID_LOG_LEVELS.includes(envLogLevel) ? envLogLevel : "info";

let destinationStream;

export function createLogger(bindings = {}) {
  return logger.child(bindings);
}

if (logToConsole && logToFile) {
  // Both console and file
  const timestamp = new Date().toISOString().replace(/:/g, "-");
  const defaultPath = `./target/submit-${timestamp}.log`;
  const logFilePath = process.env.LOG_FILE_PATH || defaultPath;

  // Ensure directory exists
  const dir = path.dirname(logFilePath);
  try {
    fs.mkdirSync(dir, { recursive: true });
  } catch {
    // ignore mkdir errors; pino will throw on write if truly unusable
  }

  const streams = [{ stream: process.stdout }, { stream: pino.destination({ dest: logFilePath, sync: false }) }];
  destinationStream = pino.multistream(streams);
} else if (logToConsole) {
  // Console only (default)
  destinationStream = process.stdout;
} else if (logToFile) {
  // File only
  const timestamp = new Date().toISOString().replace(/:/g, "-");
  const defaultPath = `./target/submit-${timestamp}.log`;
  const logFilePath = process.env.LOG_FILE_PATH || defaultPath;

  const dir = path.dirname(logFilePath);
  try {
    fs.mkdirSync(dir, { recursive: true });
  } catch (error) {
    console.error(`Failed to create log directory ${dir}:`, error);
  }

  destinationStream = pino.destination({ dest: logFilePath, sync: false });
}

/**
 * PII (Personally Identifiable Information) Protection Patterns
 * 
 * This logger implements two layers of PII protection:
 * 1. Pino's built-in `redact` option for field-path based redaction
 * 2. Regex-based sanitisation for pattern matching in string values
 * 
 * Protected patterns and their sources in the codebase:
 * 
 * 1. VAT Registration Numbers (VRN): 9-digit format
 *    - Source: app/lib/hmrcValidation.js, HMRC API handlers
 *    - Example: "123456789"
 * 
 * 2. Email Addresses: Standard email format
 *    - Source: JWT claims, Cognito auth, test fixtures
 *    - Example: "user@example.com"
 * 
 * 3. Tokens & Secrets: OAuth tokens, API keys, client secrets
 *    - Source: app/lib/dataMasking.js, OAuth flows
 *    - Field names: access_token, refresh_token, client_secret, authorization
 * 
 * 4. Passwords: All password fields
 *    - Source: app/lib/dataMasking.js
 *    - Field names: password, hmrcTestPassword, userPassword
 * 
 * 5. User Identifiers: Cognito subject identifiers
 *    - Source: app/lib/jwtHelper.js, app/services/subHasher.js
 *    - Field names: sub, cognito:username
 * 
 * 6. IP Addresses: IPv4 and IPv6
 *    - Source: app/lib/hmrcValidation.js, fraud prevention headers
 *    - Field names: Gov-Client-Public-IP, Gov-Vendor-Public-IP
 * 
 * 7. Device IDs: Long alphanumeric device identifiers
 *    - Source: app/lib/hmrcValidation.js, fraud prevention headers
 *    - Field names: Gov-Client-Device-ID
 * 
 * 8. Authorization Headers: Bearer tokens, cookies
 *    - Source: HTTP requests
 *    - Field names: authorization, cookie, set-cookie
 * 
 * 9. OAuth Authorization Codes: 32-char hex codes
 *    - Source: app/lib/dataMasking.js, OAuth callback flows
 */

// Sensitive field paths to redact (Pino redact configuration)
const REDACT_PATHS = [
  // Tokens and secrets
  "*.access_token",
  "*.refresh_token",
  "*.client_secret",
  "*.clientSecret",
  "*.code", // OAuth authorization codes
  "*.password",
  "*.userPassword",
  "*.hmrcTestPassword",
  "*.hmrctestpassword",
  
  // Authorization headers
  "*.authorization",
  "*.Authorization",
  "req.headers.authorization",
  "req.headers.Authorization",
  "req.headers.cookie",
  "req.headers.Cookie",
  "req.headers['set-cookie']",
  "headers.authorization",
  "headers.Authorization",
  "headers.cookie",
  "headers.Cookie",
  "headers['set-cookie']",
  
  // User identifiers
  "*.sub",
  "*.email",
  "*.cognito:username",
  "claims.sub",
  "claims.email",
  "claims['cognito:username']",
  "jwt.claims.sub",
  "jwt.claims.email",
  "jwt.claims['cognito:username']",
  
  // HMRC-specific sensitive fields
  "*.vrn",
  "*.VRN",
  "*.vatNumber",
  "*.Gov-Client-Device-ID",
  "*.Gov-Client-Public-IP",
  "*.Gov-Vendor-Public-IP",
  "headers['Gov-Client-Device-ID']",
  "headers['Gov-Client-Public-IP']",
  "headers['Gov-Vendor-Public-IP']",
];

// Regex patterns for sanitising string values
const PII_PATTERNS = [
  // VRN: 9 consecutive digits (with word boundaries to avoid false positives)
  { pattern: /\b\d{9}\b/g, replacement: "[VRN]" },
  
  // Email addresses (simplified but effective pattern)
  { pattern: /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g, replacement: "[EMAIL]" },
  
  // IPv4 addresses
  { pattern: /\b(?:\d{1,3}\.){3}\d{1,3}\b/g, replacement: "[IP]" },
  
  // IPv6 addresses (simplified pattern for common formats)
  { pattern: /\b(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}\b/g, replacement: "[IP]" },
  { pattern: /\b(?:[0-9a-fA-F]{1,4}:){1,7}:\b/g, replacement: "[IP]" },
  { pattern: /\b::(?:[0-9a-fA-F]{1,4}:){0,6}[0-9a-fA-F]{1,4}\b/g, replacement: "[IP]" },
  
  // Bearer tokens (JWT format: xxx.yyy.zzz)
  { pattern: /Bearer\s+[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]*/gi, replacement: "Bearer [TOKEN]" },
  
  // UUID format (for sub, device IDs, etc.)
  { pattern: /\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\b/gi, replacement: "[UUID]" },
  
  // OAuth authorization codes (32-char hex)
  { pattern: /\bcode=[a-f0-9]{32}\b/gi, replacement: "code=[CODE]" },
  
  // Long alphanumeric tokens (40+ chars, likely sensitive)
  { pattern: /\b[A-Za-z0-9_-]{40,}\b/g, replacement: "[TOKEN]" },
];

/**
 * Recursively sanitise an object by replacing PII patterns in string values
 * @param {*} obj - Object to sanitise
 * @param {Set} visited - Set of visited objects for circular reference detection
 * @returns {*} Sanitised copy of the object
 */
function sanitise(obj, visited = new Set()) {
  // Handle primitives
  if (obj === null || obj === undefined) {
    return obj;
  }
  
  if (typeof obj === "string") {
    // Apply all regex patterns to the string
    let sanitised = obj;
    for (const { pattern, replacement } of PII_PATTERNS) {
      sanitised = sanitised.replace(pattern, replacement);
    }
    return sanitised;
  }
  
  if (typeof obj !== "object") {
    return obj;
  }
  
  // Detect circular references
  if (visited.has(obj)) {
    return "[Circular]";
  }
  
  visited.add(obj);
  
  try {
    // Handle arrays
    if (Array.isArray(obj)) {
      return obj.map((item) => sanitise(item, visited));
    }
    
    // Handle objects
    const sanitised = {};
    for (const [key, value] of Object.entries(obj)) {
      sanitised[key] = sanitise(value, visited);
    }
    return sanitised;
  } finally {
    visited.delete(obj);
  }
}

// If neither console nor file are enabled, produce a disabled logger (no output)
export const logger = pino(
  {
    level: logLevel,
    // timestamp: pino.stdTimeFunctions.isoTime,
    enabled: Boolean(destinationStream),
    base: null, // removes pid and hostname
    timestamp: false, // Avoid Pinoâ€™s comma-prefixed timestamp chunk
    // Add an ISO time field as a normal JSON property
    mixin() {
      // Pull correlation fields from shared context; ensure we never leak old values
      const store = context.getStore();
      const requestId = store?.get("requestId") || null;

      const amznTraceId = store?.get("amznTraceId") || null;

      const traceparent = store?.get("traceparent") || null;

      const correlationId = store?.get("correlationId") || null;
      return {
        time: new Date().toISOString(),
        ...(requestId ? { requestId } : {}),
        ...(amznTraceId ? { amznTraceId } : {}),
        ...(traceparent ? { traceparent } : {}),
        ...(correlationId ? { correlationId } : {}),
      };
    },
    // formatters: {
    // remove the level key entirely
    //  level: () => ({}),
    // },
    // transport: { target: "pino-pretty", options: { translateTime: "SYS:standard" } },
  },
  destinationStream,
);

// Store for contextual information such as a request ID
// export const context = new Map();
export const storage = new AsyncLocalStorage();
export const context = {
  get: (key) => storage.getStore()?.get(key),
  set: (key, value) => {
    const store = storage.getStore();
    if (store) {
      store.set(key, value);
    }
  },
  run: (store, callback) => storage.run(store, callback),
  getStore: () => storage.getStore(),
  enterWith: (store) => storage.enterWith(store),
};
export default logger;
