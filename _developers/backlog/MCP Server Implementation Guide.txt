Content is user-generated and unverified. Customize MCP Server Implementation Guide for DIY Accounting Submit 
 Target Audience: Claude Code 
 Repository: submit.diyaccounting.co.uk 
 Date: 2026-01-30 

 Table of Contents 

 Overview 
 Architecture Design 
 Session Storage Abstraction 
 MCP Tool Schemas 
 Testing Strategy 
 Rollout Strategy 
 Implementation Checklist 

 Overview 
 Goal 
 Build an MCP (Model Context Protocol) server that allows Claude Desktop users to interact with the DIY Accounting Submit API for UK VAT submissions. The MCP server will: 

 Reuse 90% of existing Lambda handler code 
 Support token-based pricing tiers 
 Provide authentication via OIDC 
 Enable AI-driven VAT workflows 

 Value Proposition 

 For technical users: Automate VAT filing through Claude conversations 
 For the business: New distribution channel targeting developers and technical accountants 
 For future expansion: Foundation for EU ViDA/Peppol integration 

 Key Principles 

 Reuse existing code - MCP server is just a new interface to existing Lambda handlers 
 Abstract session management - Share session logic between web client, MCP, and future platforms 
 Minimal new code - Build thin adapter layers, not new business logic 

 Architecture Design 
 High-Level Architecture 
 ┌─────────────────┐
 │ Claude Desktop │
 │ (MCP Client) │
 └────────┬────────┘
 │ MCP Protocol (stdio)
 ↓
 ┌─────────────────────────────────────────┐
 │ MCP Server Container (Docker) │
 │ ┌───────────────────────────────────┐ │
 │ │ app/bin/mcp-server.js │ │ ← NEW entry point
 │ ├───────────────────────────────────┤ │
 │ │ app/lib/mcpToLambdaAdaptor.js │ │ ← NEW adapter
 │ ├───────────────────────────────────┤ │
 │ │ app/lib/SessionManager.js │ │ ← NEW (extracted)
 │ ├───────────────────────────────────┤ │
 │ │ app/lib/storage/ │ │ ← NEW storage backends
 │ │ ├── StorageInterface.js │ │
 │ │ ├── MemoryStorage.js │ │
 │ │ ├── BrowserStorage.js │ │
 │ │ └── DynamoDBStorage.js │ │
 │ ├───────────────────────────────────┤ │
 │ │ app/mcp/tools/ │ │ ← NEW tool definitions
 │ │ ├── index.js │ │
 │ │ ├── authenticate.js │ │
 │ │ ├── submitVatReturn.js │ │
 │ │ ├── getVatObligations.js │ │
 │ │ ├── getReceipts.js │ │
 │ │ └── checkTokenBalance.js │ │
 │ ├───────────────────────────────────┤ │
 │ │ EXISTING CODE (REUSED): │ │
 │ │ app/functions/ (Lambda handlers) │ │ ← REUSE
 │ │ app/services/ (business logic) │ │ ← REUSE
 │ │ app/data/ (DynamoDB repos) │ │ ← REUSE
 │ │ app/lib/ (logger, JWT, HTTP) │ │ ← REUSE
 │ └───────────────────────────────────┘ │
 └─────────────┬───────────────────────────┘
 │ REST API + OIDC
 ↓
 ┌─────────────────────────────────────────┐
 │ Existing API Backend │
 │ (Lambda + DynamoDB + Cognito) │
 └─────────────────────────────────────────┘ 
 What Gets Reused vs Built New 
 REUSE (90%): 

 ✅ All Lambda handlers in app/functions/ 
 ✅ All business logic in app/services/ 
 ✅ Authentication logic (JWT validation, token exchange) 
 ✅ DynamoDB repositories in app/data/ 
 ✅ Logger, HTTP helpers in app/lib/ 
 ✅ Async request patterns 

 NEW (10%): 

 MCP server entry point ( app/bin/mcp-server.js ) 
 MCP to Lambda adaptor ( app/lib/mcpToLambdaAdaptor.js ) 
 MCP tool definitions ( app/mcp/tools/ ) 
 Session storage abstraction (extracted from web widgets) 
 Dockerfile for MCP server 

 Session Storage Abstraction 
 Design Pattern 
 Create a storage abstraction layer that can be used across: 

 Web client (browser localStorage/sessionStorage) 
 MCP server (in-memory Map) 
 Future distributed MCP (DynamoDB) 

 Directory Structure 
 app/lib/storage/
 ├── StorageInterface.js # Base interface contract
 ├── BrowserStorage.js # For web client
 ├── MemoryStorage.js # For MCP server
 └── DynamoDBStorage.js # For distributed MCP (future)

 app/lib/
 └── SessionManager.js # Unified session management 
 StorageInterface.js 
 javascript /**
 * Abstract storage interface that can be implemented for different backends
 */ 
 export class StorageInterface { 
 async get ( key ) { 
 throw new Error ( 'get() must be implemented' ) ; 
 } 

 async set ( key , value , options = { } ) { 
 throw new Error ( 'set() must be implemented' ) ; 
 } 

 async delete ( key ) { 
 throw new Error ( 'delete() must be implemented' ) ; 
 } 

 async has ( key ) { 
 throw new Error ( 'has() must be implemented' ) ; 
 } 

 async clear ( ) { 
 throw new Error ( 'clear() must be implemented' ) ; 
 } 
 } 
 MemoryStorage.js (Primary Implementation) 
 javascript import { StorageInterface } from './StorageInterface.js' ; 

 /**
 * In-memory storage for MCP server
 * Fast, simple, but data lost on process restart
 */ 
 export class MemoryStorage extends StorageInterface { 
 constructor ( ) { 
 super ( ) ; 
 this . store = new Map ( ) ; 
 this . timers = new Map ( ) ; 
 } 

 async get ( key ) { 
 const item = this . store . get ( key ) ; 
 if ( ! item ) return null ; 

 // Check if expired 
 if ( item . expiresAt && Date . now ( ) > item . expiresAt ) { 
 await this . delete ( key ) ; 
 return null ; 
 } 

 return item . value ; 
 } 

 async set ( key , value , options = { } ) { 
 const item = { 
 value , 
 createdAt : Date . now ( ) 
 } ; 

 if ( options . ttl ) { 
 item . expiresAt = Date . now ( ) + ( options . ttl * 1000 ) ; 

 // Clear existing timer 
 if ( this . timers . has ( key ) ) { 
 clearTimeout ( this . timers . get ( key ) ) ; 
 } 

 // Set auto-delete timer 
 const timer = setTimeout ( ( ) => { 
 this . delete ( key ) ; 
 } , options . ttl * 1000 ) ; 

 this . timers . set ( key , timer ) ; 
 } 

 this . store . set ( key , item ) ; 
 } 

 async delete ( key ) { 
 if ( this . timers . has ( key ) ) { 
 clearTimeout ( this . timers . get ( key ) ) ; 
 this . timers . delete ( key ) ; 
 } 

 const existed = this . store . has ( key ) ; 
 this . store . delete ( key ) ; 
 return existed ; 
 } 

 async has ( key ) { 
 const value = await this . get ( key ) ; 
 return value !== null ; 
 } 

 async clear ( ) { 
 this . timers . forEach ( timer => clearTimeout ( timer ) ) ; 
 this . timers . clear ( ) ; 
 this . store . clear ( ) ; 
 } 

 size ( ) { 
 return this . store . size ; 
 } 
 } 
 SessionManager.js 
 javascript import { logger } from './logger.js' ; 

 /**
 * Unified session management across web, MCP, and Lambda
 * Uses dependency injection for storage backend
 */ 
 export class SessionManager { 
 constructor ( storage ) { 
 this . storage = storage ; 
 } 

 // TOKEN MANAGEMENT 
 async getAccessToken ( ) { 
 return await this . storage . get ( 'access_token' ) ; 
 } 

 async setAccessToken ( token , expiresIn ) { 
 const ttl = expiresIn || 3600 ; 
 await this . storage . set ( 'access_token' , token , { ttl } ) ; 
 } 

 async getRefreshToken ( ) { 
 return await this . storage . get ( 'refresh_token' ) ; 
 } 

 async setRefreshToken ( token ) { 
 const ttl = 30 * 24 * 60 * 60 ; // 30 days 
 await this . storage . set ( 'refresh_token' , token , { ttl } ) ; 
 } 

 async clearTokens ( ) { 
 await this . storage . delete ( 'access_token' ) ; 
 await this . storage . delete ( 'refresh_token' ) ; 
 } 

 async hasValidAccessToken ( ) { 
 const token = await this . getAccessToken ( ) ; 
 return token !== null ; 
 } 

 // USER INFORMATION 
 async getUserSub ( ) { 
 return await this . storage . get ( 'user_sub' ) ; 
 } 

 async setUserSub ( sub ) { 
 await this . storage . set ( 'user_sub' , sub ) ; 
 } 

 async getUserEmail ( ) { 
 return await this . storage . get ( 'user_email' ) ; 
 } 

 async setUserEmail ( email ) { 
 await this . storage . set ( 'user_email' , email ) ; 
 } 

 async setUserInfo ( userInfo ) { 
 await this . setUserSub ( userInfo . sub ) ; 
 await this . setUserEmail ( userInfo . email ) ; 
 if ( userInfo . name ) { 
 await this . storage . set ( 'user_name' , userInfo . name ) ; 
 } 
 } 

 // TOKEN USAGE TRACKING (for tiered system) 
 async getTokenUsage ( ) { 
 const usage = await this . storage . get ( 'token_usage' ) ; 
 return usage || { used : 0 , limit : null , tier : 'guest' } ; 
 } 

 async setTokenUsage ( usage ) { 
 await this . storage . set ( 'token_usage' , usage ) ; 
 } 

 async incrementTokenUsage ( count = 1 ) { 
 const usage = await this . getTokenUsage ( ) ; 
 usage . used += count ; 
 await this . setTokenUsage ( usage ) ; 
 return usage ; 
 } 

 async resetTokenUsage ( ) { 
 await this . storage . set ( 'token_usage' , { 
 used : 0 , 
 limit : null , 
 tier : 'guest' 
 } ) ; 
 } 

 // OAUTH STATE (for CSRF protection) 
 async getOAuthState ( ) { 
 return await this . storage . get ( 'oauth_state' ) ; 
 } 

 async setOAuthState ( state ) { 
 await this . storage . set ( 'oauth_state' , state , { ttl : 300 } ) ; 
 } 

 async clearOAuthState ( ) { 
 await this . storage . delete ( 'oauth_state' ) ; 
 } 

 // ASYNC REQUEST TRACKING 
 async setAsyncRequestId ( operation , requestId ) { 
 const key = ` async_request_ ${ operation } ` ; 
 await this . storage . set ( key , requestId , { ttl : 300 } ) ; 
 } 

 async getAsyncRequestId ( operation ) { 
 const key = ` async_request_ ${ operation } ` ; 
 return await this . storage . get ( key ) ; 
 } 

 async clearAsyncRequestId ( operation ) { 
 const key = ` async_request_ ${ operation } ` ; 
 await this . storage . delete ( key ) ; 
 } 

 // SESSION MANAGEMENT 
 async isAuthenticated ( ) { 
 return await this . hasValidAccessToken ( ) ; 
 } 

 async clearSession ( ) { 
 await this . storage . clear ( ) ; 
 logger . info ( 'Session cleared' ) ; 
 } 
 } 
 BrowserStorage.js (Extract from Web Widgets) 
 javascript import { StorageInterface } from './StorageInterface.js' ; 

 /**
 * Browser localStorage/sessionStorage implementation
 * Extract and replace logic currently in web widgets
 */ 
 export class BrowserStorage extends StorageInterface { 
 constructor ( storageType = 'localStorage' ) { 
 super ( ) ; 
 this . storage = storageType === 'sessionStorage' 
 ? window . sessionStorage 
 : window . localStorage ; 
 this . prefix = 'diy_submit_' ; 
 } 

 _makeKey ( key ) { 
 return ` ${ this . prefix } ${ key } ` ; 
 } 

 async get ( key ) { 
 try { 
 const item = this . storage . getItem ( this . _makeKey ( key ) ) ; 
 if ( ! item ) return null ; 

 const parsed = JSON . parse ( item ) ; 

 if ( parsed . expiresAt && Date . now ( ) > parsed . expiresAt ) { 
 await this . delete ( key ) ; 
 return null ; 
 } 

 return parsed . value ; 
 } catch ( error ) { 
 console . error ( ` Error getting ${ key } : ` , error ) ; 
 return null ; 
 } 
 } 

 async set ( key , value , options = { } ) { 
 try { 
 const item = { 
 value , 
 createdAt : Date . now ( ) 
 } ; 

 if ( options . ttl ) { 
 item . expiresAt = Date . now ( ) + ( options . ttl * 1000 ) ; 
 } 

 this . storage . setItem ( this . _makeKey ( key ) , JSON . stringify ( item ) ) ; 
 } catch ( error ) { 
 console . error ( ` Error setting ${ key } : ` , error ) ; 
 throw error ; 
 } 
 } 

 async delete ( key ) { 
 try { 
 const fullKey = this . _makeKey ( key ) ; 
 const existed = this . storage . getItem ( fullKey ) !== null ; 
 this . storage . removeItem ( fullKey ) ; 
 return existed ; 
 } catch ( error ) { 
 console . error ( ` Error deleting ${ key } : ` , error ) ; 
 return false ; 
 } 
 } 

 async has ( key ) { 
 const value = await this . get ( key ) ; 
 return value !== null ; 
 } 

 async clear ( ) { 
 const keys = [ ] ; 
 for ( let i = 0 ; i < this . storage . length ; i ++ ) { 
 const key = this . storage . key ( i ) ; 
 if ( key ?. startsWith ( this . prefix ) ) { 
 keys . push ( key ) ; 
 } 
 } 
 keys . forEach ( key => this . storage . removeItem ( key ) ) ; 
 } 
 } 

 MCP Tool Schemas 
 Tool Index 
 javascript // app/mcp/tools/index.js 
 import { authenticateTool } from './authenticate.js' ; 
 import { submitVatReturnTool } from './submitVatReturn.js' ; 
 import { getVatObligationsTool } from './getVatObligations.js' ; 
 import { getReceiptsTool } from './getReceipts.js' ; 
 import { checkTokenBalanceTool } from './checkTokenBalance.js' ; 
 import { pollVatReturnTool } from './pollVatReturn.js' ; 

 export const tools = [ 
 authenticateTool , 
 submitVatReturnTool , 
 pollVatReturnTool , 
 getVatObligationsTool , 
 getReceiptsTool , 
 checkTokenBalanceTool
 ] ; 
 Tool 1: Authenticate 
 javascript // app/mcp/tools/authenticate.js 
 export const authenticateTool = { 
 name : 'authenticate' , 
 description : 'Authenticate with DIY Accounting Submit using OAuth2. Call without params to get auth URL, then call with authorization code.' , 
 inputSchema : { 
 type : 'object' , 
 properties : { 
 authorizationCode : { 
 type : 'string' , 
 description : 'OAuth authorization code (optional - omit to get auth URL)' 
 } 
 } 
 } , 

 async handler ( params , context ) { 
 const { sessionManager , config , lambdaHandlers } = context ; 

 // If no code, return authorization URL 
 if ( ! params . authorizationCode ) { 
 const state = crypto . randomUUID ( ) ; 
 await sessionManager . setOAuthState ( state ) ; 

 const authUrl = new URL ( ` ${ config . COGNITO_DOMAIN } /oauth2/authorize ` ) ; 
 authUrl . searchParams . set ( 'client_id' , config . COGNITO_CLIENT_ID ) ; 
 authUrl . searchParams . set ( 'response_type' , 'code' ) ; 
 authUrl . searchParams . set ( 'redirect_uri' , config . REDIRECT_URI ) ; 
 authUrl . searchParams . set ( 'state' , state ) ; 
 authUrl . searchParams . set ( 'scope' , 'openid email profile' ) ; 

 return { 
 authorizationUrl : authUrl . toString ( ) , 
 instructions : 'Visit this URL in your browser, authorize, then provide the code from redirect URL.' 
 } ; 
 } 

 // Exchange code for tokens 
 const event = { 
 httpMethod : 'POST' , 
 path : '/auth/token/exchange' , 
 headers : { 'Content-Type' : 'application/json' } , 
 body : JSON . stringify ( { code : params . authorizationCode } ) 
 } ; 

 const result = await lambdaHandlers . tokenExchange ( event , { } ) ; 
 const tokens = JSON . parse ( result . body ) ; 

 if ( result . statusCode !== 200 ) { 
 throw new Error ( tokens . message || 'Authentication failed' ) ; 
 } 

 // Store tokens 
 await sessionManager . setAccessToken ( tokens . access_token , tokens . expires_in ) ; 
 await sessionManager . setRefreshToken ( tokens . refresh_token ) ; 

 // Decode and store user info 
 const userInfo = JSON . parse ( atob ( tokens . access_token . split ( '.' ) [ 1 ] ) ) ; 
 await sessionManager . setUserInfo ( { 
 sub : userInfo . sub , 
 email : userInfo . email 
 } ) ; 

 return { 
 success : true , 
 message : ` Authenticated as ${ userInfo . email } ` , 
 expiresIn : tokens . expires_in 
 } ; 
 } 
 } ; 
 Tool 2: Submit VAT Return 
 javascript // app/mcp/tools/submitVatReturn.js 
 export const submitVatReturnTool = { 
 name : 'submit_vat_return' , 
 description : 'Submit a VAT return to HMRC. Returns request ID for polling.' , 
 inputSchema : { 
 type : 'object' , 
 properties : { 
 periodKey : { 
 type : 'string' , 
 description : 'VAT period key (e.g., #001)' , 
 pattern : '^#\\\\d{3}$' 
 } , 
 vatDueSales : { type : 'number' , minimum : 0 } , 
 vatDueAcquisitions : { type : 'number' , minimum : 0 } , 
 totalVatDue : { type : 'number' , minimum : 0 } , 
 vatReclaimedCurrPeriod : { type : 'number' , minimum : 0 } , 
 netVatDue : { type : 'number' } , 
 totalValueSalesExVAT : { type : 'integer' , minimum : 0 } , 
 totalValuePurchasesExVAT : { type : 'integer' , minimum : 0 } , 
 totalValueGoodsSuppliedExVAT : { type : 'integer' , minimum : 0 } , 
 totalAcquisitionsExVAT : { type : 'integer' , minimum : 0 } , 
 finalised : { type : 'boolean' , default : true } 
 } , 
 required : [ 
 'periodKey' , 'vatDueSales' , 'vatDueAcquisitions' , 
 'totalVatDue' , 'vatReclaimedCurrPeriod' , 'netVatDue' , 
 'totalValueSalesExVAT' , 'totalValuePurchasesExVAT' , 
 'totalValueGoodsSuppliedExVAT' , 'totalAcquisitionsExVAT' 
 ] 
 } , 

 async handler ( params , context ) { 
 const { sessionManager , adaptor } = context ; 

 const accessToken = await sessionManager . getAccessToken ( ) ; 
 if ( ! accessToken ) { 
 throw new Error ( 'Not authenticated' ) ; 
 } 

 const event = { 
 httpMethod : 'POST' , 
 path : '/hmrc/vat/return' , 
 headers : { 
 'Authorization' : ` Bearer ${ accessToken } ` , 
 'Content-Type' : 'application/json' 
 } , 
 body : JSON . stringify ( params ) 
 } ; 

 const result = await adaptor . invokeLambda ( 'submitVatReturn' , event ) ; 
 const response = JSON . parse ( result . body ) ; 

 const usage = await sessionManager . incrementTokenUsage ( 1 ) ; 

 if ( response . requestId ) { 
 await sessionManager . setAsyncRequestId ( 'vat_return' , response . requestId ) ; 
 } 

 return { 
 requestId : response . requestId , 
 status : 'submitted' , 
 message : 'Use poll_vat_return to check status' , 
 tokenUsage : usage
 } ; 
 } 
 } ; 
 Tool 3: Poll VAT Return 
 javascript // app/mcp/tools/pollVatReturn.js 
 export const pollVatReturnTool = { 
 name : 'poll_vat_return' , 
 description : 'Check status of VAT return submission' , 
 inputSchema : { 
 type : 'object' , 
 properties : { 
 requestId : { 
 type : 'string' , 
 description : 'Request ID (optional - uses last submission if omitted)' 
 } 
 } 
 } , 

 async handler ( params , context ) { 
 const { sessionManager , adaptor } = context ; 

 let requestId = params . requestId ; 
 if ( ! requestId ) { 
 requestId = await sessionManager . getAsyncRequestId ( 'vat_return' ) ; 
 if ( ! requestId ) { 
 throw new Error ( 'No pending VAT return found' ) ; 
 } 
 } 

 const accessToken = await sessionManager . getAccessToken ( ) ; 

 const event = { 
 httpMethod : 'GET' , 
 path : ` /hmrc/vat/return/ ${ requestId } ` , 
 headers : { 
 'Authorization' : ` Bearer ${ accessToken } ` 
 } 
 } ; 

 const result = await adaptor . invokeLambda ( 'getVatReturn' , event ) ; 
 const response = JSON . parse ( result . body ) ; 

 if ( response . status === 'completed' || response . status === 'failed' ) { 
 await sessionManager . clearAsyncRequestId ( 'vat_return' ) ; 
 } 

 return response ; 
 } 
 } ; 
 Tool 4: Get VAT Obligations 
 javascript // app/mcp/tools/getVatObligations.js 
 export const getVatObligationsTool = { 
 name : 'get_vat_obligations' , 
 description : 'Retrieve VAT obligations from HMRC' , 
 inputSchema : { 
 type : 'object' , 
 properties : { 
 from : { 
 type : 'string' , 
 description : 'Start date (YYYY-MM-DD)' , 
 pattern : '^\\\\d{4}-\\\\d{2}-\\\\d{2}$' 
 } , 
 to : { 
 type : 'string' , 
 description : 'End date (YYYY-MM-DD)' , 
 pattern : '^\\\\d{4}-\\\\d{2}-\\\\d{2}$' 
 } , 
 status : { 
 type : 'string' , 
 enum : [ 'O' , 'F' ] , 
 default : 'O' 
 } 
 } , 
 required : [ 'from' , 'to' ] 
 } , 

 async handler ( params , context ) { 
 const { sessionManager , adaptor } = context ; 

 const accessToken = await sessionManager . getAccessToken ( ) ; 

 const event = { 
 httpMethod : 'GET' , 
 path : '/hmrc/vat/obligations' , 
 headers : { 
 'Authorization' : ` Bearer ${ accessToken } ` 
 } , 
 queryStringParameters : params
 } ; 

 const result = await adaptor . invokeLambda ( 'getVatObligations' , event ) ; 
 const response = JSON . parse ( result . body ) ; 

 const usage = await sessionManager . incrementTokenUsage ( 1 ) ; 

 return { 
 obligations : response . obligations , 
 tokenUsage : usage
 } ; 
 } 
 } ; 
 Tool 5: Get Receipts 
 javascript // app/mcp/tools/getReceipts.js 
 export const getReceiptsTool = { 
 name : 'get_receipts' , 
 description : 'Retrieve HMRC submission receipts' , 
 inputSchema : { 
 type : 'object' , 
 properties : { 
 receiptId : { 
 type : 'string' , 
 description : 'Specific receipt ID (optional)' 
 } , 
 limit : { 
 type : 'integer' , 
 minimum : 1 , 
 maximum : 100 , 
 default : 20 
 } 
 } 
 } , 

 async handler ( params , context ) { 
 const { sessionManager , adaptor } = context ; 

 const accessToken = await sessionManager . getAccessToken ( ) ; 

 const path = params . receiptId 
 ? ` /hmrc/receipt/ ${ params . receiptId } ` 
 : '/hmrc/receipt/receipts' ; 

 const event = { 
 httpMethod : 'GET' , 
 path , 
 headers : { 
 'Authorization' : ` Bearer ${ accessToken } ` 
 } , 
 queryStringParameters : params . receiptId ? { } : { limit : params . limit } 
 } ; 

 const result = await adaptor . invokeLambda ( 'getReceipts' , event ) ; 
 const response = JSON . parse ( result . body ) ; 

 const usage = await sessionManager . incrementTokenUsage ( 1 ) ; 

 return { 
 receipts : response . receipts || [ response ] , 
 tokenUsage : usage
 } ; 
 } 
 } ; 
 Tool 6: Check Token Balance 
 javascript // app/mcp/tools/checkTokenBalance.js 
 export const checkTokenBalanceTool = { 
 name : 'check_token_balance' , 
 description : 'Check API token usage and remaining balance' , 
 inputSchema : { 
 type : 'object' , 
 properties : { } 
 } , 

 async handler ( params , context ) { 
 const { sessionManager , adaptor } = context ; 

 const accessToken = await sessionManager . getAccessToken ( ) ; 

 const event = { 
 httpMethod : 'GET' , 
 path : '/account/bundles' , 
 headers : { 
 'Authorization' : ` Bearer ${ accessToken } ` 
 } 
 } ; 

 const result = await adaptor . invokeLambda ( 'getBundles' , event ) ; 
 const response = JSON . parse ( result . body ) ; 

 const localUsage = await sessionManager . getTokenUsage ( ) ; 

 return { 
 bundles : response . bundles , 
 currentSession : localUsage , 
 tier : response . tier || 'guest' , 
 message : response . bundles . length === 0 
 ? 'No active bundles. Using guest tier.' 
 : ` You have ${ response . bundles . length } active bundle(s) ` 
 } ; 
 } 
 } ; 
 MCP to Lambda Adaptor 
 javascript // app/lib/mcpToLambdaAdaptor.js 
 import { logger } from './logger.js' ; 

 // Import Lambda handlers 
 import { handler as tokenExchangeHandler } from '../functions/auth/submit-auth-token-exchange-post.js' ; 
 import { handler as submitVatHandler } from '../functions/hmrc/submit-hmrc-vat-return-post.js' ; 
 import { handler as getVatReturnHandler } from '../functions/hmrc/submit-hmrc-vat-return-get.js' ; 
 import { handler as getObligationsHandler } from '../functions/hmrc/submit-hmrc-vat-obligation-get.js' ; 
 import { handler as getReceiptsHandler } from '../functions/hmrc/submit-hmrc-receipt-get.js' ; 
 import { handler as getBundlesHandler } from '../functions/account/submit-bundle-get.js' ; 

 export class McpToLambdaAdaptor { 
 constructor ( sessionManager ) { 
 this . sessionManager = sessionManager ; 
 this . lambdaHandlers = { 
 tokenExchange : tokenExchangeHandler , 
 submitVatReturn : submitVatHandler , 
 getVatReturn : getVatReturnHandler , 
 getVatObligations : getObligationsHandler , 
 getReceipts : getReceiptsHandler , 
 getBundles : getBundlesHandler
 } ; 
 } 

 async invokeLambda ( handlerName , event ) { 
 const handler = this . lambdaHandlers [ handlerName ] ; 
 if ( ! handler ) { 
 throw new Error ( ` Unknown Lambda handler: ${ handlerName } ` ) ; 
 } 

 logger . info ( ` Invoking Lambda: ${ handlerName } ` , { 
 method : event . httpMethod , 
 path : event . path 
 } ) ; 

 try { 
 const result = await handler ( event , { } ) ; 
 return result ; 
 } catch ( error ) { 
 logger . error ( ` Lambda invocation failed: ${ handlerName } ` , error ) ; 
 throw error ; 
 } 
 } 
 } 
 MCP Server Entry Point 
 javascript // app/bin/mcp-server.js 
 import { Server } from '@modelcontextprotocol/sdk/server/index.js' ; 
 import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js' ; 
 import { SessionManager } from '../lib/SessionManager.js' ; 
 import { MemoryStorage } from '../lib/storage/MemoryStorage.js' ; 
 import { McpToLambdaAdaptor } from '../lib/mcpToLambdaAdaptor.js' ; 
 import { tools } from '../mcp/tools/index.js' ; 
 import { logger } from '../lib/logger.js' ; 
 import dotenv from 'dotenv' ; 

 dotenv . config ( { path : '.env.mcp' } ) ; 

 const storage = new MemoryStorage ( ) ; 
 const sessionManager = new SessionManager ( storage ) ; 
 const adaptor = new McpToLambdaAdaptor ( sessionManager ) ; 

 const config = { 
 COGNITO_DOMAIN : process . env . COGNITO_DOMAIN , 
 COGNITO_CLIENT_ID : process . env . COGNITO_CLIENT_ID , 
 REDIRECT_URI : process . env . MCP_REDIRECT_URI || 'http://localhost:3000/auth/callback' 
 } ; 

 const server = new Server ( { 
 name : 'diy-accounting-submit' , 
 version : '1.0.0' , 
 } , { 
 capabilities : { tools : { } } 
 } ) ; 

 server . setRequestHandler ( 'tools/list' , async ( ) => { 
 logger . info ( 'Tools list requested' ) ; 
 return { 
 tools : tools . map ( tool => ( { 
 name : tool . name , 
 description : tool . description , 
 inputSchema : tool . inputSchema 
 } ) ) 
 } ; 
 } ) ; 

 server . setRequestHandler ( 'tools/call' , async ( request ) => { 
 const { name , arguments : params } = request . params ; 
 logger . info ( 'Tool called' , { name , params } ) ; 

 try { 
 const tool = tools . find ( t => t . name === name ) ; 
 if ( ! tool ) { 
 throw new Error ( ` Unknown tool: ${ name } ` ) ; 
 } 

 const context = { 
 sessionManager , 
 adaptor , 
 config , 
 lambdaHandlers : adaptor . lambdaHandlers 
 } ; 

 const result = await tool . handler ( params , context ) ; 

 return { 
 content : [ { 
 type : 'text' , 
 text : JSON . stringify ( result , null , 2 ) 
 } ] 
 } ; 
 } catch ( error ) { 
 logger . error ( 'Tool execution error' , { name , error : error . message } ) ; 
 return { 
 content : [ { 
 type : 'text' , 
 text : ` Error: ${ error . message } ` 
 } ] , 
 isError : true 
 } ; 
 } 
 } ) ; 

 async function main ( ) { 
 const transport = new StdioServerTransport ( ) ; 
 await server . connect ( transport ) ; 
 logger . info ( 'MCP server started' ) ; 
 } 

 main ( ) . catch ( error => { 
 logger . error ( 'Server startup error' , error ) ; 
 process . exit ( 1 ) ; 
 } ) ; 

 Testing Strategy 
 Testing Pyramid 
 ┌──────────────┐
 │ E2E MCP │ ← Full MCP client integration
 │ (Manual) │
 └──────────────┘
 ▲
 ┌──────────────┐
 │ Integration │ ← MCP server with mocked Lambda
 │ Tests │
 └──────────────┘
 ▲
 ┌──────────────┐
 │ Unit │ ← Storage, SessionManager, tools
 │ Tests │
 └──────────────┘ 
 Unit Tests 
 Scope: Test individual components in isolation 
 Location: app/mcp/unit-tests/ 
 Test Files: 

 storage.test.js - Test all storage implementations 
 sessionManager.test.js - Test session management logic 
 mcpToLambdaAdaptor.test.js - Test Lambda invocation adapter 
 tools/*.test.js - Test each tool's handler logic 

 Example: Storage Tests 
 javascript // app/mcp/unit-tests/storage.test.js 
 import { describe , it , expect , beforeEach } from 'vitest' ; 
 import { MemoryStorage } from '../../lib/storage/MemoryStorage.js' ; 

 describe ( 'MemoryStorage' , ( ) => { 
 let storage ; 

 beforeEach ( ( ) => { 
 storage = new MemoryStorage ( ) ; 
 } ) ; 

 it ( 'should store and retrieve values' , async ( ) => { 
 await storage . set ( 'key1' , 'value1' ) ; 
 const value = await storage . get ( 'key1' ) ; 
 expect ( value ) . toBe ( 'value1' ) ; 
 } ) ; 

 it ( 'should return null for non-existent keys' , async ( ) => { 
 const value = await storage . get ( 'nonexistent' ) ; 
 expect ( value ) . toBeNull ( ) ; 
 } ) ; 

 it ( 'should handle TTL expiration' , async ( ) => { 
 await storage . set ( 'key1' , 'value1' , { ttl : 1 } ) ; 

 // Immediately should exist 
 let value = await storage . get ( 'key1' ) ; 
 expect ( value ) . toBe ( 'value1' ) ; 

 // After TTL should be gone 
 await new Promise ( resolve => setTimeout ( resolve , 1100 ) ) ; 
 value = await storage . get ( 'key1' ) ; 
 expect ( value ) . toBeNull ( ) ; 
 } ) ; 

 it ( 'should delete values' , async ( ) => { 
 await storage . set ( 'key1' , 'value1' ) ; 
 const deleted = await storage . delete ( 'key1' ) ; 
 expect ( deleted ) . toBe ( true ) ; 

 const value = await storage . get ( 'key1' ) ; 
 expect ( value ) . toBeNull ( ) ; 
 } ) ; 

 it ( 'should clear all values' , async ( ) => { 
 await storage . set ( 'key1' , 'value1' ) ; 
 await storage . set ( 'key2' , 'value2' ) ; 

 await storage . clear ( ) ; 

 expect ( await storage . get ( 'key1' ) ) . toBeNull ( ) ; 
 expect ( await storage . get ( 'key2' ) ) . toBeNull ( ) ; 
 expect ( storage . size ( ) ) . toBe ( 0 ) ; 
 } ) ; 
 } ) ; 
 Example: SessionManager Tests 
 javascript // app/mcp/unit-tests/sessionManager.test.js 
 import { describe , it , expect , beforeEach } from 'vitest' ; 
 import { SessionManager } from '../../lib/SessionManager.js' ; 
 import { MemoryStorage } from '../../lib/storage/MemoryStorage.js' ; 

 describe ( 'SessionManager' , ( ) => { 
 let sessionManager ; 

 beforeEach ( ( ) => { 
 const storage = new MemoryStorage ( ) ; 
 sessionManager = new SessionManager ( storage ) ; 
 } ) ; 

 describe ( 'Token Management' , ( ) => { 
 it ( 'should store and retrieve access token' , async ( ) => { 
 await sessionManager . setAccessToken ( 'test-token' , 3600 ) ; 
 const token = await sessionManager . getAccessToken ( ) ; 
 expect ( token ) . toBe ( 'test-token' ) ; 
 } ) ; 

 it ( 'should detect valid access token' , async ( ) => { 
 expect ( await sessionManager . hasValidAccessToken ( ) ) . toBe ( false ) ; 

 await sessionManager . setAccessToken ( 'test-token' , 3600 ) ; 
 expect ( await sessionManager . hasValidAccessToken ( ) ) . toBe ( true ) ; 
 } ) ; 

 it ( 'should clear tokens' , async ( ) => { 
 await sessionManager . setAccessToken ( 'access' , 3600 ) ; 
 await sessionManager . setRefreshToken ( 'refresh' ) ; 

 await sessionManager . clearTokens ( ) ; 

 expect ( await sessionManager . getAccessToken ( ) ) . toBeNull ( ) ; 
 expect ( await sessionManager . getRefreshToken ( ) ) . toBeNull ( ) ; 
 } ) ; 
 } ) ; 

 describe ( 'Token Usage Tracking' , ( ) => { 
 it ( 'should initialize with default usage' , async ( ) => { 
 const usage = await sessionManager . getTokenUsage ( ) ; 
 expect ( usage ) . toEqual ( { used : 0 , limit : null , tier : 'guest' } ) ; 
 } ) ; 

 it ( 'should increment usage' , async ( ) => { 
 await sessionManager . incrementTokenUsage ( 1 ) ; 
 const usage = await sessionManager . getTokenUsage ( ) ; 
 expect ( usage . used ) . toBe ( 1 ) ; 

 await sessionManager . incrementTokenUsage ( 2 ) ; 
 const updated = await sessionManager . getTokenUsage ( ) ; 
 expect ( updated . used ) . toBe ( 3 ) ; 
 } ) ; 

 it ( 'should reset usage' , async ( ) => { 
 await sessionManager . incrementTokenUsage ( 5 ) ; 
 await sessionManager . resetTokenUsage ( ) ; 

 const usage = await sessionManager . getTokenUsage ( ) ; 
 expect ( usage . used ) . toBe ( 0 ) ; 
 } ) ; 
 } ) ; 

 describe ( 'Async Request Tracking' , ( ) => { 
 it ( 'should store and retrieve async request ID' , async ( ) => { 
 await sessionManager . setAsyncRequestId ( 'vat_return' , 'req-123' ) ; 
 const requestId = await sessionManager . getAsyncRequestId ( 'vat_return' ) ; 
 expect ( requestId ) . toBe ( 'req-123' ) ; 
 } ) ; 

 it ( 'should clear async request ID' , async ( ) => { 
 await sessionManager . setAsyncRequestId ( 'vat_return' , 'req-123' ) ; 
 await sessionManager . clearAsyncRequestId ( 'vat_return' ) ; 

 const requestId = await sessionManager . getAsyncRequestId ( 'vat_return' ) ; 
 expect ( requestId ) . toBeNull ( ) ; 
 } ) ; 
 } ) ; 
 } ) ; 
 Run Unit Tests: 
 bash # Add to package.json 
 "test:mcp:unit" : "vitest run app/mcp/unit-tests/" 

 # Run 
 npm run test:mcp:unit 
 Integration Tests 
 Scope: Test MCP server with mocked Lambda handlers 
 Location: app/mcp/integration-tests/ 
 Test Files: 

 mcp-server.test.js - Test full MCP server flow 
 authentication.test.js - Test auth flow 
 vat-submission.test.js - Test VAT submission flow 

 Example: MCP Server Integration Test 
 javascript // app/mcp/integration-tests/mcp-server.test.js 
 import { describe , it , expect , beforeEach , vi } from 'vitest' ; 
 import { McpToLambdaAdaptor } from '../../lib/mcpToLambdaAdaptor.js' ; 
 import { SessionManager } from '../../lib/SessionManager.js' ; 
 import { MemoryStorage } from '../../lib/storage/MemoryStorage.js' ; 
 import { authenticateTool } from '../../mcp/tools/authenticate.js' ; 

 describe ( 'MCP Server Integration' , ( ) => { 
 let sessionManager ; 
 let adaptor ; 
 let context ; 

 beforeEach ( ( ) => { 
 const storage = new MemoryStorage ( ) ; 
 sessionManager = new SessionManager ( storage ) ; 
 adaptor = new McpToLambdaAdaptor ( sessionManager ) ; 

 // Mock Lambda handlers 
 adaptor . lambdaHandlers . tokenExchange = vi . fn ( async ( event ) => ( { 
 statusCode : 200 , 
 body : JSON . stringify ( { 
 access_token : 'mock-access-token' , 
 refresh_token : 'mock-refresh-token' , 
 expires_in : 3600 , 
 user_sub : 'user-123' , 
 user_email : 'test@example.com' 
 } ) 
 } ) ) ; 

 context = { 
 sessionManager , 
 adaptor , 
 config : { 
 COGNITO_DOMAIN : 'https://cognito.example.com' , 
 COGNITO_CLIENT_ID : 'test-client-id' , 
 REDIRECT_URI : 'http://localhost:3000/callback' 
 } , 
 lambdaHandlers : adaptor . lambdaHandlers 
 } ; 
 } ) ; 

 describe ( 'Authentication Flow' , ( ) => { 
 it ( 'should return auth URL when no code provided' , async ( ) => { 
 const result = await authenticateTool . handler ( { } , context ) ; 

 expect ( result . authorizationUrl ) . toContain ( 'cognito.example.com' ) ; 
 expect ( result . authorizationUrl ) . toContain ( 'client_id=test-client-id' ) ; 
 expect ( result . instructions ) . toBeDefined ( ) ; 
 } ) ; 

 it ( 'should exchange code for tokens' , async ( ) => { 
 const result = await authenticateTool . handler ( { 
 authorizationCode : 'test-code' 
 } , context ) ; 

 expect ( result . success ) . toBe ( true ) ; 
 expect ( result . message ) . toContain ( 'test@example.com' ) ; 

 // Verify tokens were stored 
 const accessToken = await sessionManager . getAccessToken ( ) ; 
 expect ( accessToken ) . toBe ( 'mock-access-token' ) ; 

 const userEmail = await sessionManager . getUserEmail ( ) ; 
 expect ( userEmail ) . toBe ( 'test@example.com' ) ; 
 } ) ; 

 it ( 'should handle authentication failure' , async ( ) => { 
 adaptor . lambdaHandlers . tokenExchange = vi . fn ( async ( ) => ( { 
 statusCode : 401 , 
 body : JSON . stringify ( { message : 'Invalid code' } ) 
 } ) ) ; 

 await expect ( 
 authenticateTool . handler ( { authorizationCode : 'bad-code' } , context ) 
 ) . rejects . toThrow ( 'Invalid code' ) ; 
 } ) ; 
 } ) ; 
 } ) ; 
 Example: VAT Submission Integration Test 
 javascript // app/mcp/integration-tests/vat-submission.test.js 
 import { describe , it , expect , beforeEach , vi } from 'vitest' ; 
 import { submitVatReturnTool } from '../../mcp/tools/submitVatReturn.js' ; 
 import { pollVatReturnTool } from '../../mcp/tools/pollVatReturn.js' ; 
 import { SessionManager } from '../../lib/SessionManager.js' ; 
 import { MemoryStorage } from '../../lib/storage/MemoryStorage.js' ; 
 import { McpToLambdaAdaptor } from '../../lib/mcpToLambdaAdaptor.js' ; 

 describe ( 'VAT Submission Flow' , ( ) => { 
 let sessionManager ; 
 let adaptor ; 
 let context ; 

 beforeEach ( async ( ) => { 
 const storage = new MemoryStorage ( ) ; 
 sessionManager = new SessionManager ( storage ) ; 
 adaptor = new McpToLambdaAdaptor ( sessionManager ) ; 

 // Set up authenticated session 
 await sessionManager . setAccessToken ( 'test-token' , 3600 ) ; 

 // Mock Lambda handlers 
 adaptor . lambdaHandlers . submitVatReturn = vi . fn ( async ( ) => ( { 
 statusCode : 202 , 
 body : JSON . stringify ( { requestId : 'req-123' } ) 
 } ) ) ; 

 adaptor . lambdaHandlers . getVatReturn = vi . fn ( async ( ) => ( { 
 statusCode : 200 , 
 body : JSON . stringify ( { 
 status : 'completed' , 
 result : { processingDate : '2026-01-30' } 
 } ) 
 } ) ) ; 

 context = { sessionManager , adaptor } ; 
 } ) ; 

 it ( 'should submit VAT return and store request ID' , async ( ) => { 
 const vatData = { 
 periodKey : '#001' , 
 vatDueSales : 1000 , 
 vatDueAcquisitions : 0 , 
 totalVatDue : 1000 , 
 vatReclaimedCurrPeriod : 200 , 
 netVatDue : 800 , 
 totalValueSalesExVAT : 5000 , 
 totalValuePurchasesExVAT : 1000 , 
 totalValueGoodsSuppliedExVAT : 0 , 
 totalAcquisitionsExVAT : 0 
 } ; 

 const result = await submitVatReturnTool . handler ( vatData , context ) ; 

 expect ( result . requestId ) . toBe ( 'req-123' ) ; 
 expect ( result . status ) . toBe ( 'submitted' ) ; 

 // Verify request ID was stored 
 const storedId = await sessionManager . getAsyncRequestId ( 'vat_return' ) ; 
 expect ( storedId ) . toBe ( 'req-123' ) ; 

 // Verify token usage incremented 
 const usage = await sessionManager . getTokenUsage ( ) ; 
 expect ( usage . used ) . toBe ( 1 ) ; 
 } ) ; 

 it ( 'should poll VAT return using stored request ID' , async ( ) => { 
 // Store a request ID 
 await sessionManager . setAsyncRequestId ( 'vat_return' , 'req-123' ) ; 

 // Poll without providing request ID 
 const result = await pollVatReturnTool . handler ( { } , context ) ; 

 expect ( result . status ) . toBe ( 'completed' ) ; 

 // Verify request ID was cleared after completion 
 const storedId = await sessionManager . getAsyncRequestId ( 'vat_return' ) ; 
 expect ( storedId ) . toBeNull ( ) ; 
 } ) ; 

 it ( 'should fail if not authenticated' , async ( ) => { 
 await sessionManager . clearTokens ( ) ; 

 const vatData = { 
 periodKey : '#001' , 
 vatDueSales : 1000 , 
 vatDueAcquisitions : 0 , 
 totalVatDue : 1000 , 
 vatReclaimedCurrPeriod : 200 , 
 netVatDue : 800 , 
 totalValueSalesExVAT : 5000 , 
 totalValuePurchasesExVAT : 1000 , 
 totalValueGoodsSuppliedExVAT : 0 , 
 totalAcquisitionsExVAT : 0 
 } ; 

 await expect ( 
 submitVatReturnTool . handler ( vatData , context ) 
 ) . rejects . toThrow ( 'Not authenticated' ) ; 
 } ) ; 
 } ) ; 
 Run Integration Tests: 
 bash # Add to package.json 
 "test:mcp:integration" : "vitest run app/mcp/integration-tests/" 

 # Run 
 npm run test:mcp:integration 
 E2E Tests (Manual) 
 Scope: Test actual MCP server with Claude Desktop 
 Steps: 

 Build MCP server Docker image: 

 bash docker build -t diy-accounting-mcp -f mcp-server/Dockerfile . 

 Configure Claude Desktop: 

 json // ~/Library/Application Support/Claude/claude_desktop_config.json 
 { 
 "mcpServers" : { 
 "diy-accounting-submit" : { 
 "command" : "docker" , 
 "args" : [ 
 "run" , 
 "-i" , 
 "--rm" , 
 "-e" , "COGNITO_DOMAIN=https://your-domain.auth.eu-west-2.amazoncognito.com" , 
 "-e" , "COGNITO_CLIENT_ID=your-client-id" , 
 "diy-accounting-mcp" 
 ] 
 } 
 } 
 } 

 Manual Test Scenarios: 

 Scenario 1: Authentication 
 User: Authenticate with DIY Accounting Submit
 Claude: [calls authenticate tool without code]
 Claude: Please visit this URL: https://...
 User: [provides authorization code]
 Claude: [calls authenticate with code]
 Claude: Authenticated as test@example.com 
 Scenario 2: Get VAT Obligations 
 User: Show me my VAT obligations for 2025
 Claude: [calls get_vat_obligations with date range]
 Claude: You have 4 VAT obligations:
 - Period #001: Due 2025-05-07 (Open)
 - Period #002: Due 2025-08-07 (Open)
 ... 
 Scenario 3: Submit VAT Return 
 User: Submit VAT return for period #001 with these figures: [details]
 Claude: [calls submit_vat_return]
 Claude: VAT return submitted. Request ID: req-123
 Claude: [automatically calls poll_vat_return]
 Claude: Submission completed. Processing date: 2026-01-30 
 Scenario 4: Check Token Balance 
 User: How many API tokens do I have left?
 Claude: [calls check_token_balance]
 Claude: You have 1 active bundle with 47 tokens remaining.
 Current session: 3 tokens used 
 CI Testing 
 GitHub Actions Workflow: 
 yaml # .github/workflows/test-mcp.yml 
 name : Test MCP Server

 on : 
 push : 
 paths : 
 - 'app/mcp/**' 
 - 'app/lib/storage/**' 
 - 'app/lib/SessionManager.js' 
 - 'app/lib/mcpToLambdaAdaptor.js' 
 pull_request : 
 paths : 
 - 'app/mcp/**' 

 jobs : 
 unit-tests : 
 runs-on : ubuntu - latest
 steps : 
 - uses : actions/checkout@v4

 - name : Setup Node.js
 uses : actions/setup - node@v4
 with : 
 node-version : '22' 

 - name : Install dependencies
 run : npm ci

 - name : Run MCP unit tests
 run : npm run test : mcp : unit

 - name : Upload coverage
 uses : codecov/codecov - action@v3
 with : 
 files : ./coverage/lcov.info

 integration-tests : 
 runs-on : ubuntu - latest
 steps : 
 - uses : actions/checkout@v4

 - name : Setup Node.js
 uses : actions/setup - node@v4
 with : 
 node-version : '22' 

 - name : Install dependencies
 run : npm ci

 - name : Run MCP integration tests
 run : npm run test : mcp : integration

 docker-build : 
 runs-on : ubuntu - latest
 steps : 
 - uses : actions/checkout@v4

 - name : Build Docker image
 run : docker build - t diy - accounting - mcp - f mcp - server/Dockerfile .

 - name : Test Docker image starts
 run : | 
 docker run -i --rm diy-accounting-mcp &
 PID=$!
 sleep 5
 kill $PID || true 

 Rollout Strategy 
 Phase 1: Foundation (Weeks 1-2) 
 Goal: Build core infrastructure without disrupting existing system 
 Tasks: 

 ✅ Create storage abstraction layer 

 app/lib/storage/StorageInterface.js 
 app/lib/storage/MemoryStorage.js 
 app/lib/storage/BrowserStorage.js 
 Unit tests for storage implementations 

 ✅ Extract and abstract session management 

 app/lib/SessionManager.js 
 Unit tests for SessionManager 
 Update web widgets to use new SessionManager (backwards compatible) 

 ✅ Create MCP adapter 

 app/lib/mcpToLambdaAdaptor.js 
 Unit tests for adapter 

 Success Criteria: 

 All existing tests pass 
 New unit tests have >90% coverage 
 Web client still works with new SessionManager 

 Testing: 
 bash npm run test:unit
 npm run test:mcp:unit
 npm run test:browser 
 Phase 2: MCP Tools (Weeks 3-4) 
 Goal: Implement MCP tool definitions 
 Tasks: 

 ✅ Create tool definitions 

 app/mcp/tools/index.js 
 app/mcp/tools/authenticate.js 
 app/mcp/tools/submitVatReturn.js 
 app/mcp/tools/pollVatReturn.js 
 app/mcp/tools/getVatObligations.js 
 app/mcp/tools/getReceipts.js 
 app/mcp/tools/checkTokenBalance.js 

 ✅ Create integration tests 

 Test authentication flow 
 Test VAT submission flow 
 Test error handling 

 ✅ Create MCP server entry point 

 app/bin/mcp-server.js 
 Environment configuration .env.mcp 

 Success Criteria: 

 All MCP tools have integration tests 
 MCP server can start locally 
 Tools can invoke Lambda handlers 

 Testing: 
 bash npm run test:mcp:integration

 # Start MCP server locally 
 node app/bin/mcp-server.js 
 Phase 3: Docker Packaging (Week 5) 
 Goal: Package MCP server as Docker container 
 Tasks: 

 ✅ Create Dockerfile 

 mcp-server/Dockerfile 
 Optimize for size and startup time 

 ✅ Create docker-compose for local testing 

 mcp-server/docker-compose.yml 
 Include all necessary environment variables 

 ✅ Update package.json scripts 

 npm run mcp:build 
 npm run mcp:run 
 npm run mcp:dev 

 ✅ Add GitHub Actions workflow 

 Build Docker image on push 
 Publish to GitHub Packages 

 Success Criteria: 

 Docker image builds successfully 
 Can run MCP server in container 
 Image size < 500MB 

 Testing: 
 bash npm run mcp:build
 npm run mcp:run

 # Test with Docker 
 docker run -i diy-accounting-mcp 
 Phase 4: Alpha Testing (Week 6) 
 Goal: Test with real users in controlled environment 
 Tasks: 

 ✅ Deploy to private registry 

 Publish to GitHub Packages (private) 
 Create installation documentation 

 ✅ Recruit 3-5 alpha testers 

 Technical users comfortable with Docker 
 Existing DIY Accounting Submit users 
 Mix of Mac and Windows users 

 ✅ Monitor and collect feedback 

 Track usage via CloudWatch 
 Daily check-ins with alpha testers 
 Document issues and feature requests 

 ✅ Iterate based on feedback 

 Fix critical bugs 
 Improve error messages 
 Update documentation 

 Success Criteria: 

 3+ successful VAT submissions via MCP 
 No critical bugs reported 
 Average user satisfaction >4/5 

 Alpha Tester Setup: 
 bash # Pull image 
 docker pull ghcr.io/antonycc/submit.diyaccounting.co.uk/mcp-server:alpha

 # Configure Claude Desktop 
 # [instructions in documentation] 
 Phase 5: Beta Launch (Weeks 7-8) 
 Goal: Soft launch to broader audience 
 Tasks: 

 ✅ Make repository public 

 Update README with MCP instructions 
 Add MCP server documentation 
 Create setup guide for Claude Desktop 

 ✅ Announce to existing users 

 Email announcement 
 Blog post on DIY Accounting site 
 Social media (LinkedIn, Twitter) 

 ✅ Create marketing materials 

 Demo video showing MCP workflow 
 Screenshots for documentation 
 FAQ document 

 ✅ Monitor usage and support 

 Set up Slack/Discord for support 
 Weekly office hours for questions 
 Track metrics (installations, submissions) 

 Success Criteria: 

 20+ beta users 
 50+ VAT submissions via MCP 
 <24hr response time on issues 

 Marketing Message: 

 "Automate your VAT filing with AI. DIY Accounting Submit now works with Claude Desktop - submit VAT returns, check obligations, and manage your account without leaving your conversation with Claude." 

 Phase 6: General Availability (Week 9+) 
 Goal: Full public launch with ongoing support 
 Tasks: 

 ✅ Official announcement 

 Press release 
 Launch on Product Hunt 
 Hacker News post 

 ✅ Documentation polish 

 Complete setup guide 
 Troubleshooting section 
 Video tutorials 

 ✅ Pricing tier for MCP users 

 Decide if MCP requires premium tier 
 Or same pricing as web/API 

 ✅ Plan EU expansion 

 Begin Peppol integration research 
 Connect with ViDA implementation timeline 
 Identify first EU country (Netherlands) 

 Success Criteria: 

 100+ active MCP users in first month 
 Featured in MCP server directory 
 Positive reviews/testimonials 

 Ongoing Maintenance: 

 Weekly dependency updates 
 Monthly feature releases 
 Quarterly user surveys 

 Rollback Plan 
 If critical issues arise: 

 Immediate: Unpublish Docker image from GitHub Packages 
 Communication: Email all MCP users about issue 
 Investigation: Debug in staging environment 
 Fix: Deploy patch within 48 hours 
 Resume: Republish with version bump 

 Rollback doesn't affect: 

 Web client (separate codebase) 
 API users (no changes to Lambda handlers) 
 Existing VAT submissions (all data in DynamoDB) 

 Implementation Checklist 
 Pre-Implementation 

 Review existing repository structure 
 Understand current Lambda handler patterns 
 Identify web widget session management code to extract 
 Set up local development environment with MCP SDK 

 Week 1-2: Foundation 

 Create app/lib/storage/ directory 
 Implement StorageInterface.js 
 Implement MemoryStorage.js 
 Implement BrowserStorage.js 
 Write storage unit tests (>90% coverage) 
 Create app/lib/SessionManager.js 
 Write SessionManager unit tests 
 Update web widgets to use SessionManager 
 Verify all existing tests pass 
 Create app/lib/mcpToLambdaAdaptor.js 
 Write adapter unit tests 

 Week 3-4: MCP Tools 

 Create app/mcp/tools/ directory 
 Implement index.js (tool registry) 
 Implement authenticate.js 
 Implement submitVatReturn.js 
 Implement pollVatReturn.js 
 Implement getVatObligations.js 
 Implement getReceipts.js 
 Implement checkTokenBalance.js 
 Create app/mcp/integration-tests/ directory 
 Write authentication integration tests 
 Write VAT submission integration tests 
 Write obligation/receipt integration tests 
 Create app/bin/mcp-server.js 
 Create .env.mcp configuration file 
 Test MCP server locally with stdio 

 Week 5: Docker Packaging 

 Create mcp-server/Dockerfile 
 Create mcp-server/docker-compose.yml 
 Add mcp:build script to package.json 
 Add mcp:run script to package.json 
 Add mcp:dev script to package.json 
 Create .github/workflows/test-mcp.yml 
 Create .github/workflows/publish-mcp.yml 
 Test Docker build locally 
 Test Docker run locally 
 Verify CI builds pass 

 Week 6: Alpha Testing 

 Publish Docker image to GitHub Packages (private) 
 Create alpha tester documentation 
 Recruit 3-5 alpha testers 
 Set up monitoring/logging 
 Conduct daily check-ins 
 Document all feedback 
 Fix critical bugs 
 Update documentation based on feedback 
 Get sign-off from alpha testers 

 Week 7-8: Beta Launch 

 Make repository public 
 Update README with MCP section 
 Create MCP setup guide 
 Create demo video 
 Write launch blog post 
 Send email to existing users 
 Post on social media 
 Set up support channel (Slack/Discord) 
 Monitor metrics daily 
 Weekly office hours for questions 
 Collect testimonials 

 Week 9+: General Availability 

 Write press release 
 Launch on Product Hunt 
 Post to Hacker News 
 Complete documentation polish 
 Decide on MCP pricing tier 
 Plan EU expansion roadmap 
 Set up user feedback loop 
 Monthly feature planning 
 Quarterly user surveys 

 Success Metrics 
 Technical Metrics 

 Test Coverage: >90% for MCP code 
 Build Time: <5 minutes 
 Docker Image Size: <500MB 
 Startup Time: <2 seconds 
 Memory Usage: <100MB at idle 

 User Metrics 

 Alpha (Week 6): 3+ users, 10+ submissions 
 Beta (Week 8): 20+ users, 50+ submissions 
 GA (Month 1): 100+ users, 200+ submissions 
 GA (Month 3): 300+ users, 1000+ submissions 

 Business Metrics 

 Installation Rate: >10% of existing users try MCP 
 Retention Rate: >70% of MCP users submit second VAT return 
 Support Burden: <10% increase in support tickets 
 Revenue Impact: Track MCP user upgrades to paid tiers 

 Risk Assessment 
 Technical Risks 
 Risk: Session storage doesn't persist across container restarts 
 Mitigation: Document this limitation; plan DynamoDB storage for Phase 2 
 Impact: Medium - users need to re-authenticate after restart 
 Risk: MCP SDK breaking changes 
 Mitigation: Pin to specific version; monitor releases 
 Impact: Low - can update and redeploy quickly 
 Risk: Lambda handler changes break MCP adapter 
 Mitigation: Integration tests catch this; shared codebase 
 Impact: Low - caught in CI 
 User Experience Risks 
 Risk: OAuth flow confusing in CLI context 
 Mitigation: Clear instructions; consider device flow in future 
 Impact: Medium - may lose less technical users 
 Risk: Async VAT submission UX unclear 
 Mitigation: Auto-poll in Claude; clear status messages 
 Impact: Low - Claude can handle polling gracefully 
 Business Risks 
 Risk: Low adoption due to technical barrier 
 Mitigation: Target technical users first; great documentation 
 Impact: Medium - still validates concept for EU expansion 
 Risk: Support burden too high 
 Mitigation: Comprehensive docs; community support channel 
 Impact: Low - technical users more self-sufficient 

 Next Steps 

 Review this document with stakeholders 
 Set up project tracking (GitHub Projects or similar) 
 Begin Phase 1 implementation 
 Schedule weekly check-ins to track progress 
 Prepare for alpha testing (recruit testers early) 

 Appendix A: File Structure 
 submit.diyaccounting.co.uk/
 ├── .env.mcp # NEW
 ├── .github/
 │ └── workflows/
 │ ├── test-mcp.yml # NEW
 │ └── publish-mcp.yml # NEW
 ├── app/
 │ ├── bin/
 │ │ ├── mcp-server.js # NEW
 │ │ ├── server.js # EXISTING
 │ │ └── ...
 │ ├── functions/ # EXISTING (reused)
 │ ├── services/ # EXISTING (reused)
 │ ├── data/ # EXISTING (reused)
 │ ├── lib/
 │ │ ├── storage/ # NEW
 │ │ │ ├── StorageInterface.js
 │ │ │ ├── MemoryStorage.js
 │ │ │ ├── BrowserStorage.js
 │ │ │ └── DynamoDBStorage.js
 │ │ ├── SessionManager.js # NEW
 │ │ ├── mcpToLambdaAdaptor.js # NEW
 │ │ ├── logger.js # EXISTING
 │ │ └── ...
 │ └── mcp/ # NEW
 │ ├── tools/
 │ │ ├── index.js
 │ │ ├── authenticate.js
 │ │ ├── submitVatReturn.js
 │ │ ├── pollVatReturn.js
 │ │ ├── getVatObligations.js
 │ │ ├── getReceipts.js
 │ │ └── checkTokenBalance.js
 │ ├── unit-tests/
 │ │ ├── storage.test.js
 │ │ ├── sessionManager.test.js
 │ │ ├── mcpToLambdaAdaptor.test.js
 │ │ └── tools/
 │ └── integration-tests/
 │ ├── mcp-server.test.js
 │ ├── authentication.test.js
 │ └── vat-submission.test.js
 ├── mcp-server/ # NEW
 │ ├── Dockerfile
 │ ├── docker-compose.yml
 │ └── README.md
 ├── web/ # EXISTING
 ├── package.json # UPDATE
 └── README.md # UPDATE 
 Appendix B: Environment Variables 
 bash # .env.mcp 
 ENVIRONMENT_NAME = mcp
 DEPLOYMENT_NAME = mcp-local

 # MCP-specific 
 MCP_REDIRECT_URI = http://localhost:3000/auth/callback

 # Reuse from existing .env files 
 COGNITO_USER_POOL_ID = eu-west-2_xxxxx
 COGNITO_CLIENT_ID = xxxxx
 COGNITO_DOMAIN = https://xxx.auth.eu-west-2.amazoncognito.com

 # DynamoDB (use local dynalite for dev) 
 BUNDLES_DYNAMODB_TABLE_NAME = mcp-bundles
 RECEIPTS_DYNAMODB_TABLE_NAME = mcp-receipts
 HMRC_API_REQUESTS_DYNAMODB_TABLE_NAME = mcp-hmrc-requests

 # HMRC (use sandbox for dev) 
 HMRC_BASE_URI = https://test-api.service.hmrc.gov.uk
 HMRC_CLIENT_ID = your-sandbox-client-id

 # Logging 
 LOG_LEVEL = debug 
 Appendix C: Docker Configuration 
 dockerfile # mcp-server/Dockerfile 
 FROM public.ecr.aws/lambda/nodejs:22 

 # Copy app code 
 COPY app/ ${LAMBDA_TASK_ROOT} /app/ 
 COPY package.json package-lock.json ${LAMBDA_TASK_ROOT} / 

 # Install dependencies 
 RUN npm ci --omit=dev 

 # Install MCP SDK 
 RUN npm install @modelcontextprotocol/sdk 

 # Set MCP server as entry point 
 CMD [ "node" , "app/bin/mcp-server.js" ] 
 yaml # mcp-server/docker-compose.yml 
 version : '3.8' 

 services : 
 mcp-server : 
 build : 
 context : ..
 dockerfile : mcp - server/Dockerfile
 environment : 
 - COGNITO_USER_POOL_ID=$ { COGNITO_USER_POOL_ID } 
 - COGNITO_CLIENT_ID=$ { COGNITO_CLIENT_ID } 
 - COGNITO_DOMAIN=$ { COGNITO_DOMAIN } 
 - MCP_REDIRECT_URI=http : //localhost : 3000/auth/callback
 - LOG_LEVEL=debug
 stdin_open : true 
 tty : true 

 End of Document Content is user-generated and unverified. MCP Server Implementation Guide for DIY Accounting | Claude